/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
import { __decorate } from '/web-component-designer-demo/node_modules/tslib/tslib.es6.js';
import { html, SpectrumElement, } from '/web-component-designer-demo/node_modules/@spectrum-web-components/base/./src/index.js';
import { ifDefined } from '/web-component-designer-demo/node_modules/@spectrum-web-components/base/src/directives.js';
import { property, query, } from '/web-component-designer-demo/node_modules/@spectrum-web-components/base/src/decorators.js';
import { streamingListener } from '/web-component-designer-demo/node_modules/@spectrum-web-components/base/src/streaming-listener.js';
import { extractHueAndSaturationRegExp, replaceHueRegExp, } from '/web-component-designer-demo/node_modules/@spectrum-web-components/color-handle/src/index.js';
import '/web-component-designer-demo/node_modules/@spectrum-web-components/color-handle/sp-color-handle.js';
import { TinyColor } from '/web-component-designer-demo/node_modules/@ctrl/tinycolor/dist/module/public_api.js';
import styles from './color-area.css.js';
/**
 * @element sp-color-area
 * @slot gradient - a custom gradient visually outlining the available color values
 * @fires input - The value of the Color Area has changed.
 * @fires change - An alteration to the value of the Color Area has been committed by the user.
 */
export class ColorArea extends SpectrumElement {
    constructor() {
        super(...arguments);
        this.disabled = false;
        this.focused = false;
        this.labelX = 'saturation';
        this.labelY = 'luminosity';
        this._hue = 0;
        this._color = new TinyColor({ h: 0, s: 1, v: 1 });
        this._previousColor = new TinyColor({ h: 0, s: 1, v: 1 });
        this._format = {
            format: '',
            isString: false,
        };
        this.activeAxis = 'x';
        this._x = 1;
        this._y = 0;
        this.step = 0.01;
        this.altered = 0;
        this.activeKeys = new Set();
        this._pointerDown = false;
    }
    static get styles() {
        return [styles];
    }
    get hue() {
        return this._hue;
    }
    set hue(value) {
        const hue = Math.min(360, Math.max(0, value));
        if (hue === this.hue) {
            return;
        }
        const oldValue = this.hue;
        const { s, v } = this._color.toHsv();
        this._color = new TinyColor({ h: hue, s, v });
        this._hue = hue;
        this.requestUpdate('hue', oldValue);
    }
    get value() {
        return this.color;
    }
    get color() {
        switch (this._format.format) {
            case 'rgb':
                return this._format.isString
                    ? this._color.toRgbString()
                    : this._color.toRgb();
            case 'prgb':
                return this._format.isString
                    ? this._color.toPercentageRgbString()
                    : this._color.toPercentageRgb();
            case 'hex8':
                return this._format.isString
                    ? this._color.toHex8String()
                    : this._color.toHex8();
            case 'name':
                return this._color.toName() || this._color.toRgbString();
            case 'hsl':
                if (this._format.isString) {
                    const hslString = this._color.toHslString();
                    return hslString.replace(replaceHueRegExp, `$1${this.hue}`);
                }
                else {
                    const { s, l, a } = this._color.toHsl();
                    return { h: this.hue, s, l, a };
                }
            case 'hsv':
                if (this._format.isString) {
                    const hsvString = this._color.toHsvString();
                    return hsvString.replace(replaceHueRegExp, `$1${this.hue}`);
                }
                else {
                    const { s, v, a } = this._color.toHsv();
                    return { h: this.hue, s, v, a };
                }
            case 'hex':
            case 'hex3':
            case 'hex4':
            case 'hex6':
            default:
                return this._format.isString
                    ? this._color.toHexString()
                    : this._color.toHex();
        }
    }
    set color(color) {
        if (color === this.color) {
            return;
        }
        const oldValue = this._color;
        this._color = new TinyColor(color);
        const format = this._color.format;
        let isString = typeof color === 'string' || color instanceof String;
        if (format.startsWith('hex')) {
            isString = color.startsWith('#');
        }
        this._format = {
            format,
            isString,
        };
        const { h, s, v } = this._color.toHsv();
        let originalHue = undefined;
        if (isString && format.startsWith('hs')) {
            const values = extractHueAndSaturationRegExp.exec(color);
            if (values !== null) {
                const [, h] = values;
                originalHue = Number(h);
            }
        }
        else if (!isString && format.startsWith('hs')) {
            const colorInput = this._color.originalInput;
            const colorValues = Object.values(colorInput);
            originalHue = colorValues[0];
        }
        this.hue = originalHue || h;
        this.x = s;
        this.y = 1 - v;
        this.requestUpdate('color', oldValue);
    }
    get x() {
        return this._x;
    }
    set x(x) {
        if (x === this.x) {
            return;
        }
        const oldValue = this.x;
        if (this.inputX) {
            // Use the native `input[type='range']` control to validate this value after `firstUpdate`
            this.inputX.value = x.toString();
            this._x = this.inputX.valueAsNumber;
        }
        else {
            this._x = x;
        }
        this.requestUpdate('x', oldValue);
    }
    get y() {
        return this._y;
    }
    set y(y) {
        if (y === this.y) {
            return;
        }
        const oldValue = this.y;
        if (this.inputY) {
            // Use the native `input[type='range']` control to validate this value after `firstUpdate`
            this.inputY.value = y.toString();
            this._y = this.inputY.valueAsNumber;
        }
        else {
            this._y = y;
        }
        this.requestUpdate('y', oldValue);
    }
    focus(focusOptions = {}) {
        super.focus(focusOptions);
        this.forwardFocus();
    }
    forwardFocus() {
        this.focused = this.hasVisibleFocusInTree();
        if (this.activeAxis === 'x') {
            this.inputX.focus();
        }
        else {
            this.inputY.focus();
        }
    }
    handleFocusin() {
        this.focused = true;
    }
    handleFocusout() {
        if (this._pointerDown) {
            return;
        }
        this.focused = false;
    }
    handleKeydown(event) {
        const { code } = event;
        this.focused = true;
        this.altered = [event.shiftKey, event.ctrlKey, event.altKey].filter((key) => !!key).length;
        const isArrowKey = code.search('Arrow') === 0;
        if (isArrowKey) {
            event.preventDefault();
            this.activeKeys.add(code);
            this.handleKeypress();
        }
    }
    handleKeypress() {
        let deltaX = 0;
        let deltaY = 0;
        const step = Math.max(this.step, this.altered * 5 * this.step);
        this.activeKeys.forEach((code) => {
            switch (code) {
                case 'ArrowUp':
                    deltaY = step * -1;
                    break;
                case 'ArrowDown':
                    deltaY = step * 1;
                    break;
                case 'ArrowLeft':
                    deltaX = step * -1;
                    break;
                case 'ArrowRight':
                    deltaX = step * 1;
                    break;
                /* c8 ignore next 2 */
                default:
                    break;
            }
        });
        if (deltaX != 0) {
            this.activeAxis = 'x';
            this.inputX.focus();
        }
        else if (deltaY != 0) {
            this.activeAxis = 'y';
            this.inputY.focus();
        }
        this.x = Math.min(1, Math.max(this.x + deltaX, 0));
        this.y = Math.min(1, Math.max(this.y + deltaY, 0));
        this._previousColor = this._color.clone();
        this._color = new TinyColor({ h: this.hue, s: this.x, v: 1 - this.y });
        if (deltaX != 0 || deltaY != 0) {
            this.dispatchEvent(new Event('input', {
                bubbles: true,
                composed: true,
            }));
            const applyDefault = this.dispatchEvent(new Event('change', {
                bubbles: true,
                composed: true,
                cancelable: true,
            }));
            if (!applyDefault) {
                this._color = this._previousColor;
            }
        }
    }
    handleKeyup(event) {
        event.preventDefault();
        const { code } = event;
        this.activeKeys.delete(code);
    }
    handleInput(event) {
        const { valueAsNumber, name } = event.target;
        this[name] = valueAsNumber;
        this._color = new TinyColor({ h: this.hue, s: this.x, v: 1 - this.y });
    }
    handleChange(event) {
        this.handleInput(event);
        this.dispatchEvent(new Event('change', {
            bubbles: true,
            composed: true,
            cancelable: true,
        }));
    }
    handlePointerdown(event) {
        if (event.button !== 0) {
            event.preventDefault();
            return;
        }
        this._pointerDown = true;
        this._previousColor = this._color.clone();
        this.boundingClientRect = this.getBoundingClientRect();
        event.target.setPointerCapture(event.pointerId);
        if (event.pointerType === 'mouse') {
            this.focused = true;
        }
    }
    handlePointermove(event) {
        const [x, y] = this.calculateHandlePosition(event);
        this._color = new TinyColor({ h: this.hue, s: x, v: 1 - y });
        this.x = x;
        this.y = y;
        this.dispatchEvent(new Event('input', {
            bubbles: true,
            composed: true,
            cancelable: true,
        }));
    }
    handlePointerup(event) {
        event.preventDefault();
        this._pointerDown = false;
        event.target.releasePointerCapture(event.pointerId);
        const applyDefault = this.dispatchEvent(new Event('change', {
            bubbles: true,
            composed: true,
            cancelable: true,
        }));
        this.inputX.focus();
        if (event.pointerType === 'mouse') {
            this.focused = false;
        }
        if (!applyDefault) {
            this._color = this._previousColor;
        }
    }
    /**
     * Returns the value under the cursor
     * @param: PointerEvent on slider
     * @return: Slider value that correlates to the position under the pointer
     */
    calculateHandlePosition(event) {
        /* c8 ignore next 3 */
        if (!this.boundingClientRect) {
            return [this.x, this.y];
        }
        const rect = this.boundingClientRect;
        const minOffsetX = rect.left;
        const minOffsetY = rect.top;
        const offsetX = event.clientX;
        const offsetY = event.clientY;
        const width = rect.width;
        const height = rect.height;
        const percentX = Math.max(0, Math.min(1, (offsetX - minOffsetX) / width));
        const percentY = Math.max(0, Math.min(1, (offsetY - minOffsetY) / height));
        return [percentX, percentY];
    }
    handleAreaPointerdown(event) {
        if (event.button !== 0) {
            return;
        }
        event.stopPropagation();
        event.preventDefault();
        this.handle.dispatchEvent(new PointerEvent('pointerdown', event));
        this.handlePointermove(event);
    }
    render() {
        var _a, _b;
        const { width = 0, height = 0 } = this.boundingClientRect || {};
        return html `
            <div
                @pointerdown=${this.handleAreaPointerdown}
                class="gradient"
                style="background:
                    linear-gradient(to top, black 0%, hsla(${this
            .hue}, 100%, 0.01%, 0) 100%),
                    linear-gradient(to right, white 0%, hsla(${this
            .hue}, 100%, 0.01%, 0) 100%), hsl(${this.hue}, 100%, 50%);"
            >
                <slot name="gradient"></slot>
            </div>

            <sp-color-handle
                tabindex=${ifDefined(this.focused ? undefined : '0')}
                @focus=${this.forwardFocus}
                ?focused=${this.focused}
                class="handle"
                color=${this._color.toHslString()}
                ?disabled=${this.disabled}
                style="transform: translate(${this.x * width}px, ${this.y *
            height}px);"
                ${streamingListener({
            start: ['pointerdown', this.handlePointerdown],
            streamInside: ['pointermove', this.handlePointermove],
            end: [['pointerup', 'pointercancel'], this.handlePointerup],
        })}
            ></sp-color-handle>

            <div>
                <input
                    type="range"
                    class="slider"
                    name="x"
                    aria-label=${(_a = this.label) !== null && _a !== void 0 ? _a : this.labelX}
                    min="0"
                    max="1"
                    step=${this.step}
                    tabindex="-1"
                    .value=${String(this.x)}
                    @input=${this.handleInput}
                    @change=${this.handleChange}
                />
            </div>
            <div>
                <input
                    type="range"
                    class="slider"
                    name="y"
                    aria-label=${(_b = this.label) !== null && _b !== void 0 ? _b : this.labelY}
                    min="0"
                    max="1"
                    step=${this.step}
                    tabindex="-1"
                    .value=${String(this.y)}
                    @input=${this.handleInput}
                    @change=${this.handleChange}
                />
            </div>
        `;
    }
    firstUpdated(changed) {
        super.firstUpdated(changed);
        this.boundingClientRect = this.getBoundingClientRect();
        this.addEventListener('focusin', this.handleFocusin);
        this.addEventListener('focusout', this.handleFocusout);
        this.addEventListener('keyup', this.handleKeyup);
        this.addEventListener('keydown', this.handleKeydown);
    }
    updated(changed) {
        super.updated(changed);
        if (this.x !== this.inputX.valueAsNumber) {
            this.x = this.inputX.valueAsNumber;
        }
        if (this.y !== this.inputY.valueAsNumber) {
            this.y = this.inputY.valueAsNumber;
        }
        if (changed.has('focused') && this.focused) {
            // Lazily bind the `input[type="range"]` elements in shadow roots
            // so that browsers with certain settings (Webkit) aren't allowed
            // multiple tab stops within the Color Area.
            const parentX = this.inputX.parentElement;
            const parentY = this.inputY.parentElement;
            if (!parentX.shadowRoot && !parentY.shadowRoot) {
                parentX.attachShadow({ mode: 'open' });
                parentY.attachShadow({ mode: 'open' });
                const slot = '<div tabindex="-1"><slot></slot></div>';
                parentX.shadowRoot.innerHTML = slot;
                parentY.shadowRoot.innerHTML = slot;
            }
        }
    }
    connectedCallback() {
        var _a;
        super.connectedCallback();
        if (!this.observer &&
            window.ResizeObserver) {
            this.observer = new window.ResizeObserver((entries) => {
                for (const entry of entries) {
                    this.boundingClientRect = entry.contentRect;
                }
                this.requestUpdate();
            });
        }
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.observe(this);
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.unobserve(this);
        super.disconnectedCallback();
    }
}
__decorate([
    property({ type: Boolean, reflect: true })
], ColorArea.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], ColorArea.prototype, "focused", void 0);
__decorate([
    property({ type: String })
], ColorArea.prototype, "label", void 0);
__decorate([
    property({ type: String, attribute: 'label-x' })
], ColorArea.prototype, "labelX", void 0);
__decorate([
    property({ type: String, attribute: 'label-y' })
], ColorArea.prototype, "labelY", void 0);
__decorate([
    query('.handle')
], ColorArea.prototype, "handle", void 0);
__decorate([
    property({ type: Number })
], ColorArea.prototype, "hue", null);
__decorate([
    property({ type: String })
], ColorArea.prototype, "value", null);
__decorate([
    property({ type: String })
], ColorArea.prototype, "color", null);
__decorate([
    property({ attribute: false })
], ColorArea.prototype, "activeAxis", void 0);
__decorate([
    property({ type: Number })
], ColorArea.prototype, "x", null);
__decorate([
    property({ type: Number })
], ColorArea.prototype, "y", null);
__decorate([
    property({ type: Number })
], ColorArea.prototype, "step", void 0);
__decorate([
    query('[name="x"]')
], ColorArea.prototype, "inputX", void 0);
__decorate([
    query('[name="y"]')
], ColorArea.prototype, "inputY", void 0);
//# sourceMappingURL=ColorArea.js.map