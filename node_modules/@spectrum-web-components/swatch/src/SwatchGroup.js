/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
import { __decorate } from '/web-component-designer-demo/node_modules/tslib/tslib.es6.js';
import { html, SizedMixin, SpectrumElement, } from '/web-component-designer-demo/node_modules/@spectrum-web-components/base/./src/index.js';
import { RovingTabindexController } from '/web-component-designer-demo/node_modules/@spectrum-web-components/reactive-controllers/src/RovingTabindex.js';
import { MutationController } from '/web-component-designer-demo/node_modules/@lit-labs/observers/mutation_controller.js';
import { property } from '/web-component-designer-demo/node_modules/lit/decorators.js';
import styles from './swatch-group.css.js';
/**
 * @element sp-swatch-group
 *
 * @slot - Swatch elements to manage as a group
 */
export class SwatchGroup extends SizedMixin(SpectrumElement, {
    validSizes: ['xs', 's', 'm', 'l'],
}) {
    constructor() {
        super();
        this._selected = [];
        this.selectedSet = new Set();
        this.rovingTabindexController = new RovingTabindexController(this, {
            focusInIndex: (elements) => {
                let firstEnabledIndex = -1;
                const firstSelectedIndex = elements.findIndex((el, index) => {
                    if (!elements[firstEnabledIndex] && !el.disabled) {
                        firstEnabledIndex = index;
                    }
                    return el.selected && !el.disabled;
                });
                return elements[firstSelectedIndex]
                    ? firstSelectedIndex
                    : firstEnabledIndex;
            },
            elements: () => [...this.children],
            isFocusableElement: (el) => !el.disabled,
        });
        this.manageChange = () => {
            const presentSet = new Set();
            this.selectedSet = new Set(this.selected);
            const swatches = [...this.children];
            swatches.forEach((swatch) => {
                presentSet.add(swatch.value);
                if (swatch.selected) {
                    this.selectedSet.add(swatch.value);
                }
            });
            this.selectedSet.forEach((value) => {
                if (!presentSet.has(value)) {
                    this.selectedSet.delete(value);
                }
            });
            this._selected = [...this.selectedSet];
        };
        new MutationController(this, {
            config: {
                attributes: true,
                childList: true,
                subtree: true,
            },
            callback: () => {
                this.manageChange();
            },
        });
    }
    static get styles() {
        return [styles];
    }
    get selected() {
        return this._selected;
    }
    set selected(selected) {
        if (selected === this.selected)
            return;
        const oldSelected = this.selected;
        this._selected = selected;
        this.requestUpdate('selected', oldSelected);
    }
    focus(options) {
        this.rovingTabindexController.focus(options);
    }
    handleChange(event) {
        event.stopPropagation();
        const oldSelected = this.selected;
        if (!this.selects) {
            event.preventDefault();
            return;
        }
        if (this.selects === 'single') {
            const { target } = event;
            target.tabIndex = 0;
            this.selectedSet.clear();
            this.selectedSet.add(target.value);
            this.rovingTabindexController.elements.forEach((child) => {
                if (child === target)
                    return;
                child.selected = false;
            });
        }
        else if (this.selects === 'multiple') {
            const { target } = event;
            if (target.selected) {
                this.selectedSet.add(target.value);
            }
            else {
                this.selectedSet.delete(target.value);
            }
        }
        this._selected = [...this.selectedSet];
        const applyDefault = this.dispatchEvent(new Event('change', {
            cancelable: true,
            bubbles: true,
        }));
        if (!applyDefault) {
            this.selected = oldSelected;
            event.preventDefault();
        }
    }
    getPassthroughSwatchActions(changes) {
        const targetValues = {};
        if (changes.has('border') &&
            (this.border || typeof changes.get('border') !== 'undefined')) {
            targetValues.border = this.border;
        }
        if (changes.has('rounding') &&
            (this.rounding || typeof changes.get('rounding') !== 'undefined')) {
            targetValues.rounding = this.rounding;
        }
        if (changes.has('size') &&
            (this.size || typeof changes.get('size') !== 'undefined')) {
            targetValues.size = this.size;
        }
        if (changes.has('shape') &&
            (this.shape || typeof changes.get('shape') !== 'undefined')) {
            targetValues.shape = this.shape;
        }
        const passThroughSwatchActions = [];
        if (Object.keys(targetValues).length) {
            passThroughSwatchActions.push((swatch) => {
                if ('border' in targetValues)
                    swatch.border = targetValues.border;
                if ('rounding' in targetValues)
                    swatch.rounding = targetValues.rounding;
                if ('shape' in targetValues)
                    swatch.shape = targetValues.shape;
                if ('size' in targetValues)
                    swatch.size = targetValues.size;
            });
        }
        return passThroughSwatchActions;
    }
    getSelectionSwatchActions(changes) {
        const selectionSwatchActions = [];
        if (!changes.has('selects'))
            return selectionSwatchActions;
        if (this.selects) {
            this.setAttribute('role', this.selects === 'single' ? 'radiogroup' : 'group');
        }
        else {
            this.removeAttribute('role');
        }
        const swatchRoles = {
            single: 'radio',
            multiple: 'checkbox',
        };
        const swatchRole = this.selects ? swatchRoles[this.selects] : 'button';
        selectionSwatchActions.push((swatch) => {
            swatch.setAttribute('role', swatchRole);
        });
        return selectionSwatchActions;
    }
    render() {
        return html `
            <slot
                @change=${this.handleChange}
                @slotchange=${this.manageChange}
            ></slot>
        `;
    }
    willUpdate(changes) {
        const swatchActions = [
            ...this.getPassthroughSwatchActions(changes),
            ...this.getSelectionSwatchActions(changes),
        ];
        // Create Swatch actions that build state to be applied later.
        const nextSelected = new Set(this.selected);
        const currentValues = new Set();
        if (changes.has('selected')) {
            swatchActions.push((swatch) => {
                currentValues.add(swatch.value);
                if (nextSelected.has(swatch.value) || swatch.selected) {
                    swatch.selected = true;
                }
                else {
                    swatch.selected = false;
                }
            });
        }
        // Do Swatch actions to each Swach in the collection.
        this.rovingTabindexController.elements.forEach((swatch) => {
            swatchActions.forEach((action) => {
                action(swatch);
            });
        });
        // Apply state built in actions back to the Swatch Group
        if (changes.has('selected')) {
            this.selected = [...nextSelected].filter((selectedValue) => currentValues.has(selectedValue));
            this.rovingTabindexController.clearElementCache();
        }
    }
}
__decorate([
    property({ reflect: true })
], SwatchGroup.prototype, "border", void 0);
__decorate([
    property({ reflect: true })
], SwatchGroup.prototype, "rounding", void 0);
__decorate([
    property({ type: Array })
], SwatchGroup.prototype, "selected", null);
__decorate([
    property()
], SwatchGroup.prototype, "selects", void 0);
__decorate([
    property({ reflect: true })
], SwatchGroup.prototype, "shape", void 0);
//# sourceMappingURL=SwatchGroup.js.map