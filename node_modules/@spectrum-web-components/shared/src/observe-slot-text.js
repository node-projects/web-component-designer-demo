import { __decorate } from '/web-component-designer-demo/node_modules/tslib/tslib.es6.js';
import { property, queryAssignedNodes, } from '/web-component-designer-demo/node_modules/@spectrum-web-components/base/src/decorators.js';
import { MutationController } from '/web-component-designer-demo/node_modules/@lit-labs/observers/mutation_controller.js';
const assignedNodesList = Symbol('assignedNodes');
export function ObserveSlotText(constructor, slotName) {
    var _a;
    class SlotTextObservingElement extends constructor {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        constructor(...args) {
            super(args);
            this.slotHasContent = false;
            new MutationController(this, {
                config: {
                    characterData: true,
                    subtree: true,
                },
                callback: (mutationsList) => {
                    for (const mutation of mutationsList) {
                        if (mutation.type === 'characterData') {
                            this.manageTextObservedSlot();
                            return;
                        }
                    }
                },
            });
        }
        manageTextObservedSlot() {
            if (!this[assignedNodesList])
                return;
            const assignedNodes = [...this[assignedNodesList]].filter((node) => {
                if (node.tagName) {
                    return true;
                }
                return node.textContent ? node.textContent.trim() : false;
            });
            this.slotHasContent = assignedNodes.length > 0;
        }
        update(changedProperties) {
            if (!this.hasUpdated) {
                const { childNodes } = this;
                const textNodes = [...childNodes].filter((node) => {
                    if (node.tagName) {
                        return slotName
                            ? node.getAttribute('slot') ===
                                slotName
                            : !node.hasAttribute('slot');
                    }
                    return node.textContent ? node.textContent.trim() : false;
                });
                this.slotHasContent = textNodes.length > 0;
            }
            super.update(changedProperties);
        }
        firstUpdated(changedProperties) {
            super.firstUpdated(changedProperties);
            this.manageTextObservedSlot();
        }
    }
    _a = assignedNodesList;
    __decorate([
        property({ type: Boolean, attribute: false })
    ], SlotTextObservingElement.prototype, "slotHasContent", void 0);
    __decorate([
        queryAssignedNodes(slotName, true)
    ], SlotTextObservingElement.prototype, _a, void 0);
    return SlotTextObservingElement;
}
//# sourceMappingURL=observe-slot-text.js.map