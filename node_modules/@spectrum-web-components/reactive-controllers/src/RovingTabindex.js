export class RovingTabindexController {
    constructor(host, { direction, elementEnterAction, elements, focusInIndex, isFocusableElement, listenerScope, } = { elements: () => [] }) {
        this._currentIndex = -1;
        this._direction = () => 'both';
        this.directionLength = 5;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.elementEnterAction = (_el) => {
            return;
        };
        this.firstUpdated = true;
        this._focused = false;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this._focusInIndex = (_elements) => 0;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.isFocusableElement = (_el) => true;
        this._listenerScope = () => this.host;
        // When elements are virtualized, the delta between the first element
        // and the first rendered element.
        this.offset = 0;
        this.managed = true;
        this.manageIndexesAnimationFrame = 0;
        this.handleFocusin = (event) => {
            if (!this.isEventWithinListenerScope(event))
                return;
            if (this.isRelatedTargetAnElement(event)) {
                this.hostContainsFocus();
            }
            const path = event.composedPath();
            let targetIndex = -1;
            path.find((el) => {
                targetIndex = this.elements.indexOf(el);
                return targetIndex !== -1;
            });
            this.currentIndex = targetIndex > -1 ? targetIndex : this.currentIndex;
        };
        this.handleFocusout = (event) => {
            if (this.isRelatedTargetAnElement(event)) {
                this.hostNoLongerContainsFocus();
            }
        };
        this.handleKeydown = (event) => {
            if (!this.acceptsEventCode(event.code) || event.defaultPrevented) {
                return;
            }
            let diff = 0;
            switch (event.code) {
                case 'ArrowRight':
                    diff += 1;
                    break;
                case 'ArrowDown':
                    diff += this.direction === 'grid' ? this.directionLength : 1;
                    break;
                case 'ArrowLeft':
                    diff -= 1;
                    break;
                case 'ArrowUp':
                    diff -= this.direction === 'grid' ? this.directionLength : 1;
                    break;
                case 'End':
                    this.currentIndex = 0;
                    diff -= 1;
                    break;
                case 'Home':
                    this.currentIndex = this.elements.length - 1;
                    diff += 1;
                    break;
            }
            event.preventDefault();
            if (this.direction === 'grid' && this.currentIndex + diff < 0) {
                this.currentIndex = 0;
            }
            else if (this.direction === 'grid' &&
                this.currentIndex + diff > this.elements.length - 1) {
                this.currentIndex = this.elements.length - 1;
            }
            else {
                this.setCurrentIndexCircularly(diff);
            }
            // To allow the `focusInIndex` to be calculated with the "after" state of the keyboard interaction
            // do `elementEnterAction` _before_ focusing the next element.
            this.elementEnterAction(this.elements[this.currentIndex]);
            this.focus();
        };
        this.host = host;
        this.host.addController(this);
        this._elements = elements;
        this.isFocusableElement = isFocusableElement || this.isFocusableElement;
        if (typeof direction === 'string') {
            this._direction = () => direction;
        }
        else if (typeof direction === 'function') {
            this._direction = direction;
        }
        this.elementEnterAction = elementEnterAction || this.elementEnterAction;
        if (typeof focusInIndex === 'number') {
            this._focusInIndex = () => focusInIndex;
        }
        else if (typeof focusInIndex === 'function') {
            this._focusInIndex = focusInIndex;
        }
        if (typeof listenerScope === 'object') {
            this._listenerScope = () => listenerScope;
        }
        else if (typeof listenerScope === 'function') {
            this._listenerScope = listenerScope;
        }
    }
    get currentIndex() {
        if (this._currentIndex === -1) {
            this._currentIndex = this.focusInIndex;
        }
        return this._currentIndex - this.offset;
    }
    set currentIndex(currentIndex) {
        this._currentIndex = currentIndex + this.offset;
    }
    get direction() {
        return this._direction();
    }
    get elements() {
        if (!this.cachedElements) {
            this.cachedElements = this._elements();
        }
        return this.cachedElements;
    }
    set focused(focused) {
        if (focused === this.focused)
            return;
        this._focused = focused;
        this.manageTabindexes();
    }
    get focused() {
        return this._focused;
    }
    get focusInElement() {
        return this.elements[this.focusInIndex];
    }
    get focusInIndex() {
        return this._focusInIndex(this.elements);
    }
    isEventWithinListenerScope(event) {
        if (this._listenerScope() === this.host)
            return true;
        return event.composedPath().includes(this._listenerScope());
    }
    update({ elements } = { elements: () => [] }) {
        this.unmanage();
        this._elements = elements;
        this.clearElementCache();
        this.manage();
    }
    focus(options) {
        var _a;
        (_a = this.elements[this.currentIndex]) === null || _a === void 0 ? void 0 : _a.focus(options);
    }
    clearElementCache(offset = 0) {
        delete this.cachedElements;
        cancelAnimationFrame(this.manageIndexesAnimationFrame);
        this.offset = offset;
        if (!this.managed)
            return;
        this.manageIndexesAnimationFrame = requestAnimationFrame(() => this.manageTabindexes());
    }
    setCurrentIndexCircularly(diff) {
        const { length } = this.elements;
        let steps = length;
        // start at a possibly not 0 index
        let nextIndex = (length + this.currentIndex + diff) % length;
        while (
        // don't cycle the elements more than once
        steps &&
            this.elements[nextIndex] &&
            !this.isFocusableElement(this.elements[nextIndex])) {
            nextIndex = (length + nextIndex + diff) % length;
            steps -= 1;
        }
        this.currentIndex = nextIndex;
    }
    hostContainsFocus() {
        this.host.addEventListener('focusout', this.handleFocusout);
        this.host.addEventListener('keydown', this.handleKeydown);
        this.focused = true;
    }
    hostNoLongerContainsFocus() {
        this.host.addEventListener('focusin', this.handleFocusin);
        this.host.removeEventListener('focusout', this.handleFocusout);
        this.host.removeEventListener('keydown', this.handleKeydown);
        this.currentIndex = this.focusInIndex;
        this.focused = false;
    }
    isRelatedTargetAnElement(event) {
        const relatedTarget = event.relatedTarget;
        return !this.elements.includes(relatedTarget);
    }
    acceptsEventCode(code) {
        if (code === 'End' || code === 'Home') {
            return true;
        }
        switch (this.direction) {
            case 'horizontal':
                return code === 'ArrowLeft' || code === 'ArrowRight';
            case 'vertical':
                return code === 'ArrowUp' || code === 'ArrowDown';
            case 'both':
            case 'grid':
                return code.startsWith('Arrow');
        }
    }
    manageTabindexes() {
        if (this.focused) {
            this.updateTabindexes(() => ({ tabIndex: -1 }));
        }
        else {
            this.updateTabindexes((el) => {
                return {
                    removeTabIndex: el.contains(this.focusInElement) &&
                        el !== this.focusInElement,
                    tabIndex: el === this.focusInElement ? 0 : -1,
                };
            });
        }
    }
    updateTabindexes(getTabIndex) {
        this.elements.forEach((el) => {
            const { tabIndex, removeTabIndex } = getTabIndex(el);
            if (!removeTabIndex) {
                el.tabIndex = tabIndex;
                return;
            }
            el.removeAttribute('tabindex');
            const updatable = el;
            if (updatable.requestUpdate)
                updatable.requestUpdate();
        });
    }
    manage() {
        this.managed = true;
        this.manageTabindexes();
        this.addEventListeners();
    }
    unmanage() {
        this.managed = false;
        this.updateTabindexes(() => ({ tabIndex: 0 }));
        this.removeEventListeners();
    }
    addEventListeners() {
        this.host.addEventListener('focusin', this.handleFocusin);
    }
    removeEventListeners() {
        this.host.removeEventListener('focusin', this.handleFocusin);
        this.host.removeEventListener('focusout', this.handleFocusout);
        this.host.removeEventListener('keydown', this.handleKeydown);
    }
    hostUpdated() {
        if (this.firstUpdated) {
            this.manageTabindexes();
            this.firstUpdated = false;
        }
    }
    hostConnected() {
        this.addEventListeners();
    }
    hostDisconnected() {
        this.removeEventListeners();
    }
}
//# sourceMappingURL=RovingTabindex.js.map