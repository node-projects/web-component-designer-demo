import { EventNames } from '../../../../enums/EventNames';
import { InsertAction } from '../../../services/undoService/transactionItems/InsertAction';
export class DrawElementTool {
    constructor(elementDefinition) {
        this.cursor = 'crosshair';
        this._elementDefinition = elementDefinition;
    }
    dispose() {
        if (this._createdItem)
            this._createdItem.element.parentElement.removeChild(this._createdItem.element);
    }
    pointerEventHandler(designerView, event, currentElement) {
        switch (event.type) {
            case EventNames.PointerDown:
                this._onPointerDown(designerView, event);
                break;
            case EventNames.PointerMove:
                this._onPointerMove(designerView, event);
                break;
            case EventNames.PointerUp:
                this._onPointerUp(designerView, event);
                break;
        }
    }
    async _onPointerDown(designerView, event) {
        event.preventDefault();
        this._startPosition = { x: event.x, y: event.y };
        this._createdItem = await designerView.serviceContainer.forSomeServicesTillResult("instanceService", (service) => service.getElement(this._elementDefinition, designerView.serviceContainer, designerView.instanceServiceContainer));
        const targetRect = event.target.getBoundingClientRect();
        this._createdItem.setStyle('position', 'absolute');
        this._createdItem.setStyle('left', event.offsetX + targetRect.left - designerView.containerBoundingRect.x + 'px');
        this._createdItem.setStyle('top', event.offsetY + targetRect.top - designerView.containerBoundingRect.y + 'px');
        this._createdItem.setStyle('width', '0');
        this._createdItem.setStyle('height', '0');
        this._createdItem.element.style.overflow = 'hidden';
        //TODO: add items as last, with all properties set
        //draw via containerService??? how to draw into a grid, a stackpanel???
        designerView.instanceServiceContainer.undoService.execute(new InsertAction(designerView.rootDesignItem, designerView.rootDesignItem.childCount, this._createdItem));
        designerView.instanceServiceContainer.selectionService.clearSelectedElements();
    }
    async _onPointerMove(designerView, event) {
        if (this._createdItem) {
            if (!this._rect) {
                designerView.rootDesignItem.element.appendChild(this._createdItem.element);
                this._rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                designerView.overlayLayer.appendChild(this._rect);
                this._rect.setAttribute('class', 'svg-draw-new-element');
                this._rect.setAttribute('x', (this._startPosition.x - designerView.containerBoundingRect.x));
                this._rect.setAttribute('y', (this._startPosition.y - designerView.containerBoundingRect.y));
            }
            this._rect.setAttribute('width', event.x - this._startPosition.x);
            this._rect.setAttribute('height', event.y - this._startPosition.y);
            this._createdItem.setStyle('width', event.x - this._startPosition.x + 'px');
            this._createdItem.setStyle('height', event.y - this._startPosition.y + 'px');
        }
    }
    async _onPointerUp(designerView, event) {
        designerView.overlayLayer.removeChild(this._rect);
        designerView.instanceServiceContainer.selectionService.setSelectedElements([this._createdItem]);
        this._startPosition = null;
        this._rect = null;
        this._createdItem = null;
        designerView.serviceContainer.globalContext.finishedWithTool(this);
    }
}
