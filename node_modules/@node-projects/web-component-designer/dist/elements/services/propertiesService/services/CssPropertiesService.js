import { BindingTarget } from '../../../item/BindingTarget.js';
import { PropertyType } from '../PropertyType.js';
import { CommonPropertiesService } from './CommonPropertiesService.js';
import { RefreshMode } from '../IPropertiesService.js';
import { PropertiesHelper } from './PropertiesHelper.js';
import { GridAssignedRowColumnPropertyEditor } from '../propertyEditors/special/GridAssignedRowColumnPropertyEditor.js';
import { MetricsPropertyEditor } from '../propertyEditors/special/MetricsPropertyEditor.js';
//TODO: remove this code when import asserts are supported
let cssProperties;
//@ts-ignore
if (window.importShim) {
    const cssPropertiesUrl = import.meta.resolve('./CssProperties.json');
    //@ts-ignore
    cssProperties = await importShim(cssPropertiesUrl, { assert: { type: 'json' } });
}
else
    //@ts-ignore
    cssProperties = await import("./CssProperties.json", { assert: { type: 'json' } });
if (cssProperties.default)
    cssProperties = cssProperties.default;
export class CssPropertiesService extends CommonPropertiesService {
    getRefreshMode(designItem) {
        return RefreshMode.none;
    }
    //metrics
    layout = {
        "common": [
            "display",
            "color",
            "background-color",
            "box-sizing",
            "border",
            "box-shadow",
            "opacity",
            "position",
        ],
        "font": [
            "font-family",
            "font-size",
            "font-weight",
        ],
        "layout": [
            "inset",
            "margin",
            "border",
            "padding",
            "overflow",
            "metrics"
        ]
    };
    grid = [
        "display",
        "position",
        "grid-template-columns",
        "grid-template-rows",
        "column-gap",
        "row-gap",
        "align-content",
        "justify-content",
        "align-items",
        "justify-items",
    ];
    gridChild = [
        "grid-row",
        "grid-column",
        "assigned-row-column",
        "align-self",
        "justify-self"
    ];
    flex = [
        "display",
        "position",
        "flex-direction",
        "flex-wrap",
        "align-content",
        "justify-content",
        "align-items"
    ];
    flexChild = [
        "align-self",
        "justify-self"
    ];
    svg = [
        "fill",
        "fill-rule",
        "fill-opacity",
        "stroke",
        "stroke-width",
        "stroke-dash-array",
        "stroke-opacity"
    ];
    constructor(name) {
        super();
        this.name = name;
    }
    isHandledElement(designItem) {
        return true;
    }
    getProperty(designItem, name) {
        return this._getPropertyDef(name);
    }
    getProperties(designItem) {
        const propNames = this[this.name];
        if (Array.isArray(propNames)) {
            const propertiesList = propNames.map(x => this._getPropertyDef(x));
            return propertiesList;
        }
        else {
            let grps = [];
            for (let g in propNames) {
                let grp = { name: g, properties: propNames[g].map(x => this._getPropertyDef(x)) };
                grps.push(grp);
            }
            return grps;
        }
    }
    _getPropertyDef(name) {
        const camelName = PropertiesHelper.dashToCamelCase(name);
        switch (camelName) {
            case 'assignedRowColumn':
                return { name, service: this, propertyType: PropertyType.complex, createEditor: (p) => new GridAssignedRowColumnPropertyEditor(p) };
            case 'metrics':
                return { name, service: this, propertyType: PropertyType.complex, createEditor: (p) => new MetricsPropertyEditor(p) };
            default:
                return {
                    name,
                    type: cssProperties[camelName]?.type ?? 'string',
                    values: cssProperties[camelName]?.values ? [...cssProperties[camelName]?.values, 'initial', 'inherit', 'unset'] : ['initial', 'inherit', 'unset'],
                    service: this,
                    propertyType: PropertyType.cssValue
                };
        }
    }
    getPropertyTarget(designItem, property) {
        return BindingTarget.css;
    }
}
