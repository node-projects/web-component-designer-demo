import { ValueType } from "../ValueType.js";
import { BaseCustomWebComponentLazyAppend, BaseCustomWebComponentConstructorAppend } from "../../../../../../base-custom-webcomponent/dist/index.js";
import { PropertiesHelper } from "./PropertiesHelper.js";
export class BaseCustomWebComponentPropertiesService {
  constructor() {
    this.name = "baseCustomWebComponent";
  }

  isHandledElement(designItem) {
    return designItem.element instanceof BaseCustomWebComponentLazyAppend || designItem.element instanceof BaseCustomWebComponentConstructorAppend;
  }

  getProperties(designItem) {
    if (!this.isHandledElement(designItem)) return null;
    let properties = [];
    let list = designItem.element.constructor.properties;

    for (const name in list) {
      const propertyObj = list[name];

      if (propertyObj === Date) {
        let property = {
          name: name,
          type: "date",
          service: this
        };
        properties.push(property);
      } else if (propertyObj === Object) {
        let property = {
          name: name,
          type: "object",
          service: this
        };
        properties.push(property);
      } else if (propertyObj === Number) {
        let property = {
          name: name,
          type: "number",
          service: this
        };
        properties.push(property);
      } else if (PropertiesHelper.isTypescriptEnum(propertyObj)) {
        let property = {
          name: name,
          type: "enum",
          enumValues: PropertiesHelper.getTypescriptEnumEntries(propertyObj),
          service: this
        };
        properties.push(property);
      } else {
        let property = {
          name: name,
          type: "string",
          service: this
        };
        properties.push(property);
      }
    }

    return properties;
  }

  setValue(designItems, property, value) {
    let attributeName = PropertiesHelper.camelToDashCase(property.name);

    for (let d of designItems) {
      if (property.type === 'object') d.setAttribute(attributeName, JSON.stringify(value));else if (property.type == 'boolean' && !value) d.removeAttribute(property.name);else d.setAttribute(attributeName, value); //@ts-ignore

      d.element._parseAttributesToProperties();
    }
  }

  clearValue(designItems, property) {
    for (let d of designItems) {
      d.removeAttribute(property.name); //@ts-ignore

      d.element._parseAttributesToProperties();
    }
  }

  isSet(designItems, property) {
    let all = true;
    let some = false;

    if (designItems != null && designItems.length !== 0) {
      let attributeName = PropertiesHelper.camelToDashCase(property.name);
      designItems.forEach(x => {
        let has = x.attributes.has(attributeName);
        all = all && has;
        some = some || has;
      });
    } else return ValueType.none;

    return all ? ValueType.all : some ? ValueType.some : ValueType.none;
  }

  getValue(designItems, property) {
    if (designItems != null && designItems.length !== 0) {
      let attributeName = PropertiesHelper.camelToDashCase(property.name);
      let lastValue = designItems[0].attributes.get(attributeName);

      for (const x of designItems) {
        let value = x.attributes.get(attributeName);

        if (value != lastValue) {
          lastValue = null;
          break;
        }
      }

      return lastValue;
    }

    return null;
  }

  getUnsetValue(designItems, property) {
    return property.defaultValue;
  }

}