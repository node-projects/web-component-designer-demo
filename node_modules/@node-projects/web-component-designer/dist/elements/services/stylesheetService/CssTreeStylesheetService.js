import { TypedEvent } from '/web-component-designer-demo/node_modules/@node-projects/base-custom-webcomponent/./dist/index.js';
import { calculate as calculateSpecifity } from "./SpecificityCalculator.js";
export class CssTreeStylesheetService {
    _stylesheets = new Map();
    stylesheetChanged = new TypedEvent();
    stylesheetsChanged = new TypedEvent();
    constructor() { }
    setStylesheets(stylesheets) {
        if (stylesheets != null) {
            this._stylesheets = new Map();
            for (let stylesheet of stylesheets) {
                this._stylesheets.set(stylesheet.name, {
                    stylesheet: stylesheet,
                    ast: window.csstree.toPlainObject((window.csstree.parse(stylesheet.content, { positions: true, parseValue: false })))
                });
            }
            this.stylesheetsChanged.emit();
        }
        else {
            this._stylesheets = null;
        }
    }
    getStylesheets() {
        let stylesheets = [];
        for (let item of this._stylesheets) {
            stylesheets.push(item[1].stylesheet);
        }
        ;
        return stylesheets;
    }
    /* Section covers the retrieval of rules and declarations */
    getAppliedRulesInternal(designItem) {
        let styles = [];
        for (let item of this._stylesheets) {
            if (!item[1].ast || !this.astHasChildren(item[1].ast))
                continue;
            styles = styles.concat(Array.from(this.rulesFromAST(item[1].ast, item[1].stylesheet.content, item[0], designItem)));
        }
        ;
        return styles;
    }
    getAppliedRules(designItem) {
        let rules = this.getAppliedRulesInternal(designItem);
        if (!rules || rules.length == 0)
            return [];
        let retCollection = [];
        for (let rule of rules) {
            retCollection.push({
                ...rule,
                declarations: rule.ast.block.children.map((declaration) => {
                    return {
                        name: declaration.property,
                        value: declaration.value.value,
                        important: declaration.important == true,
                        specificity: rule.specificity,
                        parent: rule,
                        ast: declaration,
                    };
                })
            });
        }
        return retCollection;
    }
    getDeclarationInternal(designItem, styleName) {
        let rules = this.getAppliedRulesInternal(designItem);
        if (!rules)
            return null;
        let declarations = [];
        for (let rule of rules) {
            let declaration = this.findDeclarationInRule(rule.ast, styleName);
            if (!declaration)
                continue;
            declarations.push({
                ast: declaration,
                parent: rule,
                name: styleName,
                value: declaration.value.value,
                important: declaration.important == true,
            });
        }
        ;
        return declarations;
    }
    getDeclarations(designItem, stlyeName) {
        let declarations = this.getDeclarationInternal(designItem, stlyeName);
        if (!declarations)
            return null;
        return this.sortDeclarations(declarations);
    }
    /* Section covers the update of rules and declarations */
    updateDeclarationWithDeclaration(declaration, value, important) {
        let sourceNode = this._stylesheets.get(declaration.parent.stylesheetName);
        declaration.ast.value = window.csstree.toPlainObject(window.csstree.parse(declaration.name + ": " + value + (important ? " !important" : ""), { context: 'declaration', parseValue: false })).value;
        sourceNode.stylesheet.content = window.csstree.generate(window.csstree.fromPlainObject(sourceNode.ast));
        // After generating the stylesheet, the AST has to be transformed back into a plain object
        sourceNode.ast = window.csstree.toPlainObject(sourceNode.ast);
        this.stylesheetChanged.emit({ stylesheet: sourceNode.stylesheet });
        return true;
    }
    insertDeclarationIntoRule(rule, declaration, important) {
        let sourceNode = this._stylesheets.get(rule.stylesheetName);
        rule.ast.block.children.push(window.csstree.toPlainObject(window.csstree.parse(declaration.name + ": " + declaration.value + (declaration.important ? " !important" : ""), { context: 'declaration', parseValue: false })));
        sourceNode.stylesheet.content = window.csstree.generate(window.csstree.fromPlainObject(sourceNode.ast));
        // After generating the stylesheet, the AST has to be transformed back into a plain object
        sourceNode.ast = window.csstree.toPlainObject(sourceNode.ast);
        this.stylesheetChanged.emit({ stylesheet: sourceNode.stylesheet });
        return true;
    }
    removeDeclarationFromRule(rule, declaration) {
        let index = rule.ast.block.children.indexOf(declaration.ast);
        if (index == -1)
            return false;
        rule.ast.block.children.splice(index, 1);
        this._stylesheets.get(rule.stylesheetName).stylesheet.content = window.csstree.generate(window.csstree.fromPlainObject(this._stylesheets.get(rule.stylesheetName).ast));
        this._stylesheets.get(rule.stylesheetName).ast = window.csstree.toPlainObject(window.csstree.fromPlainObject(this._stylesheets.get(rule.stylesheetName).ast));
        this.stylesheetChanged.emit({ stylesheet: this._stylesheets.get(rule.stylesheetName).stylesheet });
        return true;
    }
    /* Section covers the internal traversal creation of rules and declarations */
    *rulesFromAST(ast, stylesheet, source, designItem, previousCheck = '') {
        let parent = ast["children"] != null ? ast : ast.block;
        for (const child of parent.children) {
            if (child.type == "Atrule") {
                const currentCheck = this.buildAtRuleString(child, stylesheet);
                if (currentCheck.type === "@media" && !window.matchMedia(currentCheck.sel))
                    continue;
                if (currentCheck.type === "@supports" && !CSS.supports(currentCheck.sel))
                    continue;
                let ruleCollection = this.rulesFromAST(child, stylesheet, source, designItem, previousCheck + currentCheck.type + " " + currentCheck.sel + "\n");
                if (ruleCollection) {
                    for (const r of ruleCollection) {
                        if (!this.elementMatchesASelector(designItem, this.buildSelectorString(r.ast.prelude)))
                            continue;
                        yield r;
                    }
                }
            }
            if (child.type == "Rule") {
                let selectors = this.buildSelectorString(child.prelude);
                if (!this.elementMatchesASelector(designItem, selectors))
                    continue;
                yield ({
                    ast: child,
                    selector: previousCheck + this.buildSelectorString(child.prelude).join(", "),
                    specificity: this.getSpecificity(child.prelude),
                    stylesheetName: source,
                    declarations: null,
                });
            }
        }
        ;
    }
    /* Utility functions for building selectors, specificity and so on  */
    astHasChildren(ast) {
        return ast != null && ast["children"] != null && ast["children"].length > 0;
    }
    buildSelectorString(selectorsAST) {
        let selectors = [];
        for (let selector of selectorsAST.children) {
            let sel = "";
            for (let fraction of selector.children) {
                if (fraction.type == "IdSelector")
                    sel += "#" + fraction.name;
                else if (fraction.type == "ClassSelector")
                    sel += "." + fraction.name;
                else
                    sel += fraction.name;
            }
            selectors.push(sel);
        }
        ;
        return selectors;
    }
    getSpecificity(selector) {
        const specificities = calculateSpecifity(selector);
        let sum = 0;
        specificities.forEach(specificity => sum += specificity.a * 10000 + specificity.b * 100 + specificity.c);
        return sum;
    }
    findDeclarationInRule(rule, styleName) {
        return rule.block.children.find(declaration => declaration.property == styleName);
    }
    elementMatchesASelector(designItem, selectors) {
        for (const selector of selectors)
            if (designItem.element.matches(selector))
                return true;
        return false;
    }
    buildAtRuleString(ast, stylesheet) {
        return {
            sel: stylesheet.slice(ast.prelude.loc.start.offset, ast.prelude.loc.end.offset),
            type: "@" + ast.name
        };
    }
    sortDeclarations(declarations) {
        if (declarations == null || declarations.length == 0)
            return null;
        return declarations.sort((dec1, dec2) => {
            if (dec1.parent.specificity > dec2.parent.specificity)
                return -1;
            return 1;
        });
    }
}
