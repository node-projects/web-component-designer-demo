import * as csstree from 'css-tree';
import { TypedEvent } from '/web-component-designer-demo/node_modules/@node-projects/base-custom-webcomponent/./dist/index.js';
import { calculate as calculateSpecifity } from "./SpecificityCalculator.js";
export class StylesheetService {
    stylesheets;
    stylesheetChanged = new TypedEvent();
    styles = [];
    constructor(stylesheets) {
        this.stylesheets = stylesheets;
    }
    updateDefiningRule(designItem, property, value) {
        // let highestSpecificityRule = this.getAppliedRules(designItem, property);
        // if (!highestSpecificityRule) return false;
        // let newRule = csstree.toPlainObject(csstree.parse("* {" + property.name + ": " + value + "}")) as csstree.StyleSheetPlain;
        // let index = this.returnRuleDeclarationIndex(highestSpecificityRule, property);
        // if (index > -1) highestSpecificityRule.block.children.splice(index, 1, (newRule.children[0] as csstree.RulePlain).block.children[0]);
        // else highestSpecificityRule.block.children.push((newRule.children[0] as csstree.RulePlain).block.children[0]);
        // if (!this.ruleset) this.ruleset = this.parseStylesheetToRuleset(this.stylesheet);
        // this.stylesheetChanged.emit({ stylesheet: csstree.generate(csstree.fromPlainObject(this.ruleset)) });
        return true;
    }
    getAppliedRulesInternal(designItem, prop) {
        return this.parseStylesheetToRuleset(this.stylesheets).filter(item => designItem.element.matches(item.selector));
    }
    getAppliedRules(designItem, prop) {
        let rules = this.getAppliedRulesInternal(designItem, prop);
        if (!rules)
            return [];
        return rules.map(r => {
            return {
                selector: r.selector,
                declarations: r.rule.block.children.map(c => {
                    return {
                        // @ts-ignore
                        name: c.property,
                        // @ts-ignore
                        value: c.value.value,
                        // @ts-ignore
                        important: c.important == true
                    };
                }),
                specificity: this.getSpecificity(r.rule.prelude)
            };
        });
    }
    getDeclarationInternal(designItem, prop) {
        let rules = this.getAppliedRulesInternal(designItem, prop);
        if (!rules)
            return null;
        let declarations = [];
        rules.forEach(r => {
            let index = this.returnRuleDeclarationIndex(r.rule, prop);
            // @ts-ignore
            if (index > -1)
                declarations.push(r.rule.block.children[index]);
        });
        return declarations;
    }
    getDeclarations(designItem, prop) {
        let decl = this.getDeclarationInternal(designItem, prop);
        if (!decl)
            return null;
        let declarations = [];
        decl.forEach(d => {
            declarations.push({
                name: d.property,
                value: d.value.value,
                important: d.important == true
            });
        });
        return declarations;
    }
    parseStylesheetToRuleset(stylesheets) {
        let styles = [];
        stylesheets.forEach(s => {
            let stylesheetPlain = csstree.toPlainObject(csstree.parse(s, { positions: true, parseValue: false }));
            stylesheetPlain.children.forEach((rule) => {
                styles.push({
                    rule: rule,
                    selector: this.buildSelectorString(s, rule.prelude),
                    specificity: this.getSpecificity(rule.prelude)
                });
            });
        });
        return styles;
    }
    buildSelectorString(stylesheet, selector) {
        return stylesheet.substring(selector.loc.start.offset, selector.loc.end.offset);
    }
    getSpecificity(selector) {
        const specificities = calculateSpecifity(selector);
        let sum = 0;
        specificities.forEach(specificity => sum += specificity.a * 10000 + specificity.b * 100 + specificity.c);
        return sum;
    }
    returnRuleDeclarationIndex(rule, property) {
        let decl;
        rule.block.children.forEach((child) => {
            if (child.property == property.name) {
                decl = child;
                return;
            }
        });
        if (!decl)
            return -1;
        return rule.block.children.indexOf(decl);
    }
}
