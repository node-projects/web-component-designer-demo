import { getElementOffsetsInContainer, getParentElementIncludingSlots, instanceOf } from "./ElementHelper.js";
//TODO:
//transform-box
let identityMatrix = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];
export function getElementCombinedTransform(element) {
    //https://www.w3.org/TR/css-transforms-2/#ctm
    let s = (element.ownerDocument.defaultView ?? window).getComputedStyle(element);
    let m = new DOMMatrix();
    const origin = s.transformOrigin.split(' ');
    const originX = parseFloat(origin[0]);
    const originY = parseFloat(origin[1]);
    //todo: 3d?
    const mOri = new DOMMatrix().translate(originX, originY);
    const mOriInv = new DOMMatrix().translate(-originX, -originY);
    if (s.translate != 'none' && s.translate) {
        m = m.multiply(new DOMMatrix('translate(' + s.translate.replace(' ', ',') + ')'));
    }
    if (s.rotate != 'none' && s.rotate) {
        m = m.multiply(new DOMMatrix('rotate(' + s.rotate.replace(' ', ',') + ')'));
    }
    if (s.scale != 'none' && s.scale) {
        m = m.multiply(new DOMMatrix('scale(' + s.scale.replace(' ', ',') + ')'));
    }
    if (s.transform != 'none' && s.transform) {
        m = m.multiply(new DOMMatrix(s.transform));
    }
    return mOri.multiply(m.multiply(mOriInv));
}
export function combineTransforms(element, actualTransforms, requestedTransformation) {
    if (actualTransforms == null || actualTransforms == '') {
        element.style.transform = requestedTransformation;
        return;
    }
    const actualTransformationMatrix = new DOMMatrix(actualTransforms);
    const requestedTransformationMatrix = new DOMMatrix(requestedTransformation);
    const newTransformationMatrix = requestedTransformationMatrix.multiply(actualTransformationMatrix);
    element.style.transform = newTransformationMatrix.toString();
}
export function transformPointByInverseMatrix(point, matrix) {
    const inverse = matrix.inverse();
    return point.matrixTransform(inverse);
}
export function getRotationMatrix3d(axisOfRotation, angle) {
    const angleInRadians = angle / 180 * Math.PI;
    const sin = Math.sin;
    const cos = Math.cos;
    let rotationMatrix3d = [];
    switch (axisOfRotation.toLowerCase()) {
        case 'x':
            rotationMatrix3d = [
                1, 0, 0, 0,
                0, cos(angleInRadians), -sin(angleInRadians), 0,
                0, sin(angleInRadians), cos(angleInRadians), 0,
                0, 0, 0, 1
            ];
            break;
        case 'y':
            rotationMatrix3d = [
                cos(angleInRadians), 0, sin(angleInRadians), 0,
                0, 1, 0, 0,
                -sin(angleInRadians), 0, cos(angleInRadians), 0,
                0, 0, 0, 1
            ];
            break;
        case 'z':
            rotationMatrix3d = [
                cos(angleInRadians), -sin(angleInRadians), 0, 0,
                sin(angleInRadians), cos(angleInRadians), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
            break;
        default:
            rotationMatrix3d = null;
            break;
    }
    return rotationMatrix3d;
}
export function rotateElementByMatrix3d(element, matrix) {
    element.style.transform = matrixArrayToCssMatrix(matrix);
}
export function matrixArrayToCssMatrix(matrixArray) {
    return "matrix3d(" + matrixArray.join(',') + ")";
}
//maybe remove -> refactor rotate extension
export function cssMatrixToMatrixArray(cssMatrix) {
    if (!cssMatrix.includes('matrix')) {
        if (cssMatrix != 'none')
            console.error('cssMatrixToMatrixArray: no css matrix passed');
        return identityMatrix;
    }
    let matrixArray = cssMatrix.match(/^matrix.*\((.*)\)/)[1].split(',').map(Number);
    return matrixArray;
}
export function getRotationAngleFromMatrix(matrixArray, domMatrix) {
    let angle = null;
    const a = domMatrix != null ? domMatrix.a : matrixArray[0];
    const b = domMatrix != null ? domMatrix.b : matrixArray[1];
    angle = Math.round(Math.atan2(b, a) * (180 / Math.PI));
    return angle;
}
export function addVectors(vectorA, vectorB) {
    return [vectorA[0] + vectorB[0], vectorA[1] + vectorB[1]];
}
const elementMatrixCacheKey = Symbol('windowOffsetsCacheKey');
export function getResultingTransformationBetweenElementAndAllAncestors(element, ancestor, excludeAncestor, cache = {}) {
    let ch;
    if (cache)
        ch = cache[elementMatrixCacheKey] ??= new Map();
    else
        ch = new Map();
    const res = ch.get(element);
    if (res)
        return res;
    let actualElement = element;
    let parentElementMatrix;
    let originalElementAndAllParentsMultipliedMatrix = getElementCombinedTransform(actualElement);
    while (actualElement != ancestor && actualElement != null) {
        const offsets = getElementOffsetsInContainer(actualElement);
        const mvMat = new DOMMatrix().translate(offsets.x, offsets.y);
        originalElementAndAllParentsMultipliedMatrix = mvMat.multiply(originalElementAndAllParentsMultipliedMatrix);
        const parentElement = getParentElementIncludingSlots(actualElement);
        if (parentElement) {
            parentElementMatrix = getElementCombinedTransform(parentElement);
            if (parentElement != ancestor || !excludeAncestor) {
                originalElementAndAllParentsMultipliedMatrix = parentElementMatrix.multiply(originalElementAndAllParentsMultipliedMatrix);
            }
        }
        actualElement = parentElement;
    }
    ch.set(element, originalElementAndAllParentsMultipliedMatrix);
    return originalElementAndAllParentsMultipliedMatrix;
}
export function getDesignerCanvasNormalizedTransformedPoint(element, point, designerCanvas, cache) {
    return getDesignerCanvasNormalizedTransformedCornerDOMPoints(element, { x: -point.x, y: -point.y }, designerCanvas, cache)[0];
}
export function getElementSize(element) {
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    if (instanceOf(element, SVGElement) && element.width) {
        width = element.width.baseVal.value;
        height = element.height.baseVal.value;
    }
    else if (instanceOf(element, SVGGraphicsElement)) {
        //@ts-ignore
        let bbox = element.getBBox();
        width = bbox.width;
        height = bbox.height;
    }
    else if (instanceOf(element, MathMLElement)) {
        let bbox = element.getBoundingClientRect();
        width = bbox.width;
        height = bbox.height;
    }
    return { width, height };
}
export function getDesignerCanvasNormalizedTransformedCornerDOMPoints(element, untransformedCornerPointsOffset, designerCanvas, cache) {
    let { width, height } = getElementSize(element);
    let originalElementAndAllParentsMultipliedMatrix = getResultingTransformationBetweenElementAndAllAncestors(element, designerCanvas.canvas, true, cache);
    const canvasOffset = designerCanvas.containerOffset;
    let arr = [{ x: 0, y: 0 }, { x: width, y: 0 }, { x: 0, y: height }, { x: width, y: height }];
    const transformedCornerPoints = Array(4);
    //@ts-ignore
    let offset = untransformedCornerPointsOffset ?? { x: 0, y: 0 };
    if (!Array.isArray(offset)) {
        //@ts-ignore
        offset = [{ x: offset.x, y: offset.y }, { x: -offset.x, y: offset.y }, { x: offset.x, y: -offset.y }, { x: -offset.x, y: -offset.y }];
    }
    for (let i = 0; i < 4; i++) {
        let p = new DOMPoint(arr[i].x, arr[i].y);
        p = new DOMPoint(arr[i].x - (offset[i].x / designerCanvas.scaleFactor), arr[i].y - (offset[i].y / designerCanvas.scaleFactor));
        let pTransformed = p.matrixTransform(originalElementAndAllParentsMultipliedMatrix);
        transformedCornerPoints[i] = new DOMPoint(pTransformed.x + canvasOffset.x, pTransformed.y + canvasOffset.y);
    }
    return transformedCornerPoints;
}
export function extractTranslationFromDOMMatrix(matrix) {
    //TODO: maybe we also need m43 here??
    return new DOMPoint(matrix.m41, matrix.m42, 0, 0);
}
export function extractRotationAngleFromDOMMatrix(matrix) {
    return getRotationAngleFromMatrix(null, matrix);
}
//# sourceMappingURL=TransformHelper.js.map