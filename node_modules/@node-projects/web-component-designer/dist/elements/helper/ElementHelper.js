export function newElementFromString(text) {
    const range = document.createRange();
    range.selectNode(document.body);
    const fragment = range.createContextualFragment(text);
    return fragment.firstChild;
}
export var ElementDisplayType;
(function (ElementDisplayType) {
    ElementDisplayType[ElementDisplayType["none"] = 0] = "none";
    ElementDisplayType[ElementDisplayType["inline"] = 1] = "inline";
    ElementDisplayType[ElementDisplayType["block"] = 2] = "block";
})(ElementDisplayType || (ElementDisplayType = {}));
export function isInline(element) {
    if (element instanceof SVGElement)
        return false;
    return element != null && window.getComputedStyle(element).display.startsWith('inline');
}
export function isInlineAfter(element) {
    if (element instanceof SVGElement)
        return false;
    return element != null && window.getComputedStyle(element).display.startsWith('inline');
}
export function getElementDisplaytype(element) {
    if (element instanceof SVGElement)
        return ElementDisplayType.block;
    const display = window.getComputedStyle(element).display;
    return display == 'none' ? ElementDisplayType.none : display.startsWith('inline') ? ElementDisplayType.inline : ElementDisplayType.block;
}
export function isEmptyTextNode(node) {
    return node.textContent.trim() == '' && node.textContent.indexOf('\xa0' /* &nbsp; */) < 0;
}
export function getActiveElement() {
    let activeElement = document.activeElement;
    let lastActive = null;
    while (activeElement != lastActive) {
        lastActive = activeElement;
        if (activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement)
            activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
}
export function getParentElementIncludingSlots(element) {
    if (element.assignedSlot)
        return element.assignedSlot;
    if (element.parentElement == null) {
        if (element.parentNode instanceof ShadowRoot) {
            return element.parentNode.host;
        }
    }
    return element.parentElement;
}
export function getElementsWindowOffsetWithoutSelfAndParentTransformations(element) {
    let offsetLeft = 0;
    let offsetTop = 0;
    while (element) {
        if (element instanceof SVGSVGElement) {
            //todo - fix without transformation
            let t = element.style.transform;
            element.style.transform = '';
            const bcEl = element.getBoundingClientRect();
            const bcPar = element.parentElement.getBoundingClientRect();
            element.style.transform = t;
            offsetLeft += bcEl.left - bcPar.left;
            offsetTop += bcEl.top - bcPar.top;
            element = element.parentElement;
        }
        else if (element instanceof SVGGraphicsElement) {
            let bbox = element.getBBox();
            offsetLeft += bbox.x;
            offsetTop += bbox.y;
            element = element.ownerSVGElement;
        }
        else {
            offsetLeft += element.offsetLeft;
            offsetTop += element.offsetTop;
            element = element.offsetParent;
        }
    }
    return { offsetLeft: offsetLeft, offsetTop: offsetTop };
}
