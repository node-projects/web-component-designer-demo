import { css, html, BaseCustomWebComponentConstructorAppend, cssFromString } from '@node-projects/base-custom-webcomponent';
import { NodeType, assetsPath, ContextMenu, switchContainer, DomConverter } from '@node-projects/web-component-designer';
import { Wunderbaum } from 'wunderbaum';
import { defaultOptions, defaultStyle } from '../WunderbaumOptions.js';
//@ts-ignore
import wunderbaumStyle from 'wunderbaum/dist/wunderbaum.css' assert { type: 'css' };
export class TreeViewExtended extends BaseCustomWebComponentConstructorAppend {
    _treeDiv;
    _tree;
    _filter;
    _instanceServiceContainer;
    _selectionChangedHandler;
    _contentChangedHandler;
    static style = css `
      * {
          touch-action: none;
          cursor: default;
      }
    
      .cmd {
        display: flex;
        position: absolute;
        right: 0;
        top: 0;
        height: 100%;
        padding-right: 2px;
        align-items: center;
        gap: 2px;
        background: #ffffffc9;
        width: 42px;
        justify-content: flex-end;
        background: white;
      }
      .cmd > img {
        width: 10px;
      }
      
      div.wunderbaum div.wb-row {
        display: block;
      }
      span.wb-node.wb-col {
        width: unset !important;
        display: inline-block;
      }
      div.wunderbaum span.wb-node span.wb-title {
        text-overflow: unset;
        width: unset !important;
      }`;
    static template = html `
      <div style="height: 100%;">
        <input id="input" style="width: 100%; box-sizing: border-box; height:27px;" placeholder="Filter... (regex)" autocomplete="off">
        <div style="height: calc(100% - 23px);">
        <div id="treetable" class="wb-alternate" style="min-width: 100%;"></div>
        </div>
      </div>`;
    constructor() {
        super();
        this._restoreCachedInititalValues();
        this.shadowRoot.adoptedStyleSheets = [cssFromString(wunderbaumStyle), defaultStyle, TreeViewExtended.style];
        this._filter = this._getDomElement('input');
        this._filter.onkeyup = () => {
            this._filterNodes();
        };
        this._treeDiv = this._getDomElement('treetable');
    }
    _filterNodes() {
        let match = this._filter.value;
        if (match) {
            const regEx = new RegExp(match, "i");
            this._tree.filterNodes((node) => {
                const di = node.data.ref;
                return regEx.test(di.name) || regEx.test(di.id) || regEx.test(di.content);
            }, {});
        }
        else {
            this._tree.clearFilter();
        }
    }
    _showHideAtDesignTimeState(img, designItem) {
        if (designItem.hideAtDesignTime)
            img.src = assetsPath + "images/treeview/eyeclose.png";
        else
            img.src = assetsPath + "images/treeview/eyeopen.png";
    }
    _switchHideAtDesignTimeState(img, designItem) {
        designItem.hideAtDesignTime = !designItem.hideAtDesignTime;
        this._showHideAtDesignTimeState(img, designItem);
    }
    _showLockAtDesignTimeState(img, designItem) {
        if (designItem.lockAtDesignTime)
            img.src = assetsPath + "images/treeview/lock.png";
        else
            img.src = assetsPath + "images/treeview/dot.png";
    }
    _switchLockAtDesignTimeState(img, designItem) {
        designItem.lockAtDesignTime = !designItem.lockAtDesignTime;
        this._showLockAtDesignTimeState(img, designItem);
    }
    _showHideAtRunTimeState(img, designItem) {
        if (designItem.hideAtRunTime)
            img.src = assetsPath + "images/treeview/eyeclose.png";
        else
            img.src = assetsPath + "images/treeview/eyeopen.png";
    }
    _switchHideAtRunTimeState(img, designItem) {
        designItem.hideAtRunTime = !designItem.hideAtRunTime;
        this._showHideAtRunTimeState(img, designItem);
    }
    showDesignItemContextMenu(designItem, event) {
        event.preventDefault();
        const mnuItems = [];
        for (let cme of designItem.serviceContainer.designerContextMenuExtensions) {
            if (cme.shouldProvideContextmenu(event, designItem.instanceServiceContainer.designerCanvas, designItem, 'treeView')) {
                mnuItems.push(...cme.provideContextMenuItems(event, designItem.instanceServiceContainer.designerCanvas, designItem));
            }
        }
        let ctxMnu = ContextMenu.show(mnuItems, event);
        return ctxMnu;
    }
    async ready() {
        this._tree = new Wunderbaum({
            ...defaultOptions,
            element: this._treeDiv,
            click: (e) => {
                if (e.event) { // only for clicked items, not when elements selected via code.
                    let node = e.node;
                    let designItem = node.data.ref;
                    if (designItem) {
                        if (e.event.ctrlKey) {
                            const sel = [...designItem.instanceServiceContainer.selectionService.selectedElements];
                            const idx = sel.indexOf(designItem);
                            if (idx >= 0) {
                                sel.splice(idx, 1);
                                designItem.instanceServiceContainer.selectionService.setSelectedElements(sel);
                            }
                            else {
                                designItem.instanceServiceContainer.selectionService.setSelectedElements([...sel, designItem]);
                            }
                        }
                        else {
                            designItem.instanceServiceContainer.selectionService.setSelectedElements([designItem]);
                        }
                    }
                }
                const disableExpand = e.event.ctrlKey || e.event.shiftKey;
                return !disableExpand;
            },
            dnd: {
                guessDropEffect: true,
                preventRecursion: true,
                preventVoidMoves: false,
                serializeClipboardData: false,
                dragStart: (e) => {
                    e.event.dataTransfer.effectAllowed = "all";
                    e.event.dataTransfer.dropEffect = "move";
                    return true;
                },
                dragEnter: (e) => {
                    e.event.dataTransfer.dropEffect = e.event.ctrlKey ? 'copy' : 'move';
                    return true;
                },
                dragOver: (e) => {
                    e.event.dataTransfer.dropEffect = e.event.ctrlKey ? 'copy' : 'move';
                    //return true;
                },
                drop: async (e) => {
                    let sourceDesignitems = [e.sourceNode].map(x => x.data.ref);
                    if (e.event.dataTransfer.dropEffect == 'copy') {
                        let newSourceDesignitems = [];
                        for (let d of sourceDesignitems)
                            newSourceDesignitems.push(await d.clone());
                        sourceDesignitems = newSourceDesignitems;
                    }
                    const targetDesignitem = e.node.data.ref;
                    let grp = targetDesignitem.openGroup("drag/drop in treeview");
                    if (e.region == 'over') {
                        switchContainer(sourceDesignitems, targetDesignitem);
                    }
                    else if (e.region == 'after' || e.region == 'before') {
                        for (let d of sourceDesignitems) {
                            if (d.parent != targetDesignitem.parent) {
                                switchContainer([d], targetDesignitem.parent);
                            }
                            if (e.region == 'before')
                                targetDesignitem.insertAdjacentElement(d, 'beforebegin');
                            else
                                targetDesignitem.insertAdjacentElement(d, 'afterend');
                        }
                    }
                    grp.commit();
                }
            },
            filter: {
                autoApply: true, // Re-apply last filter if lazy data is loaded
                autoExpand: true, // Expand all branches that contain matches while filtered
                counter: true, // Show a badge with number of matching child nodes near parent icons
                fuzzy: true, // Match single characters in order, e.g. 'fb' will match 'FooBar'
                hideExpandedCounter: true, // Hide counter badge if parent is expanded
                hideExpanders: false, // Hide expanders if all child nodes are hidden by filter
                highlight: true, // Highlight matches by wrapping inside <mark> tags
                leavesOnly: false, // Match end nodes only
                mode: "hide" // Grayout unmatched nodes (pass "hide" to remove unmatched node instead)
            },
            render: (e) => {
                if (e.isNew) {
                    const node = e.node;
                    const rowElem = e.nodeElem.parentElement;
                    let item = node.data.ref;
                    e.nodeElem.oncontextmenu = (e) => this.showDesignItemContextMenu(item, e);
                    e.nodeElem.onmouseenter = (e) => item.instanceServiceContainer.designerCanvas.showHoverExtension(item.element, e);
                    e.nodeElem.onmouseleave = (e) => item.instanceServiceContainer.designerCanvas.showHoverExtension(null, e);
                    if (item && item.nodeType === NodeType.Element && item !== item.instanceServiceContainer.contentService.rootDesignItem) {
                        let d = document.createElement("div");
                        d.className = "cmd";
                        let imgL = document.createElement('img');
                        this._showLockAtDesignTimeState(imgL, item);
                        imgL.onclick = () => this._switchLockAtDesignTimeState(imgL, item);
                        imgL.title = 'lock';
                        d.appendChild(imgL);
                        let img = document.createElement('img');
                        this._showHideAtDesignTimeState(img, item);
                        img.onclick = () => this._switchHideAtDesignTimeState(img, item);
                        img.title = 'hide in designer';
                        d.appendChild(img);
                        let imgH = document.createElement('img');
                        this._showHideAtRunTimeState(imgH, item);
                        imgH.onclick = () => this._switchHideAtRunTimeState(imgH, item);
                        imgH.title = 'hide at runtime';
                        d.appendChild(imgH);
                        rowElem.appendChild(d);
                    }
                }
                e.nodeElem.querySelector("span.wb-title").innerHTML = e.node.title;
            },
        });
    }
    createTree(rootItem) {
        if (this._tree) {
            this._recomputeTree(rootItem);
        }
    }
    set instanceServiceContainer(value) {
        this._instanceServiceContainer = value;
        this._selectionChangedHandler?.dispose();
        this._selectionChangedHandler = this._instanceServiceContainer.selectionService.onSelectionChanged.on(e => {
            this.selectionChanged(e);
        });
        this._contentChangedHandler?.dispose();
        this._contentChangedHandler = this._instanceServiceContainer.contentService.onContentChanged.on(e => {
            this.createTree(value.contentService.rootDesignItem);
        });
        this.createTree(value.contentService.rootDesignItem);
    }
    selectionChanged(event) {
        this._highlight(event.selectedElements);
    }
    _recomputeTree(rootItem) {
        this._tree.root.removeChildren();
        this._getChildren(rootItem, null);
        this._tree.expandAll();
        this._filterNodes();
    }
    _getChildren(item, currentNode) {
        if (currentNode == null) {
            currentNode = this._tree.root;
        }
        const newNode = currentNode.addChildren({
            title: item.isRootItem ? '-root-' : item.nodeType === NodeType.Element ? item.name + " " + (item.id ? ('#' + item.id) : '') : '<small><small><small>#' + (item.nodeType === NodeType.TextNode ? 'text' : 'comment') + '&nbsp;</small></small></small> ' + DomConverter.normalizeContentValue(item.content),
            ref: item
        });
        for (let i of item.children()) {
            if (!i.isEmptyTextNode) {
                this._getChildren(i, newNode);
            }
        }
    }
    _highlight(activeElements) {
        let scrolled = false;
        this._tree.runWithDeferredUpdate(() => {
            this._tree.visit((node) => {
                const flag = activeElements && activeElements.includes(node.data.ref);
                node.setSelected(flag);
                if (flag && !scrolled) {
                    scrolled = true;
                    node.scrollIntoView();
                }
            });
        });
    }
}
customElements.define('node-projects-tree-view-extended', TreeViewExtended);
