import { css, html, BaseCustomWebComponentConstructorAppend, cssFromString } from '@node-projects/base-custom-webcomponent';
import { dragDropFormatNameElementDefinition } from '@node-projects/web-component-designer';
import { Wunderbaum } from 'wunderbaum';
import { defaultOptions, defaultStyle } from '../WunderbaumOptions.js';
//@ts-ignore
import wunderbaumStyle from 'wunderbaum/dist/wunderbaum.css' assert { type: 'css' };
export class PaletteTreeView extends BaseCustomWebComponentConstructorAppend {
    _treeDiv;
    _tree;
    _filter;
    static style = css `
        :host {
          display: block;
        }

        * {
            touch-action: none;
        }`;
    static template = html `
      <div style="height: 100%;">
        <input id="input" style="width: 100%; height: 25px; box-sizing: border-box;" placeholder="Filter..." autocomplete="off">
        <div style="height: calc(100% - 26px);">
          <div id="treetable" class="wb-alternate" style="min-width: 100%;"></div>
        </div>
      </div>`;
    constructor() {
        super();
        this._restoreCachedInititalValues();
        this.shadowRoot.adoptedStyleSheets = [cssFromString(wunderbaumStyle), defaultStyle, PaletteTreeView.style];
        this._filter = this._getDomElement('input');
        this._filter.onkeyup = () => {
            let match = this._filter.value;
            this._tree.filterNodes((node) => {
                return new RegExp(match, "i").test(node.title);
            }, {});
        };
        this._treeDiv = this._getDomElement('treetable');
        this._tree = new Wunderbaum({
            ...defaultOptions,
            element: this._treeDiv,
            filter: {
                autoExpand: true,
                mode: 'hide',
                highlight: true
            },
            dnd: {
                guessDropEffect: true,
                preventRecursion: true,
                preventVoidMoves: false,
                serializeClipboardData: false,
                dragStart: (e) => {
                    e.event.dataTransfer.effectAllowed = "all";
                    e.event.dataTransfer.setData(dragDropFormatNameElementDefinition, JSON.stringify(e.node.data.ref));
                    e.event.dataTransfer.dropEffect = "copy";
                    return true;
                },
                dragEnter: (e) => {
                    return false;
                }
            }
        });
    }
    async loadControls(serviceContainer, elementsServices) {
        let rootNode = this._tree.root;
        rootNode.removeChildren();
        for (const s of elementsServices) {
            const newNode = rootNode.addChildren({
                title: s.name
            });
            try {
                let elements = await s.getElements();
                for (let e of elements) {
                    newNode.addChildren({
                        title: e.name ?? e.tag,
                        //@ts-ignore
                        ref: e
                    });
                }
            }
            catch (err) {
                console.warn('Error loading elements', err);
            }
        }
    }
}
customElements.define('node-projects-palette-tree-view', PaletteTreeView);
