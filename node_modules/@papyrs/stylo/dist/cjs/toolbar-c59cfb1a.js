'use strict';

const createEmptyElement = ({ nodeName }) => {
  const element = document.createElement(nodeName);
  element.innerHTML = '\u200B';
  return element;
};

var i=()=>{window&&window.getSelection?window.getSelection()?.empty?window.getSelection()?.empty():window.getSelection()?.removeAllRanges&&window.getSelection()?.removeAllRanges():document&&document.selection&&document.selection.empty();},c=()=>window&&window.getSelection?window.getSelection():document&&document.getSelection?document.getSelection():document&&document.selection?document.selection.createRange().text:null,a=e=>{let n=e?.anchorNode;return n?n.nodeType!==Node.TEXT_NODE&&n.nodeType!==Node.COMMENT_NODE?n:n.parentElement:null},u=e=>{d({element:e,collapse:"end"});},g=e=>{d({element:e,collapse:"start"});},d=({element:e,collapse:n})=>{if(!e)return;let t=document.createRange();t.selectNodeContents(e),t.collapse(n==="start"),l(t);},f=({element:e,offset:n})=>{if(!e)return;let t=document.createRange();t.setStart(e,n),l(t);},l=e=>{let n=c();n?.removeAllRanges(),n?.addRange(e),e.detach();},m=({target:e})=>{let t=c()?.getRangeAt(0),o=t?.cloneRange();if(!o||!t)return;let{endContainer:r,endOffset:s}=t;return o.selectNodeContents(e),o.setEnd(r,s),o.toString().length};

const isTextNode = (element) => {
  return (element === null || element === void 0 ? void 0 : element.nodeType) === Node.TEXT_NODE || (element === null || element === void 0 ? void 0 : element.nodeType) === Node.COMMENT_NODE;
};
const toHTMLElement = (element) => {
  return isTextNode(element) ? element.parentElement : element;
};
const elementIndex = (element) => {
  var _a;
  return Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []).indexOf(element);
};
const nodeIndex = (node) => {
  var _a;
  return Array.from(((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) || []).indexOf(node);
};
const nodeDepths = ({ target, paragraph }) => {
  const depths = [nodeIndex(target)];
  if (!paragraph) {
    return depths;
  }
  let parentElement = target.parentElement;
  while (parentElement && !parentElement.isSameNode(paragraph)) {
    depths.push(nodeIndex(parentElement));
    parentElement = parentElement.parentElement;
  }
  return depths.reverse();
};
const findNodeAtDepths = ({ parent, indexDepths }) => {
  const childNode = ((parent === null || parent === void 0 ? void 0 : parent.childNodes) ? Array.from(parent === null || parent === void 0 ? void 0 : parent.childNodes) : [])[indexDepths[0]];
  if (!childNode) {
    return undefined;
  }
  const [, ...rest] = indexDepths;
  if ((rest === null || rest === void 0 ? void 0 : rest.length) <= 0) {
    return childNode;
  }
  return findNodeAtDepths({ parent: childNode, indexDepths: rest });
};

const findParagraph = ({ element, container }) => {
  if (!container) {
    return undefined;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return undefined;
  }
  if (!container.parentNode) {
    return undefined;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return undefined;
  }
  if (parentElement.isEqualNode(container)) {
    return element;
  }
  return findParagraph({ element: parentElement, container });
};
/**
 * <article>
 *   <div>
 *     <span>
 *       => isStartNode = true
 *
 * <article>
 *   <div>
 *     Hello <span>
 *             => isStartNode = false
 */
const isStartNode = ({ element, container }) => {
  if (!container) {
    return false;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return false;
  }
  if (isParagraph({ element, container })) {
    return true;
  }
  // If node is the direct first child of it's parent, we can check the parent until we get the container
  if (nodeIndex(element) === 0) {
    return isStartNode({ element: element.parentElement, container });
  }
  return false;
};
const isParagraph = ({ element, container }) => {
  if (!element) {
    return false;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return false;
  }
  return parentElement === null || parentElement === void 0 ? void 0 : parentElement.isEqualNode(container);
};
const isTargetContainer = ({ target, container }) => target.isEqualNode(container);
const focusParagraph = ({ paragraph }) => {
  if (!isTextNode(paragraph)) {
    toHTMLElement(paragraph).focus();
  }
  u(paragraph);
};
const transformParagraph = ({ elements, paragraph, container, focus = 'first' }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    if (addedNodes.length <= 0) {
      return;
    }
    const { firstChild } = toHTMLElement(addedNodes[focus === 'first' ? 0 : addedNodes.length - 1]);
    u(firstChild);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  const anchor = toHTMLElement(paragraph.previousElementSibling);
  // We delete present paragraph and add the new element and assumes the mutation observer will trigger both delete and add in a single mutation.
  // Thanks to this, only one entry will be added in the undo-redo stack.
  container.removeChild(paragraph);
  if (!anchor) {
    container.append(...elements);
    return;
  }
  anchor.after(...elements);
};
const createEmptyParagraph = ({ paragraph, container }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    // Should not happen, fallback
    if (!paragraph) {
      container.append(div);
      return;
    }
    paragraph.after(div);
  });
};
const addParagraph = ({ paragraph, container, fragment }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    paragraph.after(fragment);
  });
};
const createNewEmptyLine = ({ paragraph, range }) => {
  const br = document.createElement('br');
  return insertNodeInRange({ observerRoot: paragraph, range, element: br });
};
const createNewParagraph = ({ container, range, text }) => {
  const div = document.createElement('div');
  div.innerHTML = text;
  return insertNodeInRange({ observerRoot: container, range, element: div });
};
const insertNodeInRange = ({ observerRoot, range, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(observerRoot, { childList: true, subtree: true });
    range.insertNode(element);
  });
};
const prependEmptyText = ({ paragraph }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    paragraph.prepend(text);
  });
};
const addEmptyText = ({ paragraph, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    element.after(text);
  });
};
const isParagraphEmpty = ({ paragraph }) => { var _a; return ['', '\n', '\u200B'].includes((_a = paragraph === null || paragraph === void 0 ? void 0 : paragraph.textContent) === null || _a === void 0 ? void 0 : _a.trim()); };
const isParagraphNotEditable = ({ paragraph }) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.getAttribute('contenteditable')) === 'false';
const isParagraphCode = ({ paragraph }) => {
  // DeckDeckGo web components
  if (paragraph.nodeName.toLowerCase().startsWith('deckgo-')) {
    return true;
  }
  return ['code', 'pre'].includes(paragraph.nodeName.toLowerCase());
};
const isParagraphList = ({ paragraph }) => ['ul', 'ol', 'dl'].includes(paragraph.nodeName.toLowerCase());

const code = {
  text: 'code',
  icon: 'code',
  createParagraphs: async ({ container, paragraph }) => {
    transformParagraph({
      elements: [createEmptyElement({ nodeName: 'code' }), createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};

const h1 = {
  text: 'huge_title',
  icon: `<span class='placeholder'>H1</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h1' })],
    paragraph,
    container
  })
};

const h2 = {
  text: 'large_title',
  icon: `<span class='placeholder'>H2</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h2' })],
    paragraph,
    container
  })
};

const h3 = {
  text: 'small_title',
  icon: `<span class='placeholder'>H3</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h3' })],
    paragraph,
    container
  })
};

const hr = {
  text: 'separator',
  icon: 'hr',
  createParagraphs: async ({ container, paragraph }) => {
    const hr = document.createElement('hr');
    transformParagraph({
      elements: [hr, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container,
      focus: 'last'
    });
  }
};

const img = {
  text: 'image',
  icon: 'img',
  files: {
    accept: 'image/x-png,image/jpeg,image/gif,image/svg+xml,image/webp',
    multiple: false
  },
  createParagraphs: async ({ container, paragraph, files }) => {
    const URL = window.URL || window.webkitURL;
    const imgUrl = URL.createObjectURL(files[0]);
    const img = document.createElement('img');
    img.src = imgUrl;
    img.setAttribute('loading', 'lazy');
    const emptyDiv = createEmptyElement({ nodeName: 'div' });
    transformParagraph({
      elements: [img, emptyDiv],
      paragraph,
      container,
      focus: 'last'
    });
  }
};

const createListItem = () => {
  const item = document.createElement('li');
  item.innerHTML = '\u200B';
  return item;
};
const ul = {
  text: 'list',
  icon: 'ul',
  createParagraphs: async ({ container, paragraph }) => {
    const ul = document.createElement('ul');
    ul.append(createListItem());
    await transformParagraph({
      elements: [ul, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};

const DEFAULT_PALETTE = [
  {
    color: {
      hex: '#8ED1FC',
      rgb: '142,209,252'
    },
    alt: 'Light blue'
  },
  {
    color: {
      hex: '#0693E3',
      rgb: '6,147,227'
    },
    alt: 'Blue'
  },
  {
    color: {
      hex: '#7BDCB5',
      rgb: '123,220,181'
    },
    alt: 'Light green'
  },
  {
    color: {
      hex: '#00D084',
      rgb: '0,208,132'
    },
    alt: 'Green'
  },
  {
    color: {
      hex: '#FCB900',
      rgb: '252,185,0'
    },
    alt: 'Yellow'
  },
  {
    color: {
      hex: '#FF6900',
      rgb: '255,105,0'
    },
    alt: 'Orange'
  },
  {
    color: {
      hex: '#F78DA7',
      rgb: '247,141,167'
    },
    alt: 'Pink'
  },
  {
    color: {
      hex: '#EB144C',
      rgb: '235,20,76'
    },
    alt: 'Red'
  },
  {
    color: {
      hex: '#ffffff',
      rgb: '255,255,255'
    },
    alt: 'White',
    display: {
      borderColor: '#ddd',
      boxShadowColor: '221,221,221'
    }
  },
  {
    color: {
      hex: '#ABB8C3',
      rgb: '171,184,195'
    },
    alt: 'Grey'
  },
  {
    color: {
      hex: '#000000',
      rgb: '0,0,0'
    },
    alt: 'Black'
  }
];

exports.ToolbarActions = void 0;
(function (ToolbarActions) {
  ToolbarActions[ToolbarActions["STYLE"] = 0] = "STYLE";
  ToolbarActions[ToolbarActions["LINK"] = 1] = "LINK";
  ToolbarActions[ToolbarActions["COLOR"] = 2] = "COLOR";
  ToolbarActions[ToolbarActions["ALIGNMENT"] = 3] = "ALIGNMENT";
  ToolbarActions[ToolbarActions["LIST"] = 4] = "LIST";
  ToolbarActions[ToolbarActions["FONT_SIZE"] = 5] = "FONT_SIZE";
  ToolbarActions[ToolbarActions["BACKGROUND_COLOR"] = 6] = "BACKGROUND_COLOR";
})(exports.ToolbarActions || (exports.ToolbarActions = {}));
exports.ToolbarList = void 0;
(function (ToolbarList) {
  ToolbarList["ORDERED"] = "insertOrderedList";
  ToolbarList["UNORDERED"] = "insertUnorderedList";
})(exports.ToolbarList || (exports.ToolbarList = {}));
exports.ToolbarAlign = void 0;
(function (ToolbarAlign) {
  ToolbarAlign["LEFT"] = "left";
  ToolbarAlign["CENTER"] = "center";
  ToolbarAlign["RIGHT"] = "right";
})(exports.ToolbarAlign || (exports.ToolbarAlign = {}));
exports.ToolbarFontSize = void 0;
(function (ToolbarFontSize) {
  ToolbarFontSize["X_SMALL"] = "1";
  ToolbarFontSize["SMALL"] = "2";
  ToolbarFontSize["MEDIUM"] = "3";
  ToolbarFontSize["LARGE"] = "4";
  ToolbarFontSize["X_LARGE"] = "5";
  ToolbarFontSize["XX_LARGE"] = "6";
  ToolbarFontSize["XXX_LARGE"] = "7";
})(exports.ToolbarFontSize || (exports.ToolbarFontSize = {}));

exports.DEFAULT_PALETTE = DEFAULT_PALETTE;
exports.a = a;
exports.addEmptyText = addEmptyText;
exports.addParagraph = addParagraph;
exports.c = c;
exports.code = code;
exports.createEmptyElement = createEmptyElement;
exports.createEmptyParagraph = createEmptyParagraph;
exports.createNewEmptyLine = createNewEmptyLine;
exports.createNewParagraph = createNewParagraph;
exports.elementIndex = elementIndex;
exports.f = f;
exports.findNodeAtDepths = findNodeAtDepths;
exports.findParagraph = findParagraph;
exports.focusParagraph = focusParagraph;
exports.g = g;
exports.h1 = h1;
exports.h2 = h2;
exports.h3 = h3;
exports.hr = hr;
exports.i = i;
exports.img = img;
exports.isParagraph = isParagraph;
exports.isParagraphCode = isParagraphCode;
exports.isParagraphEmpty = isParagraphEmpty;
exports.isParagraphList = isParagraphList;
exports.isParagraphNotEditable = isParagraphNotEditable;
exports.isStartNode = isStartNode;
exports.isTargetContainer = isTargetContainer;
exports.isTextNode = isTextNode;
exports.m = m;
exports.nodeDepths = nodeDepths;
exports.prependEmptyText = prependEmptyText;
exports.toHTMLElement = toHTMLElement;
exports.transformParagraph = transformParagraph;
exports.u = u;
exports.ul = ul;
