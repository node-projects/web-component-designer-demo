'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-dc1b5428.js');
const toolbar = require('./toolbar-9a6c3bf0.js');

function u(n){if(!n||n===void 0||n==="")return;let e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);return e?`${parseInt(e[1],16)}, ${parseInt(e[2],16)}, ${parseInt(e[3],16)}`:void 0}function i(n){return n?(r=>{if(!!r)return `#${r.map(t=>t.toString(16).padStart(2,"0")).join("")}`})(d$1(n)):void 0}function d$1(n){let e=n.match(/([.\d]+),\s*([.\d]+),\s*([.\d]+)/);if(!!e)return e.splice(1,3).map(r=>Number(r))}

function l(n){return n.changedTouches?n.changedTouches[0]:n}function d(n,e){let o;return (...r)=>{let i=()=>n(...r);o&&clearTimeout(o),o=setTimeout(i,e&&e>0?e:300);}}function a(){if(!window)return !1;let n=window.matchMedia("(any-pointer:coarse)").matches,e=window.matchMedia("(any-pointer:fine)").matches;return n&&!e}function f(){if(!window||!navigator)return !1;let n=t();return /iPhone|iPod/i.test(n)||s()}function s(){if(!window||!navigator)return !1;let n=t();return /iPad/i.test(n)?!0:/Macintosh/i.test(n)&&a()}function w(){if(!window||!navigator)return !1;let n=t();return /firefox/i.test(n)}var b=()=>/apple/i.test(navigator.vendor);function p(){let n=document.documentElement.getAttribute("dir");return n!==null&&n==="rtl"}var c=()=>{if(!window)return !1;let n=t();return /android|sink/i.test(n)},t=()=>navigator.userAgent||navigator.vendor||window.opera;

const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof index.getRenderingRef !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = index.getRenderingRef();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(index.forceUpdate));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(index.forceUpdate));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};

const DEFAULT_PLUGINS = [toolbar.h1, toolbar.h2, toolbar.h3, toolbar.ul, toolbar.ol, toolbar.blockquote, toolbar.img, toolbar.code, toolbar.hr];
const DEFAULT_TOOLBAR = {
  palette: toolbar.DEFAULT_PALETTE,
  command: 'native',
  style: {
    list: false,
    align: true,
    fontSize: true,
    backgroundColor: true
  }
};
const DEFAULT_PLACEHOLDERS = ['div', 'p', 'span'];
const DEFAULT_TEXT_PARAGRAPHS = ['h1', 'h2', 'h3', 'div', 'p', 'blockquote'];
const DEFAULT_EXCLUDE_ATTRIBUTES = [
  'placeholder',
  'class',
  'spellcheck',
  'contenteditable',
  'data-gramm',
  'data-gramm_id',
  'data-gramm_editor',
  'data-gr-id',
  'autocomplete'
];
const DEFAULT_PARAGRAPH_IDENTIFIER = 'paragraph_id';
const DEFAULT_ATTRIBUTES = {
  paragraphIdentifier: DEFAULT_PARAGRAPH_IDENTIFIER,
  exclude: [...DEFAULT_EXCLUDE_ATTRIBUTES, DEFAULT_PARAGRAPH_IDENTIFIER]
};
const { state: state$3, onChange: onChange$3 } = createStore({
  plugins: DEFAULT_PLUGINS,
  toolbar: DEFAULT_TOOLBAR,
  placeholders: DEFAULT_PLACEHOLDERS,
  textParagraphs: DEFAULT_TEXT_PARAGRAPHS,
  menus: undefined,
  attributes: DEFAULT_ATTRIBUTES
});
const configStore = { state: state$3, onChange: onChange$3 };

const { state: state$2, onChange: onChange$2 } = createStore({
  ref: undefined,
  size: undefined
});
const containerStore = { state: state$2, onChange: onChange$2 };

const en = {
  lang: 'en',
  plugins: {
    huge_title: 'Huge title',
    large_title: 'Large title',
    small_title: 'Small title',
    paragraph: 'Paragraph',
    separator: 'Separator',
    unordered_list: 'Bulleted list',
    ordered_list: 'Numbered list',
    image: 'Image',
    code: 'Code',
    no_matches: 'No matches',
    blockquote: 'Blockquote'
  },
  add: {
    placeholder: 'Press "/" for plugins',
    add_element: 'Add a new part'
  },
  toolbar: {
    align_left: 'Align left',
    align_center: 'Align center',
    align_right: 'Align right',
    font_size: 'Font size',
    list_ol: 'Ordered list',
    list_ul: 'Unordered list',
    style_list: 'Style list',
    style_align: 'Style alignment',
    style_font_size: 'Style font size',
    style_color: 'Style color',
    style_background: 'Style background',
    link: 'Create or remove link',
    bold: 'Bold',
    italic: 'Italic',
    underline: 'Underline',
    strikethrough: 'Strikethrough'
  },
  menus: {
    img_width_original: 'Original image width',
    img_width_large: 'Large image width',
    img_width_medium: 'Medium image width',
    img_width_small: 'Small image width',
    img_delete: 'Delete image'
  }
};

const { state: state$1, onChange: onChange$1 } = createStore(en);
const esI18n = async () => {
  const { es } = await Promise.resolve().then(function () { return require('./es-cb88b3b9.js'); });
  return es;
};
const deI18n = async () => {
  const { de } = await Promise.resolve().then(function () { return require('./de-b01d7d5c.js'); });
  return de;
};
const nlI18n = async () => {
  const { nl } = await Promise.resolve().then(function () { return require('./nl-5e269a63.js'); });
  return nl;
};
const jaI18n = async () => {
  const { ja } = await Promise.resolve().then(function () { return require('./ja-c3ce9f2e.js'); });
  return ja;
};
const zhCnI18n = async () => {
  const { zhCn } = await Promise.resolve().then(function () { return require('./zh-cn-c662c966.js'); });
  return zhCn;
};
const enI18n = () => en;
onChange$1('lang', async (lang) => {
  let bundle;
  switch (lang) {
    case 'es':
      bundle = await esI18n();
      break;
    case 'de':
      bundle = await deI18n();
      break;
    case 'nl':
      bundle = await nlI18n();
      break;
    case 'ja':
      bundle = await jaI18n();
      break;
    case 'zh-cn':
      bundle = await zhCnI18n();
      break;
    default:
      bundle = enI18n();
  }
  Object.assign(state$1, Object.assign({ custom: state$1.custom }, bundle));
});
const i18n = { state: state$1 };

// keyCode 229 = input is processing - Japanese entry
// https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
const isKeyboardEnter = ({ code, keyCode }) => ['Enter'].includes(code) && keyCode !== 229;

/**
 * isMobileDevice detects device that has touch and no mouse pointer so for example a Samsung Note 20 would probably not match.
 * that's why we enhance the check with android and ios, considering these as mobile devices too.
 */
const isMobile = () => a() || c() || f();

/**
 * The document selection or, if a container is provided
 */
const getSelection$1 = (container) => {
  // https://stackoverflow.com/questions/62054839/shadowroot-getselection
  // https://twitter.com/bocoup/status/1459120675390689284?s=20
  // https://github.com/WICG/webcomponents/issues/79
  if (isShadowRoot(container) && hasShadowRootSelectionApi(container)) {
    return getShadowRootSelection(container);
  }
  return toolbar.c();
};
const isShadowRoot = (container) => (container === null || container === void 0 ? void 0 : container.getRootNode()) instanceof ShadowRoot;
const hasShadowRootSelectionApi = (container) => (container === null || container === void 0 ? void 0 : container.getRootNode()).getSelection;
const getShadowRootSelection = (container) => container.getRootNode().getSelection();
const getRange = (container) => {
  const selection = getSelection$1(container);
  if (!selection || selection.rangeCount <= 0) {
    return {
      range: null,
      selection: null
    };
  }
  return {
    selection,
    range: selection.getRangeAt(0)
  };
};
const deleteRange = (range) => {
  const { startOffset, endOffset } = range;
  const textSelected = startOffset !== endOffset;
  if (!textSelected) {
    return;
  }
  range.extractContents();
};

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Aadd%3A
const IconAdd = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" })));

const addCss = ":host{display:block;position:absolute;top:var(--actions-top);left:var(--stylo-add-left, 8px);transition:top 0.1s ease;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}button{display:flex;position:relative;isolation:isolate;overflow:hidden;background:transparent;border:none;outline:none;cursor:pointer;transition:color 0.25s ease-out, background 0.25s ease-out, transform 0.15s ease-out;flex-direction:column;justify-content:center;align-items:center;border-radius:50%;width:1.4rem;height:1.4rem;color:var(--stylo-add-color, var(--medium))}button:active{box-shadow:none;transform:translateX(1px) translateY(1px)}button:hover,button:focus{color:var(--light-contrast)}svg{width:1.2rem;height:1.2rem}";

const Add = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.selectParagraph = index.createEvent(this, "selectParagraph", 7);
    this.listPlugins = index.createEvent(this, "listPlugins", 7);
    this.hidePlugins = index.createEvent(this, "hidePlugins", 7);
    this.debouncePlaceholder = d(() => this.addPlaceholder(), 350);
    /**
     * When "enter" is pressed, create a new paragraph and select it.
     */
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (!['ArrowDown', 'ArrowUp'].includes(code) && !isKeyboardEnter($event)) {
        this.removePlaceholder();
      }
      if (['Backspace', 'Delete'].includes(code)) {
        this.displayOnMutations();
      }
    };
    this.onFocusout = () => {
      // Only if not mobile because the event bubble and is triggered often
      if (!f()) {
        return;
      }
      this.top = undefined;
    };
    this.initParagraph = ({ target, onlyIfEmptyParagraph }) => {
      if (!target) {
        this.hide();
        return;
      }
      const paragraph = toolbar.findParagraph({
        element: target,
        container: containerStore.state.ref
      });
      this.paragraph = toolbar.toHTMLElement(paragraph);
      if (!this.paragraph) {
        this.hide();
        return;
      }
      if (toolbar.isParagraphNotEditable({ paragraph: this.paragraph })) {
        this.hide();
        return;
      }
      if (onlyIfEmptyParagraph && !toolbar.isParagraphEmpty({ paragraph: this.paragraph })) {
        this.hide();
        return;
      }
      this.top = this.paragraph.offsetTop;
      this.editPlaceholder();
      this.selectParagraph.emit(this.paragraph);
    };
    this.top = undefined;
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.addEventListener('focusout', this.onFocusout);
    this.destroyListener = containerStore.onChange('ref', () => {
      this.removeContainerListener();
      this.addContainerListener();
    });
    this.addContainerListener();
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.removeEventListener('focusout', this.onFocusout);
    this.removeContainerListener();
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  addContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown, { passive: true });
  }
  removeContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  onKeyUp($event) {
    const { code } = $event;
    if (!['ArrowDown', 'ArrowUp', 'Backspace', 'Delete'].includes(code) &&
      !isKeyboardEnter($event)) {
      if (this.top !== undefined) {
        this.hide();
      }
      return;
    }
    if (['ArrowDown', 'ArrowUp'].includes(code)) {
      this.display({ onlyIfEmptyParagraph: false });
      return;
    }
  }
  /**
   * If user press "/" we want to display the list of plugins.
   */
  onBeforeInput({ data }) {
    if (!['/'].includes(data)) {
      this.hidePlugins.emit();
      return;
    }
    if (!this.paragraph || !this.paragraph.isConnected) {
      return;
    }
    if (!toolbar.isParagraphEmpty({ paragraph: this.paragraph })) {
      this.hidePlugins.emit();
      return;
    }
    this.focusListPlugins();
  }
  /**
   * Hide or display the component, the "plus" button.
   */
  onClick({ target }) {
    var _a;
    // We use the target only if not the container - it can happen for example if the margin is clicked, in such case we want to use the selection
    this.display({
      onlyIfEmptyParagraph: false,
      target: ((_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.isEqualNode(target)) ? undefined : target
    });
  }
  onAddParagraphs({ detail: addedParagraphs }) {
    const { length, [length - 1]: last } = addedParagraphs;
    this.initParagraph({ target: last, onlyIfEmptyParagraph: false });
  }
  hide() {
    this.selectParagraph.emit(undefined);
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.top = undefined;
  }
  display({ onlyIfEmptyParagraph, target }) {
    var _a;
    this.initParagraph({
      target: target !== null && target !== void 0 ? target : (_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode,
      onlyIfEmptyParagraph
    });
  }
  displayOnMutations() {
    const onRender = (_mutations, observer) => {
      observer.disconnect();
      this.display({ onlyIfEmptyParagraph: true });
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, {
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  editPlaceholder() {
    this.removePlaceholder();
    this.debouncePlaceholder();
  }
  addPlaceholder() {
    var _a;
    if (!toolbar.isParagraphEmpty({ paragraph: this.paragraph })) {
      return;
    }
    if (toolbar.isParagraphNotEditable({ paragraph: this.paragraph })) {
      return;
    }
    if (!configStore.state.placeholders.includes((_a = this.paragraph) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase())) {
      return;
    }
    const cssBefore = window.getComputedStyle(this.paragraph, ':before');
    const cssAfter = window.getComputedStyle(this.paragraph, ':after');
    const emptyPseudoElement = ['""', 'none'];
    if (!emptyPseudoElement.includes(cssBefore.getPropertyValue('content')) ||
      !emptyPseudoElement.includes(cssAfter.getPropertyValue('content'))) {
      // An external source use :before or :after to style this paragraph, we don't want to add noise in the ui
      return;
    }
    this.paragraph.setAttribute('placeholder', i18n.state.add.placeholder);
  }
  removePlaceholder() {
    var _a;
    const placeholders = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.querySelectorAll('[placeholder]');
    placeholders === null || placeholders === void 0 ? void 0 : placeholders.forEach((element) => element.removeAttribute('placeholder'));
  }
  selectPlugins($event) {
    if (!this.paragraph || !containerStore.state.ref) {
      return;
    }
    $event.stopPropagation();
    if (toolbar.isParagraphEmpty({ paragraph: this.paragraph }) &&
      !toolbar.isParagraphNotEditable({ paragraph: this.paragraph })) {
      this.focusListPlugins();
      return;
    }
    toolbar.focusParagraph({ paragraph: this.paragraph });
    const onRender = (mutations, observer) => {
      observer.disconnect();
      const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
      const div = addedNodes.find((node) => node.nodeName.toLowerCase() === 'div');
      toolbar.g(div);
      this.listPlugins.emit(div);
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const div = toolbar.createEmptyElement({ nodeName: 'div' });
    this.paragraph.after(div);
    this.hide();
  }
  focusListPlugins() {
    toolbar.focusParagraph({ paragraph: this.paragraph });
    this.listPlugins.emit(this.paragraph);
  }
  render() {
    const style = this.top === undefined ? { display: 'none' } : { '--actions-top': `${this.top}px` };
    return (index.h(index.Host, { style: style }, index.h("button", { type: "button", "aria-label": i18n.state.add.add_element, onClick: ($event) => this.selectPlugins($event), onKeyDown: ($event) => $event.stopPropagation(), onMouseDown: ($event) => $event.stopPropagation(), onTouchStart: ($event) => $event.stopPropagation() }, index.h(IconAdd, null))));
  }
};
Add.style = addCss;

const colorCss$1 = ":host{display:flex;align-items:center;justify-content:center;flex-wrap:var(--stylo-color-flex-wrap, wrap);overflow:var(--stylo-color-overflow, visible);padding:var(--stylo-color-padding, 8px);width:var(--stylo-color-width, 298px)}button{width:var(--stylo-color-button-width, 28px);height:var(--stylo-color-button-height, 28px);margin:var(--stylo-color-button-margin, 4px);padding:0;outline:var(--stylo-color-button-outline, none);cursor:pointer;border:1px solid var(--stylo-palette-border-color, var(--stylo-palette-color-hex));border-radius:var(--stylo-color-button-border-radius, 1px);background:var(--stylo-palette-color-hex)}button.selected{box-shadow:0 0 4px 4px rgba(var(--stylo-palette-box-shadow-color, var(--stylo-palette-color-rgb)), 0.4)}button:not(.selected):hover,button:not(.selected):focus{box-shadow:0 0 2px 2px rgba(var(--stylo-palette-box-shadow-color, var(--stylo-palette-color-rgb)), 0.4)}";

const Color$1 = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.colorChange = index.createEvent(this, "colorChange", 7);
    this.debounceInitSelectedColorPalette = d(() => {
      this.selectedColorPalette = this.initSelectedColorPalette();
      this.selectedCustomColorRgb = !this.selectedColorPalette ? this.selectedColorRgb : undefined;
    }, 150);
    this.selectColor = ($event) => {
      const color = $event.detail;
      this.applyColorHexChange(color.hex, color.rgb);
      this.colorChange.emit(color);
    };
    this.palette = toolbar.DEFAULT_PALETTE;
    this.inputAlt = 'Input a color (hex)';
    this.colorHex = undefined;
    this.colorRgb = undefined;
    this.selectedColorHex = undefined;
    this.selectedColorRgb = undefined;
    this.selectedColorPalette = false;
    this.selectedCustomColorRgb = undefined;
  }
  componentWillLoad() {
    this.selectedColorHex = this.colorHex;
    this.selectedColorRgb = this.colorRgb ? this.colorRgb : u(this.colorHex);
    this.selectedColorPalette = this.initSelectedColorPalette();
    if (!this.selectedColorPalette) {
      this.selectedCustomColorRgb = this.selectedColorRgb;
    }
  }
  async onColorHexChange() {
    this.applyColorHexChange(this.colorHex, undefined);
  }
  applyColorHexChange(colorHex, colorRgb) {
    this.selectedColorHex = colorHex;
    this.selectedColorRgb = colorRgb;
    this.debounceInitSelectedColorPalette();
    // Render component again
    this.palette = [...this.palette];
  }
  async onColorRgbChange() {
    this.selectedColorHex = undefined;
    this.selectedColorRgb = this.colorRgb;
    this.debounceInitSelectedColorPalette();
    // Render component again
    this.palette = [...this.palette];
  }
  pickColor(paletteColor) {
    if (!this.palette || this.palette.length <= 0) {
      return;
    }
    this.selectedColorHex = paletteColor.color ? paletteColor.color.hex : undefined;
    this.selectedColorRgb = paletteColor.color ? paletteColor.color.rgb : undefined;
    this.colorChange.emit(paletteColor.color);
    this.selectedColorPalette = true;
    this.selectedCustomColorRgb = undefined;
  }
  isHexColorSelected(element) {
    if (!element || !element.color || !element.color.hex) {
      return false;
    }
    if (!this.selectedColorHex) {
      return false;
    }
    return this.selectedColorHex.toUpperCase() === element.color.hex.toUpperCase();
  }
  isRgbColorSelected(element) {
    if (!element || !element.color || !element.color.rgb) {
      return false;
    }
    if (!this.selectedColorRgb) {
      return false;
    }
    return (this.selectedColorRgb.replace(/\s/g, '').toUpperCase() ===
      element.color.rgb.replace(/\s/g, '').toUpperCase());
  }
  initSelectedColorPalette() {
    if (!this.palette || this.palette.length <= 0) {
      return false;
    }
    const index = this.palette.findIndex((element) => {
      return this.isHexColorSelected(element) || this.isRgbColorSelected(element);
    });
    return index > -1;
  }
  render() {
    return (index.h(index.Host, null, this.renderPalette(), this.renderInput()));
  }
  renderPalette() {
    if (this.palette && this.palette.length > 0) {
      return this.palette.map((element) => {
        const style = {
          '--stylo-palette-color-hex': `${element.color.hex}`,
          '--stylo-palette-color-rgb': `${element.color.rgb}`
        };
        if (element.display) {
          style['--stylo-palette-border-color'] = element.display.borderColor;
          style['--stylo-palette-box-shadow-color'] = element.display.boxShadowColor;
        }
        return (index.h("button", { "aria-label": element.alt, class: this.isHexColorSelected(element) || this.isRgbColorSelected(element)
            ? 'selected'
            : undefined, style: style, onClick: ($event) => {
            $event.stopPropagation();
            this.pickColor(element);
          } }));
      });
    }
    else {
      return undefined;
    }
  }
  renderInput() {
    return (index.h("stylo-color-input", { colorHex: this.selectedColorHex, colorRgb: this.selectedColorRgb, customColorRgb: this.selectedCustomColorRgb, inputAlt: this.inputAlt, onSelectHexColor: this.selectColor }));
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "colorHex": ["onColorHexChange"],
    "colorRgb": ["onColorRgbChange"]
  }; }
};
Color$1.style = colorCss$1;

const inputCss = ":host{display:flex;position:relative;margin:var(--stylo-color-input-margin, 4px);border-radius:var(--stylo-color-input-container-border-radius);border:var(--stylo-color-input-container-border)}span{width:var(--stylo-color-hash-width, 28px);height:var(--stylo-color-hash-height, 28px);display:inline-flex;justify-content:center;align-items:center;background:var(--stylo-color-hash-background, #f0f0f0 none repeat scroll 0 0);color:var(--stylo-color-hash-color, #98a1a4);border-radius:var(--stylo-color-hash-border-radius, 4px 0 0 4px)}input{color:var(--stylo-color-input-color, #666666);background:var(--stylo-color-input-background, inherit);border:none;outline:none;height:var(--stylo-color-input-height, 28px);box-shadow:var(--stylo-color-input-box-shadow, #f0f0f0 0 0 0 1px inset);border-radius:var(--stylo-color-input-border-radius, 0 4px 4px 0);padding:var(--stylo-color-input-padding, 0 4px);max-width:var(--stylo-color-input-max-width, 136px);font-family:var(--stylo-color-input-font-family, inherit)}";

const Input = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.selectHexColor = index.createEvent(this, "selectHexColor", 7);
    this.debounceSelectColor = d((inputColor) => this.emitColor(inputColor), 500);
    this.colorHex = undefined;
    this.colorRgb = undefined;
    this.customColorRgb = undefined;
    this.inputAlt = undefined;
    this.color = undefined;
  }
  async componentWillLoad() {
    this.color = this.initColorHex();
  }
  async watchColors() {
    this.color = this.initColorHex();
  }
  initColorHex() {
    if (this.colorHex) {
      return this.colorHex;
    }
    if (this.customColorRgb) {
      return i(this.customColorRgb);
    }
    return i(this.colorRgb);
  }
  emitColor(inputColor) {
    const hex = `#${inputColor.replace('#', '')}`;
    const rgb = u(hex);
    if (!rgb) {
      return;
    }
    this.selectHexColor.emit({
      hex,
      rgb
    });
  }
  render() {
    var _a;
    return (index.h(index.Host, null, index.h("span", null, "#"), index.h("input", { type: "text", name: "color-picker", "aria-label": this.inputAlt, onInput: ($event) => this.debounceSelectColor($event.target.value), value: (_a = this.color) === null || _a === void 0 ? void 0 : _a.replace('#', '') })));
  }
  static get watchers() { return {
    "colorHex": ["watchColors"],
    "colorRgb": ["watchColors"],
    "customColorRgb": ["watchColors"]
  }; }
};
Input.style = inputCss;

const emitAddParagraphs = ({ editorRef, addedParagraphs }) => emit({ editorRef, detail: addedParagraphs, message: 'addParagraphs' });
const emitDeleteParagraphs = ({ editorRef, removedParagraphs }) => emit({ editorRef, detail: removedParagraphs, message: 'deleteParagraphs' });
const emitUpdateParagraphs = ({ editorRef, updatedParagraphs }) => emit({ editorRef, detail: updatedParagraphs, message: 'updateParagraphs' });
const emit = ({ editorRef, message, detail }) => {
  const $event = new CustomEvent(message, { detail, bubbles: true });
  editorRef === null || editorRef === void 0 ? void 0 : editorRef.dispatchEvent($event);
};

const findAddedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const addedNodes = mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
  return filterAddedParagraphs({ nodes: addedNodes, container });
};
const findAddedNodesParagraphs = ({ mutations, container }) => {
  return mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .filter(({ addedNodes }) => !toolbar.isParagraph({ element: addedNodes[0], container }))
    .filter(({ addedNodes }) => !toolbar.isParagraphEmpty({
    paragraph: toolbar.findParagraph({ element: addedNodes[0], container })
  }));
};
const hasNodeParagraph = ({ removedNodes, paragraphIdentifier }) => Array.from(removedNodes).find((removedNode) => { var _a; return !toolbar.isTextNode(removedNode) && ((_a = toolbar.toHTMLElement(removedNode)) === null || _a === void 0 ? void 0 : _a.hasAttribute(paragraphIdentifier)); }) !== undefined;
const findRemovedNodesParagraphs = ({ mutations, paragraphIdentifier }) => mutations
  .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
  .filter(({ removedNodes }) => !hasNodeParagraph({ removedNodes, paragraphIdentifier }));
const findRemovedParagraphs = ({ mutations, container, paragraphIdentifier }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  return mutations
    .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
    .reduce((acc, { removedNodes, previousSibling }) => {
    const paragraphs = filterRemovedParagraphs({
      nodes: Array.from(removedNodes),
      paragraphIdentifier
    });
    return [
      ...acc,
      ...paragraphs.map((paragraph) => ({
        paragraph,
        previousSibling: findPreviousElementSibling({ container, previousSibling })
      }))
    ];
  }, []);
};
/**
 * The mutation observer previous sibling can be a #text node. Because we assume every child of the container are HTML elements, we iterate until we find the closest one.
 */
const findPreviousElementSibling = ({ previousSibling, container }) => {
  if (!previousSibling) {
    return undefined;
  }
  if (container.isEqualNode(previousSibling)) {
    return undefined;
  }
  if (!toolbar.isTextNode(previousSibling)) {
    return previousSibling;
  }
  return findPreviousElementSibling({ previousSibling: previousSibling.previousSibling, container });
};
const findUpdatedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const nodes = mutations.reduce((acc, { target }) => [...acc, target], []);
  return [
    ...new Set(nodes
      .map((node) => toolbar.findParagraph({ element: node, container }))
      .filter((paragraph) => paragraph !== undefined &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE))
  ];
};
const filterAddedParagraphs = ({ nodes, container }) => {
  return nodes
    .filter((node) => toolbar.isParagraph({ element: node, container }))
    .filter((paragraph) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE && (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE);
};
const filterRemovedParagraphs = ({ nodes, paragraphIdentifier }) => {
  return nodes
    .filter((paragraph) => !toolbar.isTextNode(paragraph))
    .map((node) => node)
    .filter((element) => element === null || element === void 0 ? void 0 : element.hasAttribute(paragraphIdentifier));
};
const findSelectionParagraphs = ({ container, filterEmptySelection }) => {
  const { range, selection } = getRange(container);
  if (!range || (filterEmptySelection && (selection === null || selection === void 0 ? void 0 : selection.toString().length) === 0)) {
    return undefined;
  }
  const start = toolbar.toHTMLElement(toolbar.findParagraph({ element: range.startContainer, container }));
  const end = toolbar.toHTMLElement(toolbar.findParagraph({ element: range.endContainer, container }));
  if (!end || !start || (start === null || start === void 0 ? void 0 : start.isSameNode(end))) {
    return start ? [start] : [];
  }
  if (start.nextElementSibling.isSameNode(end)) {
    return [start, end];
  }
  const nodes = [];
  let next = start.nextElementSibling;
  while (next !== null && !next.isSameNode(end)) {
    nodes.push(toolbar.toHTMLElement(next));
    next = next.nextElementSibling;
  }
  return [start, ...nodes, end];
};
const filterAttributesMutations = ({ mutations, excludeAttributes }) => {
  const attributeMutations = mutations.filter(({ attributeName }) => attributeName !== null);
  // We consider only single change. If the mutations contains one attribute to exclude, we ignore all the mutations
  // If a web component attribute is updated, e.g theme="ubuntu", the component might update the class of the host
  // In such case, the mutation observer will be triggered twice
  const excludeMutations = attributeMutations.find(({ attributeName }) => excludeAttributes.includes(attributeName));
  if (excludeMutations !== undefined) {
    return [];
  }
  return attributeMutations;
};

class DataEvents {
  constructor() {
    this.stackDataMutations = [];
    this.debounceUpdateInput = d(() => this.updateData(), 500);
    this.onTreeMutation = async (mutations) => {
      const addedParagraphs = await this.addParagraphs(mutations);
      this.deleteParagraphs(mutations);
      this.updateAddedNodesParagraphs({ addedParagraphs, mutations });
    };
    this.onAttributesMutation = (mutations) => {
      this.updateParagraphs({
        mutations: filterAttributesMutations({
          mutations,
          excludeAttributes: configStore.state.attributes.exclude
        })
      });
    };
    this.onDataMutation = (mutations) => {
      this.stackDataMutations.push(...mutations);
      this.debounceUpdateInput();
    };
  }
  init({ editorRef }) {
    this.editorRef = editorRef;
    this.treeObserver = new MutationObserver(this.onTreeMutation);
    this.treeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    this.attributesObserver = new MutationObserver(this.onAttributesMutation);
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true, subtree: true });
    this.dataObserver = new MutationObserver(this.onDataMutation);
    this.dataObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.treeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.attributesObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.dataObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  async addParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (addedParagraphs.length <= 0) {
      return [];
    }
    await Promise.all(addedParagraphs.map((paragraph) => toolbar.setParagraphAttribute({
      paragraph,
      attributeName: configStore.state.attributes.paragraphIdentifier
    })));
    emitAddParagraphs({ editorRef: this.editorRef, addedParagraphs });
    return addedParagraphs;
  }
  deleteParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    const removedNodes = mutations.reduce((acc, { removedNodes }) => [...acc, ...Array.from(removedNodes)], []);
    const removedParagraphs = removedNodes
      .filter((node) => !toolbar.isTextNode(node))
      .filter((removedNode) => addedNodes.find((addedNode) => addedNode.isEqualNode(removedNode)) === undefined)
      .map((node) => toolbar.toHTMLElement(node))
      .filter((element) => element === null || element === void 0 ? void 0 : element.hasAttribute(configStore.state.attributes.paragraphIdentifier));
    if (removedParagraphs.length <= 0) {
      return;
    }
    emitDeleteParagraphs({ editorRef: this.editorRef, removedParagraphs });
  }
  updateAddedNodesParagraphs({ mutations, addedParagraphs }) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    this.updateParagraphs({
      mutations: [...addedNodesMutations, ...removedNodesMutations],
      addedParagraphs
    });
  }
  updateData() {
    if (!this.stackDataMutations || this.stackDataMutations.length <= 0) {
      return;
    }
    const mutations = [...this.stackDataMutations];
    this.stackDataMutations = [];
    this.updateParagraphs({ mutations });
  }
  updateParagraphs({ mutations, addedParagraphs = [] }) {
    if (!containerStore.state.ref) {
      return;
    }
    const updatedParagraphs = findUpdatedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (updatedParagraphs.length <= 0) {
      return;
    }
    // Browser might report an update for a node that might have just been added. We do not consider these as updates.
    // Useful when client persist paragraphs because the updated node might not be persisted yet since it was just added and emitted as such.
    const justAdded = (element) => addedParagraphs.find((addedParagraph) => addedParagraph.isSameNode(element)) !==
      undefined;
    const existingUpdatedParagraphs = updatedParagraphs.filter((element) => !justAdded(element));
    if (existingUpdatedParagraphs.length <= 0) {
      return;
    }
    emitUpdateParagraphs({ editorRef: this.editorRef, updatedParagraphs: existingUpdatedParagraphs });
  }
}

const { state, onChange, reset } = createStore({
  undo: undefined,
  redo: undefined,
  observe: true
});
const undoRedoStore = { state, onChange, reset };

const toUndoRedoSelection = (container) => {
  const { range, selection } = getRange();
  if (!range) {
    return undefined;
  }
  const { anchorNode, focusNode } = selection;
  const startParagraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: anchorNode, container }));
  const endParagraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: focusNode, container }));
  if (!startParagraph || !endParagraph) {
    return;
  }
  return {
    startIndex: toolbar.elementIndex(startParagraph),
    startIndexDepths: toolbar.nodeDepths({
      target: anchorNode,
      paragraph: toolbar.findParagraph({ element: anchorNode, container })
    }),
    startOffset: selection.anchorOffset,
    endIndex: toolbar.elementIndex(endParagraph),
    endIndexDepths: toolbar.nodeDepths({
      target: focusNode,
      paragraph: toolbar.findParagraph({ element: focusNode, container })
    }),
    endOffset: selection.focusOffset,
    reverse: !anchorNode.isEqualNode(range.startContainer)
  };
};
const redoSelection = ({ selection, container }) => {
  if (!selection) {
    return;
  }
  const { startIndex, startIndexDepths, startOffset, endIndex, endIndexDepths, endOffset, reverse } = selection;
  const startParagraph = container.children[Math.min(startIndex, container.children.length - 1)];
  const endParagraph = container.children[Math.min(endIndex, container.children.length - 1)];
  const startNode = toolbar.findNodeAtDepths({
    parent: startParagraph,
    indexDepths: startIndexDepths
  });
  const endNode = toolbar.findNodeAtDepths({
    parent: endParagraph,
    indexDepths: endIndexDepths
  });
  if (!startNode || !endNode) {
    return;
  }
  // Prevent error "DOMException: Failed to execute 'setStart' on 'Range': The offset 7 is larger than the node's length (1)."
  if (startNode.textContent.length < startOffset || endNode.textContent.length < endOffset) {
    return;
  }
  const range = document.createRange();
  if (!reverse) {
    range.setStart(startNode, startOffset);
    range.setEnd(endNode, endOffset);
  }
  else {
    range.setEnd(startNode, startOffset);
    range.setStart(endNode, endOffset);
  }
  const windowSelection = getSelection$1(container);
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.removeAllRanges();
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.addRange(range);
  range.detach();
};

const stackUndoInput = ({ container, data }) => {
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  undoRedoStore.state.undo.push({
    changes: data.map((undoRedoInput) => ({
      type: 'input',
      target: container,
      data: undoRedoInput
    }))
  });
  undoRedoStore.state.redo = [];
};
const stackUndoParagraphs = ({ container, addRemoveParagraphs, updateParagraphs, selection }) => {
  if (addRemoveParagraphs.length <= 0 && updateParagraphs.length <= 0) {
    return;
  }
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  const changes = {
    changes: [
      {
        type: 'paragraph',
        target: container,
        data: addRemoveParagraphs.map(({ outerHTML, index, mutation }) => ({
          outerHTML,
          mutation,
          index
        }))
      },
      {
        type: 'update',
        target: container,
        data: updateParagraphs
      }
    ],
    selection
  };
  undoRedoStore.state.undo.push(changes);
  undoRedoStore.state.redo = [];
};
const nextUndoChanges = () => nextChange(undoRedoStore.state.undo);
const nextRedoChanges = () => nextChange(undoRedoStore.state.redo);
const nextChange = (changes) => {
  if (!changes) {
    return undefined;
  }
  return changes[changes.length - 1];
};
const undo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.undo = [
    ...undoRedoStore.state.undo.slice(0, undoRedoStore.state.undo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.redo.push(value),
  undoChanges: nextUndoChanges()
});
const redo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.redo = [
    ...undoRedoStore.state.redo.slice(0, undoRedoStore.state.redo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.undo.push(value),
  undoChanges: nextRedoChanges()
});
const undoRedo = async ({ popFrom, pushTo, undoChanges }) => {
  if (!undoChanges) {
    return;
  }
  const currentSelection = toUndoRedoSelection(containerStore.state.ref);
  const { changes, selection } = undoChanges;
  let redoChanges = [];
  for (const undoChange of changes) {
    redoChanges = [await undoRedoChange({ undoChange }), ...redoChanges];
  }
  redoSelection({ container: containerStore.state.ref, selection });
  pushTo({ changes: redoChanges, selection: currentSelection });
  popFrom();
};
const undoRedoChange = async ({ undoChange }) => {
  const { type } = undoChange;
  if (type === 'input') {
    return undoRedoInput({ undoChange });
  }
  if (type === 'paragraph') {
    return undoRedoParagraph({ undoChange });
  }
  return undoRedoUpdate({ undoChange });
};
const undoRedoInput = async ({ undoChange }) => {
  var _a;
  const { data, target } = undoChange;
  const container = toolbar.toHTMLElement(target);
  const { oldValue, offset: newCaretPosition, index, indexDepths } = data;
  const paragraph = container.children[index];
  let text = toolbar.findNodeAtDepths({ parent: paragraph, indexDepths });
  if (!text || !toolbar.isTextNode(text)) {
    // We try to find sibling in case the parent does not yet exist. If we find it, we can replicate such parent for the new text.
    // Useful notably when reverting lists and li.
    const cloneIndexDepths = [...indexDepths];
    cloneIndexDepths.pop();
    let parent = cloneIndexDepths.length <= 0
      ? text
        ? text.parentNode
        : undefined
      : toolbar.findNodeAtDepths({ parent: paragraph, indexDepths: [...cloneIndexDepths] });
    if (!parent && toolbar.isTextNode((_a = toolbar.toHTMLElement(paragraph)) === null || _a === void 0 ? void 0 : _a.lastChild)) {
      text = toolbar.toHTMLElement(paragraph).lastChild;
    }
    if (!text) {
      if (!parent) {
        parent = await createLast({ paragraph: toolbar.toHTMLElement(paragraph) || container, container });
      }
      text = await prependText({ parent: toolbar.toHTMLElement(parent), container });
    }
  }
  const { previousValue } = await updateNodeValue({ text, oldValue, container });
  toolbar.f({
    element: text,
    offset: Math.max(Math.min(oldValue.length > newCaretPosition ? newCaretPosition : oldValue.length, text.nodeValue.length), 0)
  });
  return {
    type: 'input',
    target: container,
    data: {
      index,
      indexDepths: toolbar.nodeDepths({ target: text !== null && text !== void 0 ? text : target, paragraph }),
      oldValue: previousValue,
      offset: newCaretPosition + (previousValue.length - oldValue.length)
    }
  };
};
const undoRedoParagraph = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const container = toolbar.toHTMLElement(target);
  const paragraphs = data;
  let to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML, mutation } = paragraph;
    if (mutation === 'add') {
      await removeNode({ container, index });
      to = [
        {
          outerHTML,
          index,
          mutation: 'remove'
        },
        ...to
      ];
    }
    if (mutation === 'remove') {
      await insertNode({ container, index, outerHTML });
      to = [
        {
          outerHTML,
          mutation: 'add',
          index
        },
        ...to
      ];
    }
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
const undoRedoUpdate = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const paragraphs = data;
  const container = toolbar.toHTMLElement(target);
  const to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML } = paragraph;
    const { previousOuterHTML } = await updateNode({
      container,
      index,
      outerHTML
    });
    to.push({ index, outerHTML: previousOuterHTML });
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
/**
 * Because we are using indexes to add or remove back and forth elements, we have to wait for changes to be applied to the DOM before iterating to next element to process.
 * That's why the mutation observer and promises.
 */
const insertNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const previousSiblingIndex = index - 1;
  if (previousSiblingIndex === -1) {
    container.insertAdjacentHTML('afterbegin', outerHTML);
    return;
  }
  container.children[Math.min(previousSiblingIndex, container.children.length - 1)].insertAdjacentHTML('afterend', outerHTML);
});
const removeNode = ({ container, index }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const element = container.children[Math.min(index, container.children.length - 1)];
  element === null || element === void 0 ? void 0 : element.parentElement.removeChild(element);
});
const updateNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const paragraph = container.children[Math.min(index, container.children.length - 1)];
  const previousOuterHTML = paragraph.outerHTML;
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve({ previousOuterHTML });
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  paragraph.outerHTML = outerHTML;
});
const prependText = ({ parent, container }) => new Promise((resolve) => {
  const text = document.createTextNode('');
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(text);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  parent.prepend(text);
});
const updateNodeValue = ({ container, oldValue, text }) => new Promise((resolve) => {
  const previousValue = text.nodeValue;
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve({ previousValue });
  });
  changeObserver.observe(container, { characterData: true, subtree: true });
  text.nodeValue = oldValue;
});
const createLast = ({ container, paragraph }) => new Promise((resolve) => {
  var _a;
  const anchor = ((_a = paragraph.lastElementChild) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) !== 'br'
    ? toolbar.toHTMLElement(paragraph.lastElementChild)
    : document.createElement('span');
  const parent = toolbar.toHTMLElement(anchor.cloneNode());
  parent.innerHTML = '';
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(parent);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  anchor.after(parent);
});

class EnterEvents {
  constructor() {
    this.onKeyDown = async ($event) => {
      if (!isKeyboardEnter($event)) {
        return;
      }
      await this.createParagraph($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  async createParagraph($event) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchor = toolbar.toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
    // Create only if we have an anchor otherwise let the browser deals with it
    if (!anchor) {
      return;
    }
    const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: anchor, container: containerStore.state.ref }));
    // Same as above but should not happen
    if (!paragraph) {
      return;
    }
    // In "list" we use return to create new lines
    if (toolbar.isNodeList({ node: paragraph })) {
      return;
    }
    $event.preventDefault();
    // We undo-redo stack an update of the current paragraph value
    const undoParagraphs = this.toUpdateParagraphs([paragraph]);
    deleteRange(range);
    // Extract the rest of the "line" (the paragraph) form the cursor position to end
    range.collapse(true);
    range.setEndAfter(paragraph);
    const fragment = range.cloneContents();
    const isEndOfParagraph = fragment.textContent === '';
    const { shiftKey } = $event;
    if (shiftKey || toolbar.isParagraphCode({ paragraph })) {
      await this.createLineBreak({ anchor, paragraph, isEndOfParagraph, range, undoParagraphs });
      return;
    }
    // We created a new paragraph with the cursor at the end aka we pressed "Enter" with the cursor at the end of the paragraph
    if (isEndOfParagraph) {
      const newParagraph = await toolbar.createEmptyParagraph({
        container: containerStore.state.ref,
        paragraph
      });
      toolbar.u(newParagraph);
      return;
    }
    await this.createParagraphWithContent({
      range,
      paragraph,
      undoParagraphs
    });
  }
  async createParagraphWithContent({ paragraph, range, undoParagraphs }) {
    // We have to handle undo-redo manually because we want the redo to redo everything in one block
    undoRedoStore.state.observe = false;
    // The new fragment is a div - i.e. is a paragraph
    const moveFragment = range.extractContents();
    const newParagraph = await toolbar.addParagraph({
      container: containerStore.state.ref,
      paragraph,
      fragment: moveFragment
    });
    // We undo-redo stack the new paragraph to remove it on undo
    const addRemoveParagraphs = this.toAddParagraphs([toolbar.toHTMLElement(newParagraph)]);
    // If original paragraph is now empty - the all content has been moved to a new paragraph - we add a zero length width otherwise the div has no height
    // We do not need to add this to undo-redo stack
    // Happens for example when user click enter at the begin of the paragraph
    if (paragraph.textContent === '') {
      await toolbar.prependEmptyText({ paragraph });
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs,
      updateParagraphs: undoParagraphs
    });
    // We don't move the cursor, we keep the position at the beginning of the new paragraph
    undoRedoStore.state.observe = true;
    toolbar.g(newParagraph);
  }
  toAddParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: toolbar.elementIndex(paragraph),
      mutation: 'add'
    }));
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: toolbar.elementIndex(paragraph)
    }));
  }
  async createLineBreak({ anchor, paragraph, isEndOfParagraph, range, undoParagraphs }) {
    undoRedoStore.state.observe = false;
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: undoParagraphs
    });
    // Reset range end we do not want to select empty text
    range.setEndAfter(getSelection$1(containerStore.state.ref).anchorNode);
    const newNode = await toolbar.createNewEmptyLine({
      paragraph: anchor,
      range
    });
    if (!isEndOfParagraph || !newNode) {
      toolbar.g(newNode);
      undoRedoStore.state.observe = true;
      return;
    }
    const text = await toolbar.addEmptyText({
      paragraph,
      element: newNode
    });
    toolbar.g(text);
    undoRedoStore.state.observe = true;
  }
}

const beforeInputTransformer = [
  {
    match: ({ key, lastKey, lastBeforeInput }) => {
      if (f()) {
        return ['', '', ''].includes(lastBeforeInput === null || lastBeforeInput === void 0 ? void 0 : lastBeforeInput.key) && key.key === ' ';
      }
      return key.key === '`' && [' ', 'Dead'].includes(lastKey === null || lastKey === void 0 ? void 0 : lastKey.key);
    },
    transform: () => {
      return document.createElement('mark');
    },
    active: (element) => (element === null || element === void 0 ? void 0 : element.nodeName.toLowerCase()) === 'mark',
    shouldTrimText: ({ nodeValue }) => nodeValue.charAt(nodeValue.length - 1) === '`' || nodeValue.charAt(0) === '`',
    shouldTrimSplit: ({ target, startOffset }) => startOffset !== undefined && target.nodeValue.charAt(startOffset - 1) === '`',
    trim: () => '`'.length,
    postTransform: () => replaceBacktick()
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '*' && key.key === '*',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontWeight = 'bold';
      return span;
    },
    active: (parent) => {
      if (!parent) {
        return false;
      }
      const { fontWeight } = window.getComputedStyle(parent);
      return parseInt(fontWeight) > 400 || fontWeight === 'bold';
    },
    shouldTrimText: ({ nodeValue }) => nodeValue.charAt(nodeValue.length - 1) === '*' || nodeValue.charAt(0) === '*',
    shouldTrimSplit: ({ target, startOffset }) => startOffset !== undefined && target.nodeValue.charAt(startOffset - 1) === '*',
    trim: () => '*'.length
  },
  {
    match: ({ lastBeforeInput, key }) => (lastBeforeInput === null || lastBeforeInput === void 0 ? void 0 : lastBeforeInput.key) === ' ' && key.key === '_',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontStyle = 'italic';
      return span;
    },
    active: (parent) => {
      if (!parent) {
        return false;
      }
      const { fontStyle } = window.getComputedStyle(parent);
      return fontStyle === 'italic';
    },
    shouldTrimText: (_target) => false,
    shouldTrimSplit: () => false,
    trim: () => ''.length
  }
];
const transformInput = async ({ $event, transformInput, target, parent }) => {
  // Check if we can transform or end tag
  if (!canTransform({ target, parent, transformInput })) {
    return;
  }
  $event.preventDefault();
  // Disable undo-redo observer as we are about to play with the DOM
  undoRedoStore.state.observe = false;
  // We might remove the character, a * or `, if present
  await updateText({ target, parent, transformInput });
  // We had fun, we can observe again the undo redo store to stack the next bold element we are about to create
  undoRedoStore.state.observe = true;
  await createNode({ target, parent, transformInput });
};
const replaceBacktick = () => {
  if (b()) {
    return Promise.resolve();
  }
  return replaceBacktickText();
};
/**
 * On Swiss French keyboard - i.e. when backtick is entered with "Shift + key":
 *
 * - Chrome renders the backtick in the new mark therefore we have to delete it the new element
 * - Firefox renders the new mark and renders the backtick at the begin of the previous text element
 */
const replaceBacktickText = () => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async (mutations) => {
      changeObserver.disconnect();
      const target = mutations[0].target;
      // On us keyboard, the backtick is already removed
      if (!target.nodeValue.includes('`')) {
        resolve();
        return;
      }
      undoRedoStore.state.observe = false;
      await replaceChar({ target, searchValue: '`', replaceValue: '' });
      undoRedoStore.state.observe = true;
      const parent = toolbar.toHTMLElement(target);
      const mark = (parent === null || parent === void 0 ? void 0 : parent.nodeName.toLowerCase()) === 'mark';
      if (w()) {
        toolbar.u(mark ? parent.nextSibling : target.nextSibling);
        resolve();
        return;
      }
      toolbar.u(mark ? target : target.nextSibling);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  });
};
const replaceChar = ({ target, searchValue, replaceValue }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.replace(searchValue, replaceValue);
  });
};
const createNode = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      toolbar.u((_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const { active, transform } = transformInput;
    if (active(parent)) {
      // We are in a bold node, therefore we want to exit it
      return;
    }
    // We create the new node and a node afterwards if last node of the paragraph so user can escape by clicking the arrow right
    const newNode = transform();
    newNode.innerHTML = '\u200B';
    const newText = document.createTextNode('\u200B');
    if (target.nextSibling) {
      parent.insertBefore(newNode, target.nextSibling);
    }
    else {
      parent.append(newNode, newText);
    }
  });
};
const canTransform = ({ target, parent, transformInput }) => {
  const index = toolbar.m({ target });
  // We are typing at the end of the node text, we can transform it
  if (target.nodeValue.length === index) {
    return true;
  }
  // We are typing in the middle of a text node, we can transform it or end it only if not yet transformed
  const { active } = transformInput;
  return !active(parent);
};
const updateText = ({ target, transformInput, parent }) => {
  return new Promise(async (resolve) => {
    const index = toolbar.m({ target });
    // Exact same length, so we remove the last characters
    if (target.nodeValue.length === index) {
      if (!transformInput.shouldTrimText(target)) {
        resolve();
        return;
      }
      const changeObserver = new MutationObserver(() => {
        changeObserver.disconnect();
        resolve();
      });
      changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
      target.nodeValue = target.nodeValue.substring(0, target.nodeValue.length - transformInput.trim());
      return;
    }
    // The end results will be text followed by a span bold and then the remaining text
    const newText = await splitText({ target, index, transformInput });
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      toolbar.u((_a = mutations[1]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    if (target.nextSibling) {
      parent.insertBefore(newText, target.nextSibling);
    }
    else {
      parent.appendChild(newText);
    }
  });
};
const splitText = ({ target, index, transformInput }) => {
  return new Promise((resolve) => {
    var _a, _b;
    const changeObserver = new MutationObserver(async () => {
      changeObserver.disconnect();
      if (!transformInput.shouldTrimText(newText)) {
        resolve(newText);
        return;
      }
      const node = await removeChar({ target: newText, index: 1 });
      resolve(node);
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const startOffset = (_b = (_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.getRangeAt(0)) === null || _b === void 0 ? void 0 : _b.startOffset;
    const newText = target.splitText(index - (transformInput.shouldTrimSplit({ target, startOffset }) ? transformInput.trim() : 0));
  });
};
const removeChar = ({ target, index }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(index);
  });
};

class InputEvents {
  constructor() {
    this.lastBeforeInput = undefined;
    this.lastKey = undefined;
    this.onBeforeInput = async ($event) => {
      await this.preventTextLeaves($event);
      // Use for comparison purpose in transformInput
      const { data: key } = $event;
      this.lastBeforeInput = { key };
    };
    this.onKeyDown = async ($event) => {
      await this.transformInput($event);
      // This should be an on keydown listener because Firefox do not provide the same range in before input
      this.deleteSelection($event);
    };
  }
  init() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keydown', this.onKeyDown);
  }
  async preventTextLeaves($event) {
    var _a;
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchorNode = selection === null || selection === void 0 ? void 0 : selection.anchorNode;
    if (!containerStore.state.ref.isEqualNode(anchorNode)) {
      return;
    }
    const { data } = $event;
    // User is not typing, for example an image is moved
    if (data === null) {
      return;
    }
    const { startOffset } = range;
    const target = toolbar.findNodeAtDepths({
      parent: containerStore.state.ref,
      indexDepths: [startOffset]
    });
    // We create a div - i.e. new HTML element - only if the actual target is not an editable paragraph that accepts text
    if ((_a = configStore.state.textParagraphs) === null || _a === void 0 ? void 0 : _a.includes(target === null || target === void 0 ? void 0 : target.nodeName.toLowerCase())) {
      // We set the range to the start of the target because if we don't, the browser might create a text element before the target anyway
      range.setStart(target, 0);
      return;
    }
    // User is typing text at the root of the container therefore the browser will create a text node a direct descendant of the contenteditable
    // This can happen when user types for example before or after an image
    $event.preventDefault();
    const div = await toolbar.createNewParagraph({
      container: containerStore.state.ref,
      range,
      text: data
    });
    toolbar.u(div);
  }
  async transformInput($event) {
    var _a;
    const { key } = $event;
    const selection = getSelection$1(containerStore.state.ref);
    if (!selection) {
      return;
    }
    const { focusNode: target } = selection;
    const parent = toolbar.toHTMLElement(target);
    const isActive = beforeInputTransformer.find(({ active }) => active(parent)) !== undefined;
    // We are in an active mark up, therefore we do not check to transform. User can escape by moving to next text node
    if (isActive) {
      return;
    }
    const transformer = beforeInputTransformer.find(({ match }) => match({ key: { key }, lastKey: this.lastKey, lastBeforeInput: this.lastBeforeInput }));
    if (transformer !== undefined) {
      await transformInput({ $event, transformInput: transformer, target, parent });
      await ((_a = transformer.postTransform) === null || _a === void 0 ? void 0 : _a.call(transformer));
      this.lastKey = undefined;
      return;
    }
    this.lastKey = { key };
  }
  deleteSelection($event) {
    const { key } = $event;
    if (!['Delete', 'Backspace'].includes(key)) {
      return;
    }
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    // If the commonAncestorContainer is the container then we have selected multiple paragraphs
    if (!containerStore.state.ref.isEqualNode(range === null || range === void 0 ? void 0 : range.commonAncestorContainer)) {
      return;
    }
    // If first char is a zeroWidthSpace and the offset start at the second character, reset range to begin
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    if (zeroWidthSpace) {
      range.setStart(range.startContainer, 0);
    }
    // We don't have a selection that starts at the beginning of an element and paragraph
    if (range.startOffset > 0) {
      return;
    }
    // We don't have a selection that starts at the beginning of a paragraph
    if (!toolbar.isStartNode({ element: range.startContainer, container: containerStore.state.ref })) {
      return;
    }
    const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: range.startContainer, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    // Reset range to begin of the paragraph in case it contains children
    range.setStartBefore(paragraph);
    $event.preventDefault();
    $event.stopImmediatePropagation();
    range.deleteContents();
  }
}

const createLink = ({ range, linkUrl }) => {
  const fragment = range.extractContents();
  const a = createLinkElementForFragment({ fragment, linkUrl });
  range.insertNode(a);
};
const removeLink = (container) => {
  const { range, selection } = getRange(container);
  if (!range) {
    return;
  }
  if (w()) {
    removeFirefoxLink(selection);
    return;
  }
  const anchor = toolbar.toHTMLElement(selection.anchorNode);
  const fragment = range.extractContents();
  anchor.parentElement.replaceChild(fragment, anchor);
};
const removeFirefoxLink = (selection) => {
  const container = toolbar.toHTMLElement(selection.anchorNode);
  if (!container || container.nodeName.toLowerCase() !== 'a') {
    return;
  }
  container.parentElement.insertBefore(document.createTextNode(container.textContent), container);
  container.parentElement.removeChild(container);
};
const createLinkElementForFragment = ({ fragment, linkUrl }) => {
  const a = createLinkElement({ linkUrl });
  a.appendChild(fragment);
  return a;
};
const createLinkElement = ({ linkUrl }) => {
  const a = document.createElement('a');
  a.href = linkUrl;
  a.rel = 'noopener noreferrer';
  a.target = '_blank';
  return a;
};

class PasteEvents {
  constructor() {
    this.onPaste = async ($event) => {
      const pasteHTML = $event.clipboardData.getData('text/html');
      const div = document.createElement('div');
      div.innerHTML = pasteHTML;
      // User either paste a non-html content or paste text with adapt style - i.e. paste text/plain within a paragraph
      const plainText = div.children.length <= 0;
      if (plainText) {
        const text = $event.clipboardData.getData('text/plain');
        const isUrl = (text) => {
          try {
            const { protocol } = new URL(text);
            return ['http:', 'https:'].includes(protocol);
          }
          catch (_) {
            return false;
          }
        };
        // If user paste a link as plain text we convert it to link
        if (isUrl(text)) {
          const a = createLinkElement({ linkUrl: text });
          a.innerHTML = text;
          div.append(a);
        }
      }
      // It's still plain text and we did not extract any urls
      if (plainText && div.children.length <= 0) {
        return;
      }
      const { range, selection } = getRange(containerStore.state.ref);
      if (!range) {
        return;
      }
      const anchor = toolbar.toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
      // No anchor so we let the browser deals with it
      if (!anchor) {
        return;
      }
      $event.preventDefault();
      // Undefined if user has removed all paragraphs of the container previously
      const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: anchor, container: containerStore.state.ref }));
      this.cleanAttributes(div);
      this.cleanMetas(div);
      const notOnlyText = Array.from(div.childNodes).find((node) => !toolbar.isPhrasingContent(node)) !== undefined;
      deleteRange(range);
      // If there is only text nodes and span, we consider the paste content as part of a paragraph. e.g. copy/paste a text and a link
      if (!notOnlyText) {
        // addParagraphs fallbacks to container append - this happens in case user delete all the content before parsing
        if (!paragraph) {
          toolbar.addParagraphs({
            paragraph,
            container: containerStore.state.ref,
            nodes: [div]
          });
          return;
        }
        await this.insertNodes({ range, div });
        return;
      }
      const elements = Array.from(div.childNodes).map((node) => {
        if (toolbar.isTextNode(node) || node.nodeName.toLowerCase().trim() === 'span') {
          const div = document.createElement('div');
          div.appendChild(node);
          return div;
        }
        return node;
      });
      const empty = toolbar.isParagraphEmpty({ paragraph });
      if (empty) {
        toolbar.transformParagraph({
          elements,
          paragraph,
          container: containerStore.state.ref
        });
        return;
      }
      // Extract the rest of the "line" (the paragraph) form the cursor position to end
      const moveFragment = this.splitCurrentParagraph({
        range,
        paragraph
      });
      toolbar.addParagraphs({
        paragraph,
        container: containerStore.state.ref,
        nodes: [...elements, ...(moveFragment !== undefined ? [moveFragment] : [])]
      });
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('paste', this.onPaste);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('paste', this.onPaste);
  }
  async insertNodes({ range, div }) {
    // convert to fragment to add all nodes at the range position
    const fragment = document.createDocumentFragment();
    fragment.append(...Array.from(div.childNodes));
    const last = await toolbar.insertNodeInRange({
      observerRoot: containerStore.state.ref,
      range,
      element: fragment
    });
    toolbar.u(last);
  }
  splitCurrentParagraph({ range, paragraph }) {
    if (!paragraph) {
      return undefined;
    }
    range.collapse(true);
    range.setEndAfter(paragraph);
    return range.extractContents();
  }
  cleanAttributes(div) {
    const attributes = [
      ...new Set([...configStore.state.attributes.exclude, 'class', 'style'])
    ];
    const cleanAttr = ({ element, attributes }) => {
      for (const attr of attributes) {
        element.removeAttribute(attr);
      }
    };
    const children = div.querySelectorAll(attributes.map((attr) => `[${attr}]`).join(','));
    for (const child of Array.from(children)) {
      cleanAttr({ element: child, attributes });
    }
    return div;
  }
  // clean all meta, style and title pasted tags
  cleanMetas(div) {
    const metas = Array.from(div.children).filter((node) => toolbar.isMetaContent(node));
    for (const element of metas) {
      element.parentElement.removeChild(element);
    }
    return div;
  }
}

class PlaceholderEvents {
  constructor() {
    this.onSelectParagraph = ({ detail }) => {
      var _a, _b, _c, _d, _e, _f;
      const firstParagraph = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.firstElementChild;
      const secondParagraph = (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.children[1];
      const first = firstParagraph && detail && detail.isEqualNode(firstParagraph);
      const second = secondParagraph && detail && detail.isEqualNode(secondParagraph);
      (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.removeEventListener('keydown', this.onKeyChange);
      (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.removeEventListener('keyup', this.onKeyChange);
      if (first || second) {
        (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.addEventListener('keydown', this.onKeyChange);
        (_f = containerStore.state.ref) === null || _f === void 0 ? void 0 : _f.addEventListener('keyup', this.onKeyChange);
      }
      this.classesEmpty();
      this.cleanEmpty();
    };
    this.onKeyChange = () => {
      var _a;
      const paragraph = toolbar.findParagraph({
        element: (_a = getSelection()) === null || _a === void 0 ? void 0 : _a.anchorNode,
        container: containerStore.state.ref
      });
      if (!paragraph || toolbar.isTextNode(paragraph)) {
        return;
      }
      // Workaround: add a bit of delay if user enters and deletes text quickly in the first paragraphs to detect the classes empty
      setTimeout(() => this.toggleClassEmpty(paragraph), 250);
    };
  }
  init({ editorRef }) {
    var _a, _b;
    this.editorRef = editorRef;
    (_a = this.editorRef) === null || _a === void 0 ? void 0 : _a.addEventListener('selectParagraph', this.onSelectParagraph);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('focusin', this.onSelectParagraph, { passive: true });
    this.classesEmpty();
  }
  destroy() {
    var _a, _b;
    (_a = this.editorRef) === null || _a === void 0 ? void 0 : _a.removeEventListener('selectParagraph', this.onSelectParagraph);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('focusin', this.onSelectParagraph);
  }
  classesEmpty() {
    var _a, _b;
    const firstParagraph = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.firstElementChild;
    const secondParagraph = (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.children[1];
    this.classEmpty(firstParagraph);
    this.classEmpty(secondParagraph);
  }
  classEmpty(element) {
    if (!element) {
      return;
    }
    const paragraph = toolbar.findParagraph({
      element,
      container: containerStore.state.ref
    });
    if (!paragraph || toolbar.isTextNode(paragraph)) {
      return;
    }
    this.toggleClassEmpty(paragraph);
  }
  toggleClassEmpty(paragraph) {
    var _a;
    const { classList, nodeName } = paragraph;
    if (!configStore.state.textParagraphs.includes(nodeName.toLowerCase())) {
      classList.remove('stylo-placeholder-empty');
      return;
    }
    const empty = toolbar.isParagraphEmpty({ paragraph });
    const index = toolbar.elementIndex(paragraph);
    // We add a placeholder for the title if empty.
    // We can display a placeholder for the second element if there are no other paragraphs, a bit weird to display a placeholder if user has began typing in another paragraph
    if (empty && (index === 0 || ((_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.children.length) <= 2)) {
      classList.add('stylo-placeholder-empty');
      return;
    }
    classList.remove('stylo-placeholder-empty');
  }
  /**
   * If a paragraph is added between the two first placeholder the new div might be created with a copy of this class so we clean it
   */
  cleanEmpty() {
    var _a;
    const elements = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.stylo-empty');
    const others = Array.from(elements || []).filter((element) => toolbar.elementIndex(element) > 1);
    for (const other of others) {
      other.classList.remove('stylo-empty');
    }
  }
}

class TabEvents {
  constructor() {
    this.onKeyDown = async ($event) => {
      const { key } = $event;
      if (!['Tab'].includes(key)) {
        return;
      }
      $event.preventDefault();
      await this.catchTab($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  async catchTab({ shiftKey }) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const node = selection === null || selection === void 0 ? void 0 : selection.focusNode;
    const paragraph = toolbar.findParagraph({
      element: node,
      container: containerStore.state.ref
    });
    if (paragraph && toolbar.isNodeList({ node: paragraph })) {
      await this.createSublist({ paragraph, node, range, shiftKey });
      return;
    }
    // Shiftkey only useful to replace sublist
    if (shiftKey) {
      return;
    }
    this.createTabulation({ range, node, paragraph });
  }
  createTabulation({ range, node, paragraph }) {
    if (!toolbar.isTextNode(node)) {
      if (paragraph !== undefined) {
        this.insertSpanTabulation({ range });
        return;
      }
      return;
    }
    this.insertSpanTabulation({ range });
  }
  insertSpanTabulation({ range }) {
    const span = document.createElement('span');
    span.innerHTML = '\u0009';
    range === null || range === void 0 ? void 0 : range.insertNode(span);
    toolbar.u(span);
  }
  async createSublist({ paragraph, node, range, shiftKey }) {
    // If list contains a single child that is just text then browser returns the list as focus node
    const focusNodeIsList = node !== undefined && toolbar.isNodeList({ node: node });
    const paragraphListNodeName = paragraph.nodeName.toLowerCase();
    const li = focusNodeIsList
      ? node.firstChild
      : this.findParentElement({
        element: node,
        paragraph,
        nodeName: 'li'
      });
    if (!li) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    const ul = focusNodeIsList
      ? node
      : this.findParentElement({
        element: node,
        paragraph,
        nodeName: paragraphListNodeName
      });
    if (!ul) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    if (shiftKey) {
      // We do not want to remove the top ul
      if (toolbar.isParagraph({ element: ul, container: containerStore.state.ref })) {
        return;
      }
      // Move cursor end to newly created list
      const observer = new MutationObserver((mutations) => {
        var _a;
        observer.disconnect();
        const addedFirstNode = (_a = mutations.find(({ addedNodes }) => addedNodes.length > 0)) === null || _a === void 0 ? void 0 : _a.addedNodes[0];
        // Move cursor to new li
        toolbar.g(addedFirstNode);
      });
      observer.observe(paragraph, { childList: true, subtree: true });
      const newRange = new Range();
      newRange.setStartBefore(li);
      newRange.setEndAfter(ul.lastChild);
      const liIndex = toolbar.nodeIndex(li);
      const contents = newRange.extractContents();
      // If we shift-tab first li of the ul, we want to replace the all ul
      if (liIndex === 0) {
        ul.parentElement.replaceChild(contents, ul);
        return;
      }
      // Else we want to bring the other li from the selected to end of this ul one level higher
      ul.parentElement.insertBefore(contents, ul.nextSibling);
      return;
    }
    const { endOffset, commonAncestorContainer } = range;
    const empty = commonAncestorContainer.textContent.length === 0;
    const cursorEnd = endOffset === commonAncestorContainer.textContent.length;
    const lastChild = commonAncestorContainer.isSameNode(this.findLastChild(li));
    if ((!cursorEnd || !lastChild) && !empty) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    // We do not want to index list that has a single element
    if (ul.childNodes.length === 1) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    // Move cursor end or start to added child
    const observer = new MutationObserver((mutations) => {
      var _a;
      observer.disconnect();
      const addedFirstNode = (_a = mutations.find(({ addedNodes }) => addedNodes.length > 0)) === null || _a === void 0 ? void 0 : _a.addedNodes[0];
      if (!addedFirstNode) {
        return;
      }
      const focusNode = toolbar.isNodeList({ node: addedFirstNode })
        ? addedFirstNode.firstChild
        : addedFirstNode;
      // Move cursor to new li. If empty we move to start because maybe it contains a br a last child.
      if (addedFirstNode.textContent.length === 0) {
        toolbar.g(focusNode);
        return;
      }
      toolbar.u(focusNode);
    });
    observer.observe(paragraph, { childList: true, subtree: true });
    // Previous sibling is a list so, we can move the li there
    if (li.previousSibling && toolbar.isNodeList({ node: li.previousSibling })) {
      li.previousSibling.appendChild(li);
      return;
    }
    // Clone li and append it to a new sublist, a new ul
    const newRange = new Range();
    newRange.selectNode(li);
    const contents = newRange.cloneContents();
    const newUl = document.createElement(paragraphListNodeName);
    newUl.append(contents);
    // Replace li with new ul
    ul.replaceChild(newUl, li);
  }
  findParentElement({ element, paragraph, nodeName }) {
    const { nodeName: elementNodeName, parentElement } = element;
    if (elementNodeName.toLowerCase() === nodeName) {
      return element;
    }
    // We iterated till the paragraph and even the paragraph is not the nodeName we are looking for
    if (toolbar.isParagraph({ element, container: containerStore.state.ref })) {
      return undefined;
    }
    return this.findParentElement({ element: parentElement, paragraph, nodeName });
  }
  findLastChild(element) {
    if (element.lastChild !== null) {
      return this.findLastChild(element.lastChild);
    }
    return element;
  }
}

class UndoRedoEvents {
  constructor() {
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.undoSelection = undefined;
    this.debounceUpdateInputs = d(() => this.stackUndoInputs(), 350);
    this.onKeydown = async ($event) => {
      const { key, ctrlKey, metaKey, shiftKey } = $event;
      if (isKeyboardEnter($event)) {
        this.stackUndoInputs();
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && !shiftKey) {
        await this.undo($event);
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && shiftKey) {
        await this.redo($event);
        return;
      }
      if (key === 'Backspace') {
        this.stackBackspace();
      }
    };
    this.onKeyup = () => {
      var _a;
      this.onEventUpdateParagraphs((_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode);
    };
    this.onSelectionChange = () => (this.undoSelection = toUndoRedoSelection(containerStore.state.ref));
    this.onToolbarActivated = () => {
      this.copySelectedParagraphs({ filterEmptySelection: true });
    };
    this.onMenuActivated = ({ detail }) => {
      const { paragraph } = detail;
      this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
    };
    this.onSnapshotParagraph = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMouseTouchDown = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMutation = (mutations) => {
      const addRemoveParagraphs = this.onParagraphsMutations(mutations);
      const updateParagraphs = this.onNodesParagraphsMutation(mutations);
      stackUndoParagraphs({
        container: containerStore.state.ref,
        addRemoveParagraphs: addRemoveParagraphs,
        updateParagraphs,
        selection: this.undoSelection
      });
      // We assume that all paragraphs updates do contain attributes and input changes
      if (updateParagraphs.length > 0) {
        return;
      }
      this.onAttributesMutation(mutations);
      this.onCharacterDataMutations(mutations);
    };
  }
  init() {
    var _a, _b, _c, _d, _e;
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.observer = new MutationObserver(this.onMutation);
    this.observe();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.addEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.addEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.addEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.addEventListener('selectionchange', this.onSelectionChange);
    document.addEventListener('toolbarActivated', this.onToolbarActivated);
    document.addEventListener('menuActivated', this.onMenuActivated);
    this.unsubscribe = undoRedoStore.onChange('observe', (observe) => {
      if (observe) {
        // We re-active the selection as if we would have selected a paragraphs because we might need to record next update
        this.copySelectedParagraphs({ filterEmptySelection: false });
        this.undoInputs = undefined;
        this.observe();
        return;
      }
      this.disconnect();
    });
  }
  destroy() {
    var _a, _b, _c, _d, _e, _f;
    this.disconnect();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.removeEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.removeEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.removeEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.removeEventListener('selectionchange', this.onSelectionChange);
    document.removeEventListener('toolbarActivated', this.onToolbarActivated);
    document.removeEventListener('menuActivated', this.onMenuActivated);
    (_f = this.unsubscribe) === null || _f === void 0 ? void 0 : _f.call(this);
  }
  async undo($event) {
    $event.preventDefault();
    if (nextUndoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: undo });
  }
  async redo($event) {
    $event.preventDefault();
    if (nextRedoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: redo });
  }
  stackUndoInputs() {
    this.copySelectedParagraphs({ filterEmptySelection: false });
    if (!this.undoInputs) {
      return;
    }
    stackUndoInput({
      data: this.undoInputs,
      container: containerStore.state.ref
    });
    this.undoInputs = undefined;
  }
  // When user hits backspace at the begin of a paragraph we should stack previous paragraph for update and current one because it will be removed
  stackBackspace() {
    var _a;
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    // Begin of paragraph?
    if (!(range.startOffset === 0 || zeroWidthSpace)) {
      return;
    }
    const anchorNode = (_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode;
    if (!anchorNode) {
      return;
    }
    const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({
      element: anchorNode,
      container: containerStore.state.ref
    }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([
      ...(paragraph.previousElementSibling
        ? [paragraph.previousElementSibling]
        : []),
      paragraph
    ]);
  }
  async undoRedo({ undoRedo }) {
    // We skip mutations when we process undo redo
    this.disconnect();
    await undoRedo();
    this.observe();
  }
  observe() {
    this.observer.observe(containerStore.state.ref, {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      subtree: true
    });
  }
  disconnect() {
    var _a;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onEventUpdateParagraphs(target) {
    if (!target) {
      return;
    }
    const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
  }
  // Copy current paragraphs value to a local state so we can add it to the undo redo global store in case of modifications
  copySelectedParagraphs({ filterEmptySelection }) {
    const paragraphs = findSelectionParagraphs({
      container: containerStore.state.ref,
      filterEmptySelection
    });
    if (!paragraphs) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs(paragraphs);
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: this.cleanOuterHTML(paragraph),
      index: toolbar.elementIndex(paragraph),
      paragraph
    }));
  }
  onCharacterDataMutations(mutations) {
    const characterMutations = mutations.filter(({ oldValue }) => oldValue !== null);
    // No character mutations
    if (characterMutations.length <= 0) {
      return;
    }
    if (!this.undoInputs) {
      this.undoInputs = characterMutations
        .map((mutation) => this.toUndoInput(mutation))
        .filter((undoInput) => undoInput !== undefined);
    }
    if (this.undoInputs.length <= 0) {
      this.undoInputs = undefined;
      return;
    }
    this.debounceUpdateInputs();
  }
  toUndoInput(mutation) {
    const target = mutation.target;
    const newValue = target.nodeValue;
    // Firefox triggers a character mutation that has same previous and new value when we delete a range in deleteContentBackward
    if (newValue === mutation.oldValue) {
      return undefined;
    }
    const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph || !target.parentNode) {
      return undefined;
    }
    // We find the list of node indexes of the parent of the modified text
    const depths = toolbar.nodeDepths({ target, paragraph });
    return {
      oldValue: mutation.oldValue,
      offset: toolbar.m({ target }) + (mutation.oldValue.length - newValue.length),
      index: toolbar.elementIndex(paragraph),
      indexDepths: depths
    };
  }
  /**
   * Paragraphs added and removed
   */
  onParagraphsMutations(mutations) {
    const changes = [];
    // New paragraph
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    addedParagraphs.forEach((paragraph) => changes.push({
      outerHTML: this.cleanOuterHTML(paragraph),
      mutation: 'add',
      index: paragraph.previousElementSibling
        ? toolbar.elementIndex(toolbar.toHTMLElement(paragraph.previousElementSibling)) + 1
        : 0
    }));
    // Sort descending because undo-redo will remove the items in that order with their index
    changes.sort(({ index: indexA }, { index: indexB }) => indexB - indexA);
    // Paragraphs removed
    const removedParagraphs = findRemovedParagraphs({
      mutations,
      container: containerStore.state.ref,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    const lowerIndex = Math.min(...removedParagraphs.map(({ previousSibling }) => previousSibling ? toolbar.elementIndex(toolbar.toHTMLElement(previousSibling)) + 1 : 0));
    removedParagraphs.forEach(({ paragraph }, index) => {
      const elementIndex = index + (Number.isFinite(lowerIndex) ? lowerIndex : 0);
      const undoParagraph = this.undoUpdateParagraphs.find(({ index }) => index === elementIndex);
      // cleanOuterHTML is only there as fallback, we should find the previous outerHTML value in undoUpdateParagraphs
      return changes.push({
        outerHTML: (undoParagraph === null || undoParagraph === void 0 ? void 0 : undoParagraph.outerHTML) || this.cleanOuterHTML(paragraph),
        mutation: 'remove',
        index: elementIndex
      });
    });
    return changes;
  }
  /**
   * Nodes within paragraphs added and removed.
   *
   * If we stack an update of the paragraph we shall not also stack an "input" update at the same time.
   *
   * @return did update
   */
  onNodesParagraphsMutation(mutations) {
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    const needsUpdate = addedNodesMutations.length > 0 || removedNodesMutations.length > 0;
    if (!needsUpdate) {
      return [];
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    // Check that the nodes of the paragraphs to update were not already been added to the undoRedo store in `onParagraphsMutations`
    const filterUndoUpdateParagraphs = this.undoUpdateParagraphs.filter(({ paragraph }) => paragraph.isConnected &&
      addedParagraphs.find((element) => element.isEqualNode(paragraph)) === undefined);
    if (filterUndoUpdateParagraphs.length <= 0) {
      this.copySelectedParagraphs({ filterEmptySelection: true });
      return [];
    }
    this.copySelectedParagraphs({ filterEmptySelection: true });
    this.undoInputs = undefined;
    return filterUndoUpdateParagraphs;
  }
  cleanOuterHTML(paragraph) {
    const clone = paragraph.cloneNode(true);
    clone.removeAttribute('placeholder');
    return clone.outerHTML;
  }
  onAttributesMutation(mutations) {
    const updateParagraphs = findUpdatedParagraphs({
      mutations: filterAttributesMutations({
        mutations,
        excludeAttributes: configStore.state.attributes.exclude
      }),
      container: containerStore.state.ref
    });
    if (updateParagraphs.length <= 0) {
      return;
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return;
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: this.undoUpdateParagraphs,
      selection: this.undoSelection
    });
    this.undoUpdateParagraphs = this.toUpdateParagraphs(updateParagraphs);
  }
}

const injectCSS = ({ rootNode }) => {
  let style = (rootNode === document ? document.head : rootNode).querySelector('style[stylo-editor]');
  if (style !== null) {
    return;
  }
  style = document.createElement('style');
  style.setAttribute('stylo-editor', '');
  style.innerHTML = `
    .stylo-container > * {
      white-space: pre-wrap;
      position: relative;
    }

    .stylo-container > *:after {
      content: attr(placeholder);
      color: var(--stylo-placeholder-color, rgba(55, 53, 47, 0.5));
      position: absolute;
      top: 0;
    }
  `;
  if (rootNode === document) {
    document.head.append(style);
    return;
  }
  rootNode.prepend(style);
};

const editorCss = ":host{display:block}";

const Editor = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.debounceSize = d(() => this.applySize(), 250);
    this.undoRedoEvents = new UndoRedoEvents();
    this.enterEvents = new EnterEvents();
    this.placeHolderEvents = new PlaceholderEvents();
    this.inputEvents = new InputEvents();
    this.tabEvents = new TabEvents();
    this.dataEvents = new DataEvents();
    this.pasteEvents = new PasteEvents();
    this.mobile = isMobile();
    this.config = undefined;
    this.containerRef = undefined;
    this.contentEditable = true;
  }
  componentWillLoad() {
    this.init();
    this.applyConfig();
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', this.debounceSize);
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', this.debounceSize);
    this.destroy();
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onContainerRefChange() {
    this.destroy();
    this.init();
  }
  onConfigChange() {
    this.destroy();
    this.applyConfig();
    this.initEvents();
  }
  applySize() {
    var _a;
    if (this.mobile) {
      return;
    }
    containerStore.state.size = (_a = this.containerRef) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  }
  init() {
    containerStore.state.ref = this.containerRef;
    if (!this.containerRef) {
      return;
    }
    injectCSS({ rootNode: this.containerRef.getRootNode() });
    containerStore.state.ref.classList.add('stylo-container');
    this.containerRefEditable();
    this.applySize();
    this.initEvents();
  }
  /**
   * Observe and init containerref "contenteditable" state. Notably useful in case consumer toggles such state.
   */
  containerRefEditable() {
    var _a;
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.attributesObserver = new MutationObserver((mutations) => {
      const contentEditableChanged = mutations.find(({ attributeName }) => ['contenteditable'].includes(attributeName.toLowerCase()));
      if (!contentEditableChanged) {
        return;
      }
      this.contentEditable = this.isContentEditable();
      if (this.contentEditable) {
        this.initEvents();
        return;
      }
      this.destroy();
    });
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true });
    this.contentEditable = this.isContentEditable();
  }
  isContentEditable() {
    return ['true', ''].includes(this.containerRef.getAttribute('contenteditable'));
  }
  applyConfig() {
    var _a, _b;
    if (!this.config) {
      return;
    }
    const { plugins, toolbar, i18n: customI18n, placeholders, textParagraphs, menus, attributes } = this.config;
    i18n.state.custom = customI18n === null || customI18n === void 0 ? void 0 : customI18n.custom;
    i18n.state.lang = (customI18n === null || customI18n === void 0 ? void 0 : customI18n.lang) || 'en';
    configStore.state.plugins = plugins || DEFAULT_PLUGINS;
    configStore.state.toolbar = toolbar
      ? Object.assign(Object.assign({}, configStore.state.toolbar), toolbar) : DEFAULT_TOOLBAR;
    configStore.state.placeholders = placeholders || DEFAULT_PLACEHOLDERS;
    configStore.state.textParagraphs = textParagraphs || DEFAULT_TEXT_PARAGRAPHS;
    configStore.state.menus = menus;
    const paragraphIdentifier = (_a = attributes === null || attributes === void 0 ? void 0 : attributes.paragraphIdentifier) !== null && _a !== void 0 ? _a : DEFAULT_PARAGRAPH_IDENTIFIER;
    configStore.state.attributes = {
      paragraphIdentifier,
      exclude: [
        ...new Set([
          ...((_b = attributes === null || attributes === void 0 ? void 0 : attributes.exclude) !== null && _b !== void 0 ? _b : []),
          ...DEFAULT_EXCLUDE_ATTRIBUTES,
          paragraphIdentifier
        ])
      ]
    };
  }
  destroy() {
    this.undoRedoEvents.destroy();
    this.inputEvents.destroy();
    this.enterEvents.destroy();
    this.placeHolderEvents.destroy();
    this.tabEvents.destroy();
    this.dataEvents.destroy();
    this.pasteEvents.destroy();
    undoRedoStore.state.undo = [];
    undoRedoStore.state.redo = [];
  }
  initEvents() {
    if (!this.contentEditable) {
      return;
    }
    this.inputEvents.init();
    this.enterEvents.init();
    this.placeHolderEvents.init({ editorRef: this.el });
    this.tabEvents.init();
    this.dataEvents.init({ editorRef: this.el });
    this.undoRedoEvents.init();
    this.pasteEvents.init();
  }
  render() {
    var _a;
    if (!this.contentEditable) {
      return undefined;
    }
    return (index.h(index.Fragment, null, index.h("stylo-add", null), index.h("stylo-plugins", null), this.renderToolbar(), ((_a = configStore.state.menus) === null || _a === void 0 ? void 0 : _a.length) && index.h("stylo-menus", null)));
  }
  renderToolbar() {
    if (this.mobile) {
      return undefined;
    }
    return index.h("stylo-toolbar", { containerRef: this.containerRef });
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "containerRef": ["onContainerRefChange"],
    "config": ["onConfigChange"]
  }; }
};
Editor.style = editorCss;

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Aformat_quote%3A
const IconBlockquote = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
  index.h("path", { d: "M18.62 18h-5.24l2-4H13V6h8v7.24L18.62 18zm-2-2h.76L19 12.76V8h-4v4h3.62l-2 4zm-8 2H3.38l2-4H3V6h8v7.24L8.62 18zm-2-2h.76L9 12.76V8H5v4h3.62l-2 4z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Acode%3A
const IconCode = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
  index.h("path", { d: "M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Amore_horiz%3A
const IconEllipsisHorizontal = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Aimage%3A
const IconImage = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
  index.h("path", { d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Aformat_list_numbered%3A
const IconOl = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Aformat_list_bulleted%3A
const IconUl = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
  index.h("path", { d: "M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z" })));

const renderIcon = (icon) => {
  switch (icon) {
    case 'code':
      return index.h(IconCode, null);
    case 'ul':
      return index.h(IconUl, null);
    case 'ol':
      return index.h(IconOl, null);
    case 'hr':
      return index.h(IconEllipsisHorizontal, null);
    case 'img':
      return index.h(IconImage, null);
    case 'blockquote':
      return index.h(IconBlockquote, null);
    default:
      return undefined;
  }
};

const listCss$1 = ":host{display:flex;flex-direction:column;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff;--background-active:var(--stylo-list-background-active, var(--light));--border-active:var(--stylo-list-border-active, 1px solid var(--background-active));--color-active:var(--stylo-list-color-active, var(--light-contrast))}button{display:flex;position:relative;isolation:isolate;overflow:hidden;background:transparent;border:none;outline:none;cursor:pointer;transition:color 0.25s ease-out, background 0.25s ease-out, transform 0.15s ease-out;justify-content:flex-start;align-items:center;font-size:1rem;color:var(--stylo-toolbar-button-color, black);white-space:pre}button:active{box-shadow:none;transform:translateX(1px) translateY(1px)}button:hover,button:focus{background:var(--background-active);color:var(--color-active)}svg,span.placeholder{width:1.4rem;height:1.4rem;border:var(--border-active);border-radius:var(--stylo-border, 4px);margin:4px 12px 4px 8px;background:var(--white)}svg{padding:8px}span.placeholder{padding:10px 8px 6px;font-size:0.8rem;font-weight:700}span.placeholder::first-letter{font-size:125%}div.icon{display:flex}.empty{padding:10px 16px 6px}.empty strong{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block}";

const List = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.applyPlugin = index.createEvent(this, "applyPlugin", 7);
    this.cancelPlugins = index.createEvent(this, "cancelPlugins", 7);
    this.filter = '';
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (['Enter'].includes(code)) {
        return;
      }
      $event.preventDefault();
      if (['Escape'].includes(code)) {
        this.cancelPlugins.emit();
        return;
      }
      if (['ArrowDown'].includes(code)) {
        this.focusNext();
        return;
      }
      if (['ArrowUp'].includes(code)) {
        this.focusPrevious();
        return;
      }
      this.filterPlugins($event);
    };
    this.display = false;
    this.plugins = undefined;
  }
  componentWillLoad() {
    this.plugins = [...configStore.state.plugins];
  }
  componentDidUpdate() {
    this.focusOnUpdate();
  }
  focusOnUpdate() {
    // If only one plugin button is displayed, focus it
    const buttons = this.el.shadowRoot.querySelectorAll('button');
    if (buttons.length === 1) {
      buttons[0].focus();
    }
  }
  emitPlugin($event, plugin) {
    $event.stopPropagation();
    this.applyPlugin.emit(plugin);
  }
  onDisplay() {
    if (this.display) {
      document.addEventListener('keydown', this.onKeyDown);
      return;
    }
    document.removeEventListener('keydown', this.onKeyDown, false);
    this.reset();
  }
  reset() {
    this.filter = '';
    this.plugins = [...configStore.state.plugins];
  }
  async focusFirstButton() {
    var _a;
    this.focusButton = this.el.shadowRoot.querySelector('button');
    (_a = this.focusButton) === null || _a === void 0 ? void 0 : _a.focus();
  }
  focusNext() {
    var _a, _b;
    this.focusButton = toolbar.toHTMLElement((_a = (this.focusButton || this.el.shadowRoot.firstElementChild)) === null || _a === void 0 ? void 0 : _a.nextElementSibling);
    (_b = this.focusButton) === null || _b === void 0 ? void 0 : _b.focus();
  }
  focusPrevious() {
    var _a, _b;
    this.focusButton = toolbar.toHTMLElement((_a = (this.focusButton || this.el.shadowRoot.lastElementChild)) === null || _a === void 0 ? void 0 : _a.previousElementSibling);
    (_b = this.focusButton) === null || _b === void 0 ? void 0 : _b.focus();
  }
  filterPlugins($event) {
    const { code, metaKey, ctrlKey, key } = $event;
    if (metaKey || ctrlKey) {
      return;
    }
    // For example Space or ArrowUp
    if (key.length > 1 && !['Backspace'].includes(code)) {
      return;
    }
    this.filter =
      code === 'Backspace'
        ? this.filter.length > 0
          ? this.filter.slice(0, -1)
          : this.filter
        : `${this.filter}${key}`;
    this.plugins = [...configStore.state.plugins].filter(({ text }) => {
      var _a, _b;
      const label = (_b = (_a = i18n.state.plugins[text]) !== null && _a !== void 0 ? _a : i18n.state.custom[text]) !== null && _b !== void 0 ? _b : text;
      return label.toLowerCase().indexOf(this.filter.toLowerCase()) > -1;
    });
  }
  render() {
    return (index.h(index.Fragment, null, this.plugins.map((plugin, i) => this.renderPlugin(plugin, `plugin-${i}`)), this.renderEmpty()));
  }
  renderEmpty() {
    if (this.plugins.length > 0) {
      return undefined;
    }
    return (index.h("span", { class: "empty" }, i18n.state.plugins.no_matches, ": ", index.h("strong", null, this.filter)));
  }
  renderPlugin(plugin, key) {
    const { text, icon: iconSrc } = plugin;
    const icon = renderIcon(iconSrc);
    return (index.h("button", { key: key, onClick: ($event) => this.emitPlugin($event, plugin) }, icon === undefined && (index.h("div", Object.assign({ class: "icon" }, (icon === undefined && { innerHTML: iconSrc })))), icon, this.renderText(text)));
  }
  renderText(text) {
    var _a, _b, _c, _d, _e;
    const textValue = (_b = (_a = i18n.state.plugins[text]) !== null && _a !== void 0 ? _a : i18n.state.custom[text]) !== null && _b !== void 0 ? _b : text;
    if (this.filter.length > 0) {
      const rgxSplit = new RegExp(this.filter + '(.*)', 'gi');
      const split = textValue.split(rgxSplit);
      const rgxFilter = new RegExp(this.filter, 'gi');
      const filter = textValue.match(rgxFilter);
      return (index.h(index.Fragment, null, (_c = split[0]) !== null && _c !== void 0 ? _c : '', index.h("strong", null, (_d = filter[0]) !== null && _d !== void 0 ? _d : ''), (_e = split[1]) !== null && _e !== void 0 ? _e : ''));
    }
    return textValue;
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "display": ["onDisplay"]
  }; }
};
List.style = listCss$1;

const menusCss = ":host{display:flex;justify-content:center;align-items:center;position:absolute;top:var(--menu-top);left:50%;transform:translate(-50%, calc(-100% - 16px));--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff;--box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.12);box-shadow:var(--stylo-box-shadow, var(--box-shadow));border:var(--stylo-border);background:var(--stylo-background, var(--white));color:var(--stylo-color, var(--white-contrast));border-radius:var(--stylo-border, 4px);padding:var(--stylo-toolbar-padding, 0 8px);z-index:var(--stylo-toolbar-zindex, 1)}div.icon{display:flex;flex-direction:column}";

const Menus = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.menuActivated = index.createEvent(this, "menuActivated", 7);
    this.onKeyDown = () => {
      this.hide();
    };
    this.top = undefined;
    this.menu = undefined;
  }
  componentDidLoad() {
    this.destroyListener = containerStore.onChange('ref', () => {
      this.removeContainerListener();
      this.addContainerListener();
    });
    this.addContainerListener();
  }
  disconnectedCallback() {
    var _a;
    this.removeContainerListener();
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  addContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown, { passive: true });
  }
  removeContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  onResize() {
    this.hide();
  }
  onClick({ target }) {
    var _a, _b;
    const paragraph = toolbar.findParagraph({
      element: target,
      container: containerStore.state.ref
    });
    this.paragraph = toolbar.toHTMLElement(paragraph);
    if (!this.paragraph) {
      this.hide();
      return;
    }
    this.menuActivated.emit({ paragraph: this.paragraph });
    this.menu = (_a = configStore.state.menus) === null || _a === void 0 ? void 0 : _a.find(({ match }) => match({ paragraph: this.paragraph }));
    this.top = this.menu && ((_b = this.paragraph) === null || _b === void 0 ? void 0 : _b.offsetTop);
  }
  async selectMenuAction({ action }) {
    if (!this.paragraph) {
      this.hide();
      return;
    }
    await action({ paragraph: this.paragraph });
    this.hide();
  }
  hide() {
    this.paragraph = undefined;
    this.menu = undefined;
    this.top = undefined;
  }
  render() {
    const style = this.top === undefined ? { display: 'none' } : { '--menu-top': `${this.top}px` };
    return (index.h(index.Host, { style: style }, this.renderMenu(), index.h("stylo-toolbar-triangle", { style: {
        '--stylo-toolbar-triangle-start': `50%`
      } })));
  }
  renderMenu() {
    var _a;
    return (_a = this.menu) === null || _a === void 0 ? void 0 : _a.actions.map((action) => this.renderAction(action));
  }
  renderAction(action) {
    var _a, _b;
    const { icon: iconSrc, text } = action;
    const icon = renderIcon(iconSrc);
    return (index.h("stylo-toolbar-button", { onAction: async () => await this.selectMenuAction(action), label: (_b = (_a = i18n.state.menus[text]) !== null && _a !== void 0 ? _a : i18n.state.custom[text]) !== null && _b !== void 0 ? _b : text }, icon ? icon : index.h("div", { class: "icon", innerHTML: iconSrc })));
  }
};
Menus.style = menusCss;

const pluginsCss = ":host{display:flex;flex-direction:column;position:absolute;top:var(--actions-top);left:var(--actions-left);transform:translate(0, var(--actions-translate-y)) scale(0.95);opacity:0;margin:2px 0;width:220px;max-height:220px;overflow:auto;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff;background:var(--stylo-background, var(--white));color:var(--stylo-color, var(--white-contrast));border-radius:var(--stylo-border, 4px);--box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.12);box-shadow:var(--stylo-box-shadow, var(--box-shadow));border:var(--stylo-border);pointer-events:none;transition-property:opacity, transform;transition-duration:0.15s, 0.15s;transition-timing-function:cubic-bezier(0.175, 0.885, 0.32, 1.275), cubic-bezier(0.175, 0.885, 0.32, 1.275)}:host(.display){opacity:1;transform:translate(0, var(--actions-translate-y)) scale(1);pointer-events:all}input{visibility:hidden;opacity:0}";

const Plugins = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.display = false;
    this.position = undefined;
  }
  componentWillLoad() {
    this.destroyListener = containerStore.onChange('size', () => {
      if (isMobile()) {
        return;
      }
      this.hide();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  /**
   * If user click anywhere not in the stylo-editor, hide the transform options
   */
  onClick(_$event) {
    this.hide();
  }
  onHidePlugins() {
    this.hide();
  }
  hide() {
    this.display = false;
    // To make the visual transition not glitchy, we hide first and then move the component outside
    setTimeout(() => (this.position = undefined), 150);
  }
  onListPlugins({ detail: paragraph }) {
    if (!paragraph) {
      this.hide();
      return;
    }
    const { height, top } = paragraph.getBoundingClientRect();
    // top + size + margin
    const downward = top + 220 + 16 < (window.innerHeight || screen.height);
    this.position = {
      top: paragraph.offsetTop + (downward ? height : -1 * height),
      left: paragraph.offsetLeft,
      downward
    };
    this.paragraph = paragraph;
    this.displayAndFocus();
  }
  displayAndFocus() {
    const onRender = async (_mutations, observer) => {
      var _a;
      if (this.el.style.visibility !== 'visible') {
        return;
      }
      observer.disconnect();
      await ((_a = this.el.shadowRoot.querySelector('stylo-list')) === null || _a === void 0 ? void 0 : _a.focusFirstButton());
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(this.el, { attributes: true, subtree: true });
    setTimeout(() => (this.display = true), 150);
  }
  onCancelPlugins() {
    this.hide();
    toolbar.focusParagraph({ paragraph: this.paragraph });
  }
  async onApplyPlugin(plugin) {
    if (!containerStore.state.ref || !this.paragraph) {
      return;
    }
    this.hide();
    const { files } = plugin;
    if (files !== undefined) {
      this.openFilePicker(plugin);
      return;
    }
    await this.transformParagraph({ plugin });
  }
  async transformParagraph({ plugin, files }) {
    const { createParagraphs } = plugin;
    await createParagraphs({
      paragraph: toolbar.toHTMLElement(this.paragraph),
      container: containerStore.state.ref,
      files
    });
  }
  openFilePicker(plugin) {
    const input = this.filePicker(plugin);
    input === null || input === void 0 ? void 0 : input.click();
  }
  async onFilePickerChange(plugin) {
    const input = this.filePicker(plugin);
    if (!input || input.files.length <= 0) {
      return;
    }
    await this.transformParagraph({ plugin, files: input.files });
    // Reset input otherwise a new data cannot be selected
    input.value = '';
  }
  filePicker({ files }) {
    const { accept } = files;
    return this.el.shadowRoot.querySelector(`input[accept="${accept}"]`);
  }
  render() {
    const style = Object.assign(Object.assign({ visibility: this.display ? 'visible' : 'hidden' }, (!this.display && { height: '0px' })), (this.position === undefined
      ? {}
      : {
        '--actions-top': `${this.position.top}px`,
        '--actions-left': `${this.position.left}px`,
        '--actions-translate-y': `${this.position.downward ? '0' : '-100%'}`
      }));
    return (index.h(index.Host, { style: style, class: `${this.display ? 'display' : 'hidden'}` }, this.renderList(), this.renderInputs()));
  }
  renderInputs() {
    return configStore.state.plugins
      .filter(({ files }) => files !== undefined)
      .map((plugin) => {
      const { accept, multiple } = plugin.files;
      return (index.h("input", { type: "file", accept: accept, multiple: multiple, onChange: async () => await this.onFilePickerChange(plugin) }));
    });
  }
  renderList() {
    return (index.h("stylo-list", { onApplyPlugin: async ({ detail }) => await this.onApplyPlugin(detail), onCancelPlugins: () => this.onCancelPlugins(), display: this.display }));
  }
  get el() { return index.getElement(this); }
};
Plugins.style = pluginsCss;

const actionBold = {
  cmd: 'style',
  detail: {
    style: 'font-weight',
    value: 'bold',
    initial: (element) => element && element.style['font-weight'] === 'bold'
  }
};
const actionItalic = {
  cmd: 'style',
  detail: {
    style: 'font-style',
    value: 'italic',
    initial: (element) => element && element.style['font-style'] === 'italic'
  }
};
const actionUnderline = {
  cmd: 'style',
  detail: {
    style: 'text-decoration',
    value: 'underline',
    initial: (element) => element && element.style['text-decoration'] === 'underline'
  }
};
const actionStrikeThrough = {
  cmd: 'style',
  detail: {
    style: 'text-decoration',
    value: 'line-through',
    initial: (element) => element && element.style['text-decoration'] === 'line-through'
  }
};

function execCommandList(selection, action, container) {
  const anchorNode = selection.anchorNode;
  if (!anchorNode) {
    return;
  }
  const anchor = toolbar.toHTMLElement(toolbar.findParagraph({ element: anchorNode, container }));
  if (!anchor) {
    return;
  }
  // Did the user select the all list
  if (anchor.nodeName.toLowerCase() === action.type) {
    removeList(anchor);
    return;
  }
  if (!['ol', 'ul', 'dl'].includes(anchor.nodeName.toLowerCase())) {
    createList(anchor, selection, action.type);
    return;
  }
  // Create a brand new list
  cloneList(anchor, selection, action.type);
  removeList(anchor, false);
}
function createList(container, selection, type) {
  const range = selection.getRangeAt(0);
  const fragment = range.extractContents();
  const list = document.createElement(type);
  const li = document.createElement('li');
  li.style.cssText = container.style.cssText;
  li.appendChild(fragment);
  list.appendChild(li);
  range.insertNode(list);
  selection.selectAllChildren(list);
}
function cloneList(container, selection, type) {
  const list = document.createElement(type);
  list.append(...Array.from(container.childNodes));
  Array.from(container.attributes).forEach((attr) => list.setAttribute(attr.nodeName, attr.nodeValue));
  container.parentElement.insertBefore(list, container);
  selection.selectAllChildren(list);
}
function removeList(list, preserveChildren = true) {
  if (list.hasChildNodes() && preserveChildren) {
    Array.from(list.childNodes).forEach((child) => {
      if (child.hasChildNodes() &&
        child.childNodes.length > 1 &&
        child.firstChild.nodeType !== Node.TEXT_NODE &&
        child.firstChild.nodeType !== Node.COMMENT_NODE) {
        const span = document.createElement('span');
        span.append(...Array.from(child.childNodes));
        list.parentElement.insertBefore(span, list);
      }
      else {
        const text = document.createTextNode(child.textContent);
        list.parentElement.insertBefore(text, list);
      }
    });
  }
  list.parentElement.removeChild(list);
}

const findStyleNode = (node, style, container) => {
  // Just in case
  if (node.nodeName.toUpperCase() === 'HTML' || node.nodeName.toUpperCase() === 'BODY') {
    return null;
  }
  if (!node.parentNode) {
    return null;
  }
  if (toolbar.isParagraph({ element: node, container })) {
    return null;
  }
  const { style: elementStyle } = toolbar.toHTMLElement(node);
  const hasStyle = elementStyle[style] !== null && elementStyle[style] !== undefined && elementStyle[style] !== '';
  if (hasStyle) {
    return node;
  }
  return findStyleNode(node.parentNode, style, container);
};
const getBold = (element) => {
  if (isTag(element, 'b')) {
    return 'bold';
  }
  if (isTag(element, 'strong')) {
    return 'bold';
  }
  return element.style.fontWeight === 'bold'
    ? 'bold'
    : element.style.fontWeight === 'initial'
      ? 'initial'
      : undefined;
};
const getFontSize = (element) => {
  if (!element) {
    return undefined;
  }
  if (element.hasAttribute('size')) {
    return element.getAttribute('size');
  }
  return element.style.fontSize !== ''
    ? toolbar.ToolbarFontSize[element.style.fontSize.replace('-', '_').toUpperCase()]
    : undefined;
};
const getContentAlignment = (element) => {
  const style = window.getComputedStyle(element);
  if (style.textAlign === 'center') {
    return toolbar.ToolbarAlign.CENTER;
  }
  else if (style.textAlign === 'right') {
    return toolbar.ToolbarAlign.RIGHT;
  }
  else if (style.textAlign === 'left') {
    return toolbar.ToolbarAlign.LEFT;
  }
  return p() ? toolbar.ToolbarAlign.RIGHT : toolbar.ToolbarAlign.LEFT;
};
const getList = (element) => {
  if (!element) {
    return undefined;
  }
  if (element.nodeName &&
    element.nodeName.toLowerCase() === 'li' &&
    element.parentElement &&
    element.parentElement.nodeName) {
    return element.parentElement.nodeName.toLowerCase() === 'ol'
      ? toolbar.ToolbarList.ORDERED
      : element.parentElement.nodeName.toLowerCase() === 'ul'
        ? toolbar.ToolbarList.UNORDERED
        : undefined;
  }
  return undefined;
};
const getStrikeThrough = (element) => {
  var _a, _b, _c, _d, _e;
  if (isTag(element, 'strike')) {
    return 'strikethrough';
  }
  if (((_a = element.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('line-through')) > -1 ||
    ((_b = element.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('line-through')) > -1) {
    return 'strikethrough';
  }
  if (((_c = element.style.textDecoration) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1 ||
    ((_d = element.style.textDecorationLine) === null || _d === void 0 ? void 0 : _d.indexOf('initial')) > -1) {
    return 'initial';
  }
  if (!element.hasChildNodes()) {
    return undefined;
  }
  const children = element.children;
  if (children && children.length > 0) {
    const selectedChild = Array.from(children).find((child) => {
      var _a, _b, _c;
      return (((_a = child.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('line-through')) > -1 ||
        ((_b = child.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('line-through')) > -1 ||
        ((_c = child.style.textDecorationLine) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1);
    });
    if (selectedChild) {
      return ((_e = selectedChild.style.fontStyle) === null || _e === void 0 ? void 0 : _e.indexOf('line-through')) > -1
        ? 'strikethrough'
        : 'initial';
    }
  }
  return undefined;
};
const getUnderline = (element) => {
  var _a, _b, _c, _d, _e;
  if (isTag(element, 'u')) {
    return 'underline';
  }
  if (((_a = element.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('underline')) > -1 ||
    ((_b = element.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('underline')) > -1) {
    return 'underline';
  }
  if (((_c = element.style.textDecoration) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1 ||
    ((_d = element.style.textDecorationLine) === null || _d === void 0 ? void 0 : _d.indexOf('initial')) > -1) {
    return 'initial';
  }
  if (!element.hasChildNodes()) {
    return undefined;
  }
  const children = element.children;
  if (children && children.length > 0) {
    const selectedChild = Array.from(children).find((child) => {
      var _a, _b, _c;
      return (((_a = child.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('underline')) > -1 ||
        ((_b = child.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('underline')) > -1 ||
        ((_c = child.style.textDecorationLine) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1);
    });
    if (selectedChild) {
      return ((_e = selectedChild.style.fontStyle) === null || _e === void 0 ? void 0 : _e.indexOf('underline')) > -1 ? 'underline' : 'initial';
    }
  }
  return undefined;
};
const getItalic = (element) => {
  if (isTag(element, 'i')) {
    return 'italic';
  }
  if (isTag(element, 'em')) {
    return 'italic';
  }
  if (element.style.fontStyle === 'italic') {
    return 'italic';
  }
  if (element.style.fontStyle === 'initial') {
    return 'initial';
  }
  if (!element.hasChildNodes()) {
    return undefined;
  }
  const children = element.children;
  if (children && children.length > 0) {
    const selectedChild = Array.from(children).find((child) => {
      return child.style.fontStyle === 'italic' || child.style.fontStyle === 'initial';
    });
    if (selectedChild) {
      return selectedChild.style.fontStyle === 'italic' ? 'italic' : 'initial';
    }
  }
  return undefined;
};
const isTag = (element, tagName) => {
  if (!element) {
    return false;
  }
  if (element.nodeName.toLowerCase() === tagName) {
    return true;
  }
  if (element.hasChildNodes()) {
    const children = element.getElementsByTagName(tagName);
    return children && children.length > 0;
  }
  return false;
};

function execCommandStyle(selection, action, container) {
  const anchor = toolbar.a(selection);
  if (!anchor) {
    return;
  }
  const sameSelection = anchor && anchor.innerText === selection.toString();
  if (sameSelection &&
    !toolbar.isParagraph({ element: anchor, container }) &&
    anchor.style[action.style] !== undefined) {
    updateSelection(anchor, action, container);
    return;
  }
  replaceSelection(anchor, action, selection, container);
}
function updateSelection(anchor, action, container) {
  anchor.style[action.style] = getStyleValue(container, action, container);
  cleanChildren(action, anchor);
}
function replaceSelection(anchor, action, selection, container) {
  const range = selection.getRangeAt(0);
  // User selected a all list?
  if (range.commonAncestorContainer &&
    ['ol', 'ul', 'dl'].some((listType) => listType === range.commonAncestorContainer.nodeName.toLowerCase())) {
    updateSelection(range.commonAncestorContainer, action, container);
    return;
  }
  const fragment = range.extractContents();
  const span = createSpan(anchor, action, container);
  span.appendChild(fragment);
  cleanChildren(action, span);
  flattenChildren(action, span);
  range.insertNode(span);
  selection.selectAllChildren(span);
}
function cleanChildren(action, span) {
  if (!span.hasChildNodes()) {
    return;
  }
  // Clean direct (> *) children with same style
  const children = Array.from(span.children).filter((element) => {
    return element.style[action.style] !== undefined && element.style[action.style] !== '';
  });
  if (children && children.length > 0) {
    children.forEach((element) => {
      element.style[action.style] = '';
      if (element.getAttribute('style') === '' || element.style === null) {
        element.removeAttribute('style');
      }
    });
  }
  // Direct children (> *) may have children (*) which need to be cleaned too
  Array.from(span.children).forEach((element) => cleanChildren(action, element));
}
function createSpan(anchor, action, container) {
  const span = document.createElement('span');
  span.style[action.style] = getStyleValue(anchor, action, container);
  return span;
}
// We assume that if the same style is applied, user want actually to remove it (same behavior as in MS Word)
// Note: initial may have no effect on the background-color
function getStyleValue(anchor, action, container) {
  if (!anchor) {
    return action.value;
  }
  if (action.initial(anchor)) {
    return 'initial';
  }
  const style = findStyleNode(anchor, action.style, container);
  if (action.initial(style)) {
    return 'initial';
  }
  return action.value;
}
// We try to not keep <span/> in the tree if we can use text
function flattenChildren(action, span) {
  if (!span.hasChildNodes()) {
    return;
  }
  // Flatten direct (> *) children with no style
  const children = Array.from(span.children).filter((element) => {
    const style = element.getAttribute('style');
    return !style || style === '';
  });
  if (children && children.length > 0) {
    children.forEach((element) => {
      // Can only be flattened if there is no other style applied to a children, like a color to part of a text with a background
      const styledChildren = element.querySelectorAll('[style]');
      if (!styledChildren || styledChildren.length === 0) {
        const text = document.createTextNode(element.textContent);
        element.parentElement.replaceChild(text, element);
      }
    });
    return;
  }
  // Direct children (> *) may have children (*) which need to be flattened too
  Array.from(span.children).forEach((element) => flattenChildren(action, element));
}

function execCommand(selection, action, container) {
  if (!document || !selection) {
    return;
  }
  if (action.cmd === 'style') {
    execCommandStyle(selection, action.detail, container);
  }
  else if (action.cmd === 'list') {
    execCommandList(selection, action.detail, container);
  }
}

const execCommandNative = (action) => {
  if (action.cmd === 'style') {
    execCommandNativeStyle(action);
  }
  else if (action.cmd === 'list') {
    execCommandNativeList(action);
  }
};
const execCommandNativeStyle = (action) => {
  const detail = action.detail;
  // @ts-ignore
  document.execCommand('styleWithCSS', false, true);
  switch (detail.style) {
    case 'color':
      document.execCommand('foreColor', false, detail.value);
      break;
    case 'background-color':
      document.execCommand('backColor', false, detail.value);
      break;
    case 'font-size':
      document.execCommand('fontSize', false, toolbar.ToolbarFontSize[detail.value.replace('-', '_').toUpperCase()]);
      break;
    case 'font-weight':
      document.execCommand('bold', false, null);
      break;
    case 'font-style':
      document.execCommand('italic', false, null);
      break;
    case 'text-decoration':
      document.execCommand(detail.value === 'line-through' ? 'strikeThrough' : 'underline', false, null);
      break;
  }
};
const execCommandNativeList = (action) => {
  const detail = action.detail;
  switch (detail.type) {
    case 'ol':
      document.execCommand('insertOrderedList', false, null);
      break;
    case 'ul':
      document.execCommand('insertUnorderedList', false, null);
      break;
  }
};
const execCommandNativeAlign = (align) => {
  switch (align) {
    case toolbar.ToolbarAlign.CENTER:
      document.execCommand('justifyCenter', false, null);
      break;
    case toolbar.ToolbarAlign.RIGHT:
      document.execCommand('justifyRight', false, null);
      break;
    default:
      document.execCommand('justifyLeft', false, null);
  }
};

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Aformat_align_center%3A
const IconAlignCenter = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Aformat_align_left%3A
const IconAlignLeft = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Aformat_align_right%3A
const IconAlignRight = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Aformat_color_fill%3A
const IconColor = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", "enable-background": "new 0 0 24 24", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("g", null,
    index.h("rect", { fill: "none", height: "24", width: "24" })),
  index.h("g", null,
    index.h("path", { d: "M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z" }))));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Alink%3A
const IconLink = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  index.h("path", { d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Apalette%3A
const IconPalette = () => (index.h("svg", { xmlns: "http://www.w3.org/2000/svg", "enable-background": "new 0 0 24 24", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  index.h("g", null,
    index.h("rect", { fill: "none", height: "24", width: "24" })),
  index.h("g", null,
    index.h("g", null,
      index.h("g", null,
        index.h("g", null,
          index.h("path", { d: "M12,22C6.49,22,2,17.51,2,12S6.49,2,12,2s10,4.04,10,9c0,3.31-2.69,6-6,6h-1.77c-0.28,0-0.5,0.22-0.5,0.5 c0,0.12,0.05,0.23,0.13,0.33c0.41,0.47,0.64,1.06,0.64,1.67C14.5,20.88,13.38,22,12,22z M12,4c-4.41,0-8,3.59-8,8s3.59,8,8,8 c0.28,0,0.5-0.22,0.5-0.5c0-0.16-0.08-0.28-0.14-0.35c-0.41-0.46-0.63-1.05-0.63-1.65c0-1.38,1.12-2.5,2.5-2.5H16 c2.21,0,4-1.79,4-4C20,7.14,16.41,4,12,4z" }),
          index.h("circle", { cx: "6.5", cy: "11.5", r: "1.5" }),
          index.h("circle", { cx: "9.5", cy: "7.5", r: "1.5" }),
          index.h("circle", { cx: "14.5", cy: "7.5", r: "1.5" }),
          index.h("circle", { cx: "17.5", cy: "11.5", r: "1.5" })))))));

const Style = ({ align, list, switchToolbarActions, disabledTitle, bold, italic, strikethrough, underline, link, onExecCommand, toggleLink }) => {
  const renderSeparator = () => index.h("stylo-toolbar-separator", null);
  const renderLinkSeparator = () => {
    if (!list && !align) {
      return undefined;
    }
    return renderSeparator();
  };
  const renderListAction = () => {
    return (index.h("stylo-toolbar-button", { onAction: () => switchToolbarActions(toolbar.ToolbarActions.LIST), label: i18n.state.toolbar.style_list }, list === toolbar.ToolbarList.UNORDERED ? index.h(IconUl, null) : index.h(IconOl, null)));
  };
  const renderAlignAction = () => {
    if (!configStore.state.toolbar.style.align) {
      return undefined;
    }
    return (index.h("stylo-toolbar-button", { onAction: () => switchToolbarActions(toolbar.ToolbarActions.ALIGNMENT), label: i18n.state.toolbar.style_align }, align === toolbar.ToolbarAlign.LEFT ? (index.h(IconAlignLeft, null)) : align === toolbar.ToolbarAlign.CENTER ? (index.h(IconAlignCenter, null)) : (index.h(IconAlignRight, null))));
  };
  const renderFontSizeAction = () => {
    if (!configStore.state.toolbar.style.fontSize) {
      return undefined;
    }
    return (index.h(index.Fragment, null,
      index.h("stylo-toolbar-button", { onAction: () => switchToolbarActions(toolbar.ToolbarActions.FONT_SIZE), label: i18n.state.toolbar.style_font_size },
        index.h("span", null,
          "A",
          index.h("small", null, "A"))),
      renderSeparator()));
  };
  const renderColorActions = () => {
    const result = [
      index.h("stylo-toolbar-button", { onAction: () => switchToolbarActions(toolbar.ToolbarActions.COLOR), label: i18n.state.toolbar.style_color },
        index.h(IconPalette, null))
    ];
    if (configStore.state.toolbar.style.backgroundColor) {
      result.push(index.h("stylo-toolbar-button", { onAction: () => switchToolbarActions(toolbar.ToolbarActions.BACKGROUND_COLOR), label: i18n.state.toolbar.style_background },
        index.h(IconColor, null)));
    }
    return result;
  };
  return (index.h(index.Fragment, null,
    index.h("stylo-toolbar-text", { disabledTitle: disabledTitle, bold: bold === 'bold', italic: italic === 'italic', underline: underline === 'underline', strikethrough: strikethrough === 'strikethrough', onExecCommand: ($event) => onExecCommand($event) }),
    renderSeparator(),
    renderFontSizeAction(),
    renderColorActions(),
    renderSeparator(),
    renderAlignAction(),
    renderListAction(),
    renderLinkSeparator(),
    index.h("stylo-toolbar-button", { onAction: toggleLink, cssClass: link ? 'active' : undefined, label: i18n.state.toolbar.link },
      index.h(IconLink, null))));
};

const toolbarCss = ":host{direction:ltr;position:absolute;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}div.tools{display:flex;justify-content:center;align-items:center;visibility:hidden;opacity:0;height:0;animation:0s ease 0s 1 normal none running none;transition:opacity 0.1s ease-out;position:absolute;top:var(--actions-top);left:var(--actions-left);right:var(--actions-right);transform:translate(var(--actions-translate-x), var(--actions-translate-y));z-index:var(--stylo-toolbar-zindex, 2);--box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.12);box-shadow:var(--stylo-box-shadow, var(--box-shadow));border:var(--stylo-border);background:var(--stylo-background, var(--white));color:var(--stylo-color, var(--white-contrast));border-radius:var(--stylo-border, 4px);padding:var(--stylo-toolbar-padding, 0 8px);min-width:var(--stylo-toolbar-min-width, 280px)}div.tools.tools-activated{visibility:visible;opacity:1;height:unset;min-height:var(--stylo-toolbar-min-height, 44px)}";

const Toolbar = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.toolbarActivated = index.createEvent(this, "toolbarActivated", 7);
    this.linkCreated = index.createEvent(this, "linkCreated", 7);
    this.styleDidChange = index.createEvent(this, "styleDidChange", 7);
    this.debounceDisplayToolsActivated = d(() => {
      this.displayToolsActivated = true;
      this.toolbarActivated.emit(true);
    });
    this.selection = null;
    this.selectionParagraph = undefined;
    this.anchorLink = null;
    this.rtl = p();
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (['Escape'].includes(code)) {
        this.reset(false);
        return;
      }
      this.styleKeyboardShortcuts($event);
    };
    this.startSelection = ($event) => {
      this.anchorEvent = {
        $event,
        composedPath: $event.composedPath()
      };
    };
    this.toggleLink = () => {
      if (this.link) {
        removeLink(this.containerRef);
        this.reset(true);
      }
      else {
        this.openLink();
      }
    };
    /***
     * The toolbar is already displayed and we want to switch the actions
     */
    this.switchToolbarActions = (actions) => (this.toolbarActions = actions);
    this.onExecCommand = ($event) => {
      this.execCommand($event.detail);
    };
    this.config = undefined;
    this.containerRef = undefined;
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
    this.align = undefined;
    this.list = undefined;
    this.fontSize = undefined;
    this.disabledTitle = false;
    this.toolsActivated = false;
    this.displayToolsActivated = false;
    this.link = false;
    this.toolbarActions = toolbar.ToolbarActions.STYLE;
    this.toolsPosition = undefined;
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  componentWillLoad() {
    this.initDefaultContentAlign();
    this.applyStandaloneConfig();
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  onContainerRef() {
    if (!this.containerRef) {
      return;
    }
    this.removeListener();
    this.addListener();
  }
  onConfigChange() {
    this.applyStandaloneConfig();
  }
  applyStandaloneConfig() {
    if (!this.config) {
      return;
    }
    configStore.state.toolbar = Object.assign(Object.assign({}, configStore.state.toolbar), this.config);
  }
  styleKeyboardShortcuts($event) {
    const { metaKey, ctrlKey, key } = $event;
    if (!metaKey && !ctrlKey) {
      return;
    }
    if (!['b', 'i', 'u', 'k'].includes(key)) {
      return;
    }
    $event.preventDefault();
    $event.stopPropagation();
    switch (key) {
      case 'b':
        this.execCommand(actionBold);
        break;
      case 'i':
        this.execCommand(actionItalic);
        break;
      case 'u':
        this.execCommand(actionUnderline);
        break;
      case 'k':
        this.openLink();
        break;
    }
  }
  onContextMenu() {
    this.reset(false);
  }
  onSelectionChange() {
    if ([toolbar.ToolbarActions.COLOR, toolbar.ToolbarActions.BACKGROUND_COLOR, toolbar.ToolbarActions.LINK].includes(this.toolbarActions)) {
      return;
    }
    this.displayTools();
  }
  onResize() {
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.reset(true);
  }
  onContainerClick($event) {
    if ([toolbar.ToolbarActions.COLOR, toolbar.ToolbarActions.BACKGROUND_COLOR, toolbar.ToolbarActions.LINK].includes(this.toolbarActions)) {
      return;
    }
    $event.preventDefault();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('mousedown', this.startSelection, { passive: true });
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('touchstart', this.startSelection, { passive: true });
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('keydown', this.onKeyDown);
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('mousedown', this.startSelection);
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('touchstart', this.startSelection);
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('keydown', this.onKeyDown);
  }
  displayTools() {
    let selection = getSelection$1(this.containerRef);
    if (!this.anchorEvent) {
      this.reset(false);
      return;
    }
    const { $event, composedPath } = this.anchorEvent;
    if (this.containerRef &&
      !this.containerRef.contains($event.target) &&
      !this.containerRef.contains(composedPath[0])) {
      this.reset(false);
      return;
    }
    if (!selection || !selection.toString() || selection.toString().trim().length <= 0) {
      this.reset(false);
      return;
    }
    const activated = this.activateToolbar(selection);
    this.setToolsActivated(activated);
    if (!this.toolsActivated) {
      return;
    }
    this.selection = selection;
    this.selectionParagraph = toolbar.findParagraph({
      element: !this.selection ? document.activeElement : this.selection.anchorNode,
      container: this.containerRef
    });
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      this.anchorLink = {
        range: range.cloneRange()
      };
      this.setToolbarAnchorPosition();
    }
  }
  setToolbarAnchorPosition() {
    if (!this.tools) {
      return;
    }
    const { $event } = this.anchorEvent;
    const eventX = l($event).clientX;
    const eventY = l($event).clientY;
    const { range } = getRange(this.containerRef);
    const selectionRect = range === null || range === void 0 ? void 0 : range.getBoundingClientRect();
    // Calculate the absolute position on the screen where the container should be (if it's above the selection)
    const targetAbsoluteX = selectionRect
      ? selectionRect.x + selectionRect.width / 2
      : eventX;
    const targetAbsoluteY = selectionRect ? selectionRect.y : eventY;
    const { x, y } = this.el.shadowRoot.host.getBoundingClientRect();
    // calculate the relative position between the containers
    const relativeX = targetAbsoluteX - x;
    const relativeY = targetAbsoluteY - y;
    const position = eventY > 100 ? 'above' : 'under';
    // TODO: this maybe not always be the case that the whole window size could be used for overlay
    const { innerWidth } = window;
    const topOffset = 16;
    const top = position === 'above' ? relativeY - topOffset : relativeY + ((selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.height) || 0) + 8;
    const safeAreaMarginX = 32;
    // Limit overflow right
    const overflowLeft = this.tools.offsetWidth / 2 + safeAreaMarginX > relativeX;
    const fixedLeft = ((selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.left) || eventX) - 40;
    const overflowRight = innerWidth > 0 && fixedLeft > innerWidth - (this.tools.offsetWidth / 2 + safeAreaMarginX);
    const left = overflowRight
      ? `${innerWidth - x - this.tools.offsetWidth - safeAreaMarginX}px`
      : overflowLeft
        ? `${safeAreaMarginX}px`
        : `${relativeX}px`;
    const right = `auto`;
    // To set the position of the tools
    this.toolsPosition = {
      top,
      left,
      right,
      position,
      align: overflowRight ? 'end' : overflowLeft ? 'start' : 'center',
      anchorLeft: overflowLeft
        ? relativeX - safeAreaMarginX
        : overflowRight
          ? relativeX - (innerWidth - safeAreaMarginX - this.tools.offsetWidth)
          : this.tools.offsetWidth / 2
    };
  }
  activateToolbar(selection) {
    const tools = selection && selection.toString() && selection.toString().length > 0;
    if (tools) {
      this.initStyle(selection);
      this.initLink(selection);
    }
    return tools;
  }
  initStyle(selection) {
    if (!selection || selection.rangeCount <= 0) {
      return;
    }
    const content = toolbar.a(selection);
    if (!content) {
      return;
    }
    this.initStyleForNode(content);
  }
  initStyleForNode(node) {
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
    this.list = undefined;
    this.fontSize = undefined;
    this.initDefaultContentAlign();
    this.findStyle(node);
  }
  initDefaultContentAlign() {
    this.align = this.rtl ? toolbar.ToolbarAlign.RIGHT : toolbar.ToolbarAlign.LEFT;
  }
  // We iterate until we find the root container to detect if bold, underline or italic are active
  findStyle(node) {
    if (!node || node instanceof ShadowRoot) {
      return;
    }
    // Just in case
    if (node.nodeName.toUpperCase() === 'HTML' || node.nodeName.toUpperCase() === 'BODY') {
      return;
    }
    if (this.bold === undefined) {
      this.bold = getBold(toolbar.toHTMLElement(node));
    }
    if (this.italic === undefined) {
      this.italic = getItalic(toolbar.toHTMLElement(node));
    }
    if (this.underline === undefined) {
      this.underline = getUnderline(toolbar.toHTMLElement(node));
    }
    if (this.strikethrough === undefined) {
      this.strikethrough = getStrikeThrough(toolbar.toHTMLElement(node));
    }
    if (this.list === undefined) {
      this.list = getList(toolbar.toHTMLElement(node));
    }
    if (this.fontSize === undefined) {
      this.fontSize = getFontSize(toolbar.toHTMLElement(node));
    }
    if (toolbar.isParagraph({ element: node, container: this.containerRef })) {
      const nodeName = node.nodeName.toUpperCase();
      this.disabledTitle =
        nodeName === 'H1' ||
          nodeName === 'H2' ||
          nodeName === 'H3' ||
          nodeName === 'H4' ||
          nodeName === 'H5' ||
          nodeName === 'H6';
      this.align = getContentAlignment(toolbar.toHTMLElement(node));
      return;
    }
    this.findStyle(node.parentNode);
  }
  initLink(selection) {
    if (!selection) {
      return;
    }
    let content = selection.anchorNode;
    if (!content) {
      return;
    }
    if (content.nodeType === 3) {
      content = content.parentElement;
    }
    this.link = content.nodeName && content.nodeName.toLowerCase() === 'a';
  }
  /**
   * Reset the inline editor (= hide it) and optionally clear its selection.
   * @param clearSelection
   * @param blurActiveElement
   */
  reset(clearSelection, blurActiveElement) {
    if (clearSelection) {
      toolbar.i();
    }
    this.setToolsActivated(false);
    if (clearSelection) {
      // We don't want to emit that state a zillion time but only when needed
      this.toolbarActivated.emit(false);
    }
    this.selection = null;
    this.selectionParagraph = null;
    this.toolbarActions = toolbar.ToolbarActions.STYLE;
    this.anchorLink = null;
    this.link = false;
    if (blurActiveElement &&
      document.activeElement &&
      document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  }
  openLink() {
    this.toolbarActions = toolbar.ToolbarActions.LINK;
  }
  setToolsActivated(activated) {
    this.toolsActivated = activated;
    if (activated) {
      this.debounceDisplayToolsActivated();
    }
    else {
      this.displayToolsActivated = false;
    }
  }
  execCommand(action) {
    // onSelectionChange is triggered if DOM changes, we still need to detect attributes changes to refresh style
    this.onAttributesChangesInitStyle();
    if (configStore.state.toolbar.command === 'native') {
      execCommandNative(action);
    }
    else {
      execCommand(this.selection, action, this.containerRef);
    }
    const { cmd } = action;
    if (cmd === 'list' || f()) {
      this.reset(true);
    }
    if (!this.selectionParagraph) {
      return;
    }
    this.styleDidChange.emit(toolbar.toHTMLElement(this.selectionParagraph));
  }
  onAttributesChangesInitStyle() {
    const anchorNode = toolbar.a(this.selection);
    if (!anchorNode) {
      return;
    }
    const observer = new MutationObserver(() => {
      observer.disconnect();
      this.initStyleForNode(anchorNode);
    });
    observer.observe(anchorNode, { attributes: true });
  }
  render() {
    var _a, _b;
    let classNames = this.displayToolsActivated ? 'tools tools-activated' : 'tools';
    const position = ((_a = this.toolsPosition) === null || _a === void 0 ? void 0 : _a.position) || 'above';
    const style = this.toolsPosition
      ? {
        '--actions-top': `${this.toolsPosition.top}px`,
        '--actions-left': this.toolsPosition.left,
        '--actions-right': this.toolsPosition.right,
        '--actions-translate-x': `${this.toolsPosition.align === 'center' ? '-50%' : '0'}`,
        '--actions-translate-y': `${this.toolsPosition.position === 'above' ? '-100%' : '0'}`
      }
      : undefined;
    return (index.h("div", { class: classNames, ref: (el) => (this.tools = el), style: style, onClick: ($event) => $event.stopPropagation(), onMouseDown: ($event) => this.onContainerClick($event), onTouchStart: ($event) => this.onContainerClick($event) }, index.h("stylo-toolbar-triangle", { class: position === 'above' ? 'bottom' : 'top', style: {
        '--stylo-toolbar-triangle-start': `${(_b = this.toolsPosition) === null || _b === void 0 ? void 0 : _b.anchorLeft}px`
      } }), this.renderActions()));
  }
  renderActions() {
    if (this.toolbarActions === toolbar.ToolbarActions.LINK) {
      return (index.h("stylo-toolbar-link", { containerRef: this.containerRef, toolbarActions: this.toolbarActions, anchorLink: this.anchorLink, linkCreated: this.linkCreated, onLinkModified: ($event) => this.reset($event.detail), onClose: () => this.reset(false) }));
    }
    if (this.toolbarActions === toolbar.ToolbarActions.COLOR ||
      this.toolbarActions === toolbar.ToolbarActions.BACKGROUND_COLOR) {
      return (index.h("stylo-toolbar-color", { containerRef: this.containerRef, action: this.toolbarActions === toolbar.ToolbarActions.BACKGROUND_COLOR ? 'background-color' : 'color', onExecCommand: this.onExecCommand, onClose: () => this.reset(false) }));
    }
    if (this.toolbarActions === toolbar.ToolbarActions.ALIGNMENT) {
      return (index.h("stylo-toolbar-align", { containerRef: this.containerRef, anchorEvent: this.anchorEvent.$event, align: this.align, onAlignModified: () => this.reset(true) }));
    }
    if (this.toolbarActions === toolbar.ToolbarActions.LIST) {
      return (index.h("stylo-toolbar-list", { list: this.list, onExecCommand: this.onExecCommand }));
    }
    if (this.toolbarActions === toolbar.ToolbarActions.FONT_SIZE) {
      return (index.h("stylo-toolbar-font-size", { fontSize: this.fontSize, onExecCommand: this.onExecCommand }));
    }
    return (index.h(Style, { align: this.align, list: this.list, switchToolbarActions: this.switchToolbarActions, bold: this.bold, disabledTitle: this.disabledTitle, italic: this.italic, strikethrough: this.strikethrough, underline: this.underline, link: this.link, onExecCommand: this.onExecCommand, toggleLink: this.toggleLink }));
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "containerRef": ["onContainerRef"],
    "config": ["onConfigChange"]
  }; }
};
Toolbar.style = toolbarCss;

const execCommandAlign = (anchorEvent, container, align) => {
  const anchorElement = toolbar.toHTMLElement(anchorEvent.target);
  const paragraph = toolbar.toHTMLElement(toolbar.findParagraph({ element: anchorElement, container }));
  if (!paragraph) {
    return;
  }
  paragraph.style.textAlign = (paragraph === null || paragraph === void 0 ? void 0 : paragraph.style.textAlign) === align ? '' : align;
};

const alignCss = ":host{display:flex;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}stylo-toolbar-button.active{--stylo-toolbar-button-color:var(--stylo-toolbar-button-color-active, var(--highlight))}";

const Align = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.alignModified = index.createEvent(this, "alignModified", 7);
    this.anchorEvent = undefined;
    this.align = undefined;
    this.containerRef = undefined;
  }
  justifyContent($event, align) {
    $event.stopPropagation();
    if (configStore.state.toolbar.command === 'native') {
      execCommandNativeAlign(align);
    }
    else {
      execCommandAlign(this.anchorEvent, this.containerRef, align);
    }
    this.alignModified.emit();
  }
  render() {
    return (index.h(index.Host, null, index.h("stylo-toolbar-button", { label: i18n.state.toolbar.align_left, onAction: ($event) => this.justifyContent($event.detail, toolbar.ToolbarAlign.LEFT), class: this.align === toolbar.ToolbarAlign.LEFT ? 'active' : undefined }, index.h(IconAlignLeft, null)), index.h("stylo-toolbar-button", { label: i18n.state.toolbar.align_center, onAction: ($event) => this.justifyContent($event.detail, toolbar.ToolbarAlign.CENTER), class: this.align === toolbar.ToolbarAlign.CENTER ? 'active' : undefined }, index.h(IconAlignCenter, null)), index.h("stylo-toolbar-button", { label: i18n.state.toolbar.align_right, onAction: ($event) => this.justifyContent($event.detail, toolbar.ToolbarAlign.RIGHT), class: this.align === toolbar.ToolbarAlign.RIGHT ? 'active' : undefined }, index.h(IconAlignRight, null))));
  }
};
Align.style = alignCss;

const buttonCss = ".host{--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}button{pointer-events:initial;cursor:pointer;margin:0;padding:4px 6px 6px;height:40px;z-index:var(--stylo-toolbar-button-zindex, 2);display:flex;justify-content:center;align-items:center;border:0;color:var(--stylo-toolbar-button-color, black);transition:0.1s background-color, 0.1s border-color, 0.1s fill;background:transparent;font-size:var(--stylo-toolbar-button-font-size, 1.4rem);font-family:var(--stylo-toolbar-button-font-family, inherit);-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;outline:0}button.active{color:var(--stylo-toolbar-button-color-active, var(--highlight))}button[disabled]{color:var(--stylo-toolbar-button-color-disabled, var(--light));display:var(--stylo-toolbar-button-display-disabled, none)}button.active>div{background-color:var(--stylo-toolbar-button-color-active, var(--highlight))}button[disabled]>div{background-color:var(--stylo-toolbar-button-color-disabled, var(--light))}::slotted(*){pointer-events:none}::slotted(svg){width:18px;height:18px;padding-bottom:2px}";

const Button = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.action = index.createEvent(this, "action", 7);
    this.disableAction = false;
    this.cssClass = undefined;
    this.label = undefined;
  }
  render() {
    return (index.h("button", { onMouseDown: ($event) => $event.stopPropagation(), onTouchStart: ($event) => $event.stopPropagation(), onClick: ($event) => {
        $event.stopPropagation();
        this.action.emit($event);
      }, disabled: this.disableAction, class: this.cssClass, "aria-label": this.label }, index.h("slot", null)));
  }
};
Button.style = buttonCss;

const colorCss = ":host{padding:4px 0}:host stylo-color{pointer-events:all}";

const Color = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.execCommand = index.createEvent(this, "execCommand", 7);
    this.close = index.createEvent(this, "close", 7);
    this.closeToolbar = () => {
      this.close.emit();
    };
    this.action = undefined;
    this.containerRef = undefined;
    this.colorRgb = undefined;
  }
  componentWillLoad() {
    this.initColor();
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('click', this.closeToolbar, { passive: true });
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('click', this.closeToolbar);
  }
  initColor() {
    const { range, selection } = getRange(this.containerRef);
    this.range = range;
    const anchor = toolbar.a(selection);
    if (!anchor) {
      return;
    }
    const style = findStyleNode(anchor, this.action === 'color' ? 'color' : 'background-color', this.containerRef);
    if (!style) {
      return;
    }
    const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(toolbar.toHTMLElement(style));
    this.colorRgb = (this.action === 'color' ? css.color : css.backgroundColor)
      .replace('rgb(', '')
      .replace(')', '');
  }
  selectColor($event) {
    const selection = getSelection$1(this.containerRef);
    if (!selection || !$event || !$event.detail) {
      return;
    }
    if (!this.action) {
      return;
    }
    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
    selection === null || selection === void 0 ? void 0 : selection.addRange(this.range);
    const observer = new MutationObserver((_mutations) => {
      observer.disconnect();
      // No node were added so the style was modified
      this.range = selection === null || selection === void 0 ? void 0 : selection.getRangeAt(0);
    });
    const anchorNode = toolbar.a(selection);
    if (!anchorNode) {
      return;
    }
    observer.observe(anchorNode, { childList: true });
    this.execCommand.emit({
      cmd: 'style',
      detail: {
        style: this.action,
        value: $event.detail.hex,
        initial: (element) => {
          const rgb = u($event.detail.hex);
          return (element &&
            (element.style[this.action] === $event.detail.hex ||
              element.style[this.action] === `rgb(${rgb})`));
        }
      }
    });
  }
  render() {
    return (index.h("stylo-color", { "color-rgb": this.colorRgb, onColorChange: ($event) => this.selectColor($event), palette: configStore.state.toolbar.palette }));
  }
};
Color.style = colorCss;

const fontSizeCss = ":host{--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff;display:flex}stylo-toolbar-button.active{--stylo-toolbar-button-color:var(--stylo-toolbar-button-color-active, var(--highlight))}stylo-toolbar-button:first-of-type{--stylo-toolbar-button-font-size:0.8rem}stylo-toolbar-button:nth-of-type(2){--stylo-toolbar-button-font-size:1rem}stylo-toolbar-button:nth-of-type(3){--stylo-toolbar-button-font-size:1.2rem}stylo-toolbar-button:nth-of-type(5){--stylo-toolbar-button-font-size:1.6rem}stylo-toolbar-button:nth-of-type(6){--stylo-toolbar-button-font-size:1.8rem}stylo-toolbar-button:nth-of-type(7){--stylo-toolbar-button-font-size:2rem}";

const FontSize = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.execCommand = index.createEvent(this, "execCommand", 7);
    this.fontSize = undefined;
  }
  modifyFontSize($event, size) {
    $event.stopPropagation();
    const value = Object.keys(toolbar.ToolbarFontSize).find((key) => toolbar.ToolbarFontSize[key] === size);
    this.execCommand.emit({
      cmd: 'style',
      detail: {
        style: 'font-size',
        value: value.toLowerCase().replace('_', '-'),
        initial: (element) => element && element.style['font-size'] === value.toLowerCase().replace('_', '-')
      }
    });
    this.fontSize = size;
  }
  render() {
    return (index.h(index.Host, null, this.renderAction(toolbar.ToolbarFontSize.X_SMALL), this.renderAction(toolbar.ToolbarFontSize.SMALL), this.renderAction(toolbar.ToolbarFontSize.MEDIUM), this.renderAction(toolbar.ToolbarFontSize.LARGE), this.renderAction(toolbar.ToolbarFontSize.X_LARGE), this.renderAction(toolbar.ToolbarFontSize.XX_LARGE), this.renderAction(toolbar.ToolbarFontSize.XXX_LARGE)));
  }
  renderAction(size) {
    return (index.h("stylo-toolbar-button", { label: `${i18n.state.toolbar.font_size} ${size}`, onAction: ($event) => this.modifyFontSize($event.detail, size), class: this.fontSize === size ? 'active' : undefined }, index.h("span", null, size.toString())));
  }
};
FontSize.style = fontSizeCss;

const linkCss = ":host{width:100%;height:100%;z-index:var(--stylo-toolbar-link-zindex, 2)}:host input{pointer-events:visible;background:transparent;width:97%;height:100%;color:var(--stylo-toolbar-link-color, black);border:none;outline:0;font-size:16px}:host input::-moz-placeholder{color:var(--stylo-toolbar-link-placeholder-color, black)}:host input::placeholder{color:var(--stylo-toolbar-link-placeholder-color, black)}";

const Link = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.linkModified = index.createEvent(this, "linkModified", 7);
    this.close = index.createEvent(this, "close", 7);
    this.closeToolbar = () => {
      this.close.emit();
    };
    this.containerRef = undefined;
    this.toolbarActions = undefined;
    this.anchorLink = undefined;
    this.linkCreated = undefined;
  }
  componentDidLoad() {
    setTimeout(() => { var _a; return (_a = this.input) === null || _a === void 0 ? void 0 : _a.focus(); }, 250);
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('click', this.closeToolbar, { passive: true });
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('click', this.closeToolbar);
  }
  handleLinkInput($event) {
    this.linkUrl = $event.target.value;
  }
  createLink() {
    if (!this.anchorLink) {
      return;
    }
    const { range } = this.anchorLink;
    if (!range) {
      return;
    }
    if (!this.linkUrl || this.linkUrl.length <= 0) {
      return;
    }
    createLink({ range, linkUrl: this.linkUrl });
    const container = toolbar.findParagraph({
      element: range.commonAncestorContainer,
      container: this.containerRef
    });
    if (!container) {
      return;
    }
    this.linkCreated.emit(toolbar.toHTMLElement(container));
  }
  handleLinkEnter($event) {
    if (!$event) {
      return;
    }
    if (this.toolbarActions === toolbar.ToolbarActions.STYLE &&
      ($event.key.toLowerCase() === 'backspace' || $event.key.toLowerCase() === 'delete')) {
      this.linkModified.emit(false);
    }
    else if (this.toolbarActions === toolbar.ToolbarActions.LINK &&
      $event.key.toLowerCase() === 'enter') {
      this.createLink();
      this.linkModified.emit(true);
    }
  }
  render() {
    return (index.h(index.Host, null, index.h("input", { ref: (el) => (this.input = el), placeholder: "Add a link...", onInput: ($event) => this.handleLinkInput($event), onKeyUp: ($event) => this.handleLinkEnter($event) })));
  }
};
Link.style = linkCss;

const listCss = ":host{display:flex;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}stylo-toolbar-button.active{--stylo-toolbar-button-color:var(--stylo-toolbar-button-color-active, var(--highlight))}";

const AlignActions = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.execCommand = index.createEvent(this, "execCommand", 7);
    this.list = undefined;
  }
  toggleList(e, type) {
    e.stopPropagation();
    this.execCommand.emit({
      cmd: 'list',
      detail: {
        type
      }
    });
  }
  render() {
    return (index.h(index.Host, null, index.h("stylo-toolbar-button", { label: i18n.state.toolbar.list_ol, onAction: ($event) => this.toggleList($event.detail, 'ol'), class: this.list === toolbar.ToolbarList.ORDERED ? 'active' : undefined }, index.h(IconOl, null)), index.h("stylo-toolbar-button", { label: i18n.state.toolbar.list_ul, onAction: ($event) => this.toggleList($event.detail, 'ul'), class: this.list === toolbar.ToolbarList.UNORDERED ? 'active' : undefined }, index.h(IconUl, null))));
  }
};
AlignActions.style = listCss;

const separatorCss = ":host{--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}div.separator{display:inline-block;vertical-align:middle;width:1px;min-width:1px;margin:0 6px;height:24px;background:var(--stylo-toolbar-separator-background, var(--light))}";

const Separator$1 = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
  }
  render() {
    return index.h("div", { class: "separator" });
  }
};
Separator$1.style = separatorCss;

const textCss = ":host{display:inline-flex;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}stylo-toolbar-button{margin:0 2px}stylo-toolbar-button.italic span{font-style:italic}stylo-toolbar-button.underline.active span{border-bottom:1px solid var(--stylo-toolbar-button-color-active, var(--highlight))}stylo-toolbar-button.underline span{border-bottom:1px solid var(--stylo-toolbar-button-color, black)}";

const Text = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.execCommand = index.createEvent(this, "execCommand", 7);
    this.disabledTitle = false;
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
  }
  styleBold($event) {
    $event.stopPropagation();
    this.execCommand.emit(actionBold);
  }
  styleItalic($event) {
    $event.stopPropagation();
    this.execCommand.emit(actionItalic);
  }
  styleUnderline($event) {
    $event.stopPropagation();
    this.execCommand.emit(actionUnderline);
  }
  styleStrikeThrough($event) {
    $event.stopPropagation();
    this.execCommand.emit(actionStrikeThrough);
  }
  render() {
    return (index.h(index.Host, null, index.h("stylo-toolbar-button", { label: i18n.state.toolbar.bold, onAction: ($event) => this.styleBold($event.detail), disableAction: this.disabledTitle, cssClass: this.bold ? 'active' : undefined, class: "bold" }, index.h("span", null, "B")), index.h("stylo-toolbar-button", { label: i18n.state.toolbar.italic, onAction: ($event) => this.styleItalic($event.detail), cssClass: this.italic ? 'active' : undefined, class: "italic" }, index.h("span", null, "I")), index.h("stylo-toolbar-button", { label: i18n.state.toolbar.underline, onAction: ($event) => this.styleUnderline($event.detail), cssClass: this.underline ? 'active' : undefined, class: this.underline ? 'active underline' : 'underline' }, index.h("span", null, "U")), index.h("stylo-toolbar-button", { label: i18n.state.toolbar.strikethrough, onAction: ($event) => this.styleStrikeThrough($event.detail), cssClass: this.strikethrough ? 'active' : undefined, class: "strikethrough" }, index.h("span", { style: { 'text-decoration': 'line-through' } }, "S"))));
  }
};
Text.style = textCss;

const triangleCss = ":host(.top) div.triangle{bottom:unset;top:-34px;transform:scale(0.7) translate(50%, 0)}div.triangle{z-index:1;position:absolute;bottom:-34px;left:var(--stylo-toolbar-triangle-start);width:40px;height:40px;overflow:hidden;transform:scale(0.7) rotate(180deg) translate(50%, 0)}div.triangle:after{content:\"\";position:absolute;width:24px;height:24px;background:white;transform:rotate(45deg);top:28px;left:8px;--box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.12);box-shadow:var(--stylo-box-shadow, var(--box-shadow));border:var(--stylo-border)}";

const Separator = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.mobile = undefined;
  }
  render() {
    if (this.mobile) {
      return undefined;
    }
    return index.h("div", { class: "triangle" });
  }
};
Separator.style = triangleCss;

exports.stylo_add = Add;
exports.stylo_color = Color$1;
exports.stylo_color_input = Input;
exports.stylo_editor = Editor;
exports.stylo_list = List;
exports.stylo_menus = Menus;
exports.stylo_plugins = Plugins;
exports.stylo_toolbar = Toolbar;
exports.stylo_toolbar_align = Align;
exports.stylo_toolbar_button = Button;
exports.stylo_toolbar_color = Color;
exports.stylo_toolbar_font_size = FontSize;
exports.stylo_toolbar_link = Link;
exports.stylo_toolbar_list = AlignActions;
exports.stylo_toolbar_separator = Separator$1;
exports.stylo_toolbar_text = Text;
exports.stylo_toolbar_triangle = Separator;
