const createEmptyElement = ({ nodeName }) => {
  const element = document.createElement(nodeName);
  element.innerHTML = '\u200B';
  return element;
};

var i=()=>{window&&window.getSelection?window.getSelection()?.empty?window.getSelection()?.empty():window.getSelection()?.removeAllRanges&&window.getSelection()?.removeAllRanges():document&&document.selection&&document.selection.empty();},c=()=>window&&window.getSelection?window.getSelection():document&&document.getSelection?document.getSelection():document&&document.selection?document.selection.createRange().text:null,a=e=>{let n=e?.anchorNode;return n?n.nodeType!==Node.TEXT_NODE&&n.nodeType!==Node.COMMENT_NODE?n:n.parentElement:null},u=e=>{d({element:e,collapse:"end"});},g=e=>{d({element:e,collapse:"start"});},d=({element:e,collapse:n})=>{if(!e)return;let t=document.createRange();t.selectNodeContents(e),t.collapse(n==="start"),l(t);},f=({element:e,offset:n})=>{if(!e)return;let t=document.createRange();t.setStart(e,n),l(t);},l=e=>{let n=c();n?.removeAllRanges(),n?.addRange(e),e.detach();},m=({target:e})=>{let t=c()?.getRangeAt(0),o=t?.cloneRange();if(!o||!t)return;let{endContainer:r,endOffset:s}=t;return o.selectNodeContents(e),o.setEnd(r,s),o.toString().length};

const isTextNode = (element) => {
  return (element === null || element === void 0 ? void 0 : element.nodeType) === Node.TEXT_NODE || (element === null || element === void 0 ? void 0 : element.nodeType) === Node.COMMENT_NODE;
};
const toHTMLElement = (element) => {
  return isTextNode(element) ? element.parentElement : element;
};
const elementIndex = (element) => {
  var _a;
  return Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []).indexOf(element);
};
const nodeIndex = (node) => {
  var _a;
  return Array.from(((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) || []).indexOf(node);
};
const nodeDepths = ({ target, paragraph }) => {
  const depths = [nodeIndex(target)];
  if (!paragraph) {
    return depths;
  }
  let parentElement = target.parentElement;
  while (parentElement && !parentElement.isSameNode(paragraph)) {
    depths.push(nodeIndex(parentElement));
    parentElement = parentElement.parentElement;
  }
  return depths.reverse();
};
const findNodeAtDepths = ({ parent, indexDepths }) => {
  const childNode = ((parent === null || parent === void 0 ? void 0 : parent.childNodes) ? Array.from(parent === null || parent === void 0 ? void 0 : parent.childNodes) : [])[indexDepths[0]];
  if (!childNode) {
    return undefined;
  }
  const [, ...rest] = indexDepths;
  if ((rest === null || rest === void 0 ? void 0 : rest.length) <= 0) {
    return childNode;
  }
  return findNodeAtDepths({ parent: childNode, indexDepths: rest });
};
// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories
const isPhrasingContent = (node) => isTextNode(node) ||
  [
    'abbr',
    'audio',
    'b',
    'bdo',
    'br',
    'button',
    'canvas',
    'cite',
    'code',
    'data',
    'datalist',
    'dfn',
    'em',
    'embed',
    'i',
    'iframe',
    'img',
    'input',
    'kbd',
    'label',
    'mark',
    'math',
    'meter',
    'noscript',
    'object',
    'output',
    'picture',
    'progress',
    'q',
    'ruby',
    'samp',
    'script',
    'select',
    'small',
    'span',
    'strong',
    'sub',
    'sup',
    'svg',
    'textarea',
    'time',
    'u',
    'var',
    'video',
    'wbr'
  ].includes(node.nodeName.toLowerCase()) ||
  ['a', 'area', 'del', 'ins', 'map'].includes(node.nodeName.toLowerCase());
const isMetaContent = ({ nodeName }) => ['base', 'link', 'meta', 'noscript', 'script', 'style', 'title'].includes(nodeName.toLowerCase());
const isNodeList = ({ node: { nodeName } }) => ['ul', 'ol', 'dl'].includes(nodeName.toLowerCase());

const findParagraph = ({ element, container }) => {
  if (!container) {
    return undefined;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return undefined;
  }
  if (!container.parentNode) {
    return undefined;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return undefined;
  }
  if (parentElement.isEqualNode(container)) {
    return element;
  }
  return findParagraph({ element: parentElement, container });
};
/**
 * <article>
 *   <div>
 *     <span>
 *       => isStartNode = true
 *
 * <article>
 *   <div>
 *     Hello <span>
 *             => isStartNode = false
 */
const isStartNode = ({ element, container }) => {
  if (!container) {
    return false;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return false;
  }
  if (isParagraph({ element, container })) {
    return true;
  }
  // If node is the direct first child of it's parent, we can check the parent until we get the container
  if (nodeIndex(element) === 0) {
    return isStartNode({ element: element.parentElement, container });
  }
  return false;
};
const isParagraph = ({ element, container }) => {
  if (!element) {
    return false;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return false;
  }
  return parentElement === null || parentElement === void 0 ? void 0 : parentElement.isEqualNode(container);
};
const focusParagraph = ({ paragraph }) => {
  if (!isTextNode(paragraph)) {
    toHTMLElement(paragraph).focus();
  }
  u(paragraph);
};
const transformParagraph = ({ elements, paragraph, container, focus = 'first' }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    if (addedNodes.length <= 0) {
      return;
    }
    const { firstChild } = toHTMLElement(addedNodes[focus === 'first' ? 0 : addedNodes.length - 1]);
    u(firstChild);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  paragraph.replaceWith(...elements);
};
const createEmptyParagraph = ({ paragraph, container }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    // Should not happen, fallback
    if (!paragraph) {
      container.append(div);
      return;
    }
    paragraph.after(div);
  });
};
const addParagraph = ({ paragraph, container, fragment }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    paragraph.after(fragment);
  });
};
const addParagraphs = ({ paragraph, container, nodes }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const mutation = mutations[mutations.length - 1];
    if (!mutation) {
      return;
    }
    const { addedNodes } = mutation;
    const last = addedNodes[addedNodes.length - 1];
    u(last);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  // User has deleted all paragraphs of the container previously
  if (!paragraph) {
    container.append(...nodes);
    return;
  }
  paragraph.after(...nodes);
};
const createNewEmptyLine = ({ paragraph, range }) => {
  const br = document.createElement('br');
  return insertNodeInRange({ observerRoot: paragraph, range, element: br });
};
const createNewParagraph = ({ container, range, text }) => {
  const div = document.createElement('div');
  div.innerHTML = text;
  return insertNodeInRange({ observerRoot: container, range, element: div });
};
const insertNodeInRange = ({ observerRoot, range, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      addObserver.disconnect();
      if (mutations.length === 0) {
        resolve(undefined);
        return;
      }
      const { addedNodes } = mutations[mutations.length - 1];
      if (!addedNodes || addedNodes.length === 0) {
        resolve(undefined);
        return;
      }
      resolve(addedNodes[addedNodes.length - 1]);
    });
    addObserver.observe(observerRoot, { childList: true, subtree: true });
    range.insertNode(element);
  });
};
const prependEmptyText = ({ paragraph }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    paragraph.prepend(text);
  });
};
const addEmptyText = ({ paragraph, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    element.after(text);
  });
};
const isParagraphEmpty = ({ paragraph }) => { var _a; return ['', '\n', '\u200B'].includes((_a = paragraph === null || paragraph === void 0 ? void 0 : paragraph.textContent) === null || _a === void 0 ? void 0 : _a.trim()); };
const isParagraphNotEditable = ({ paragraph }) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.getAttribute('contenteditable')) === 'false';
const isParagraphCode = ({ paragraph }) => {
  // DeckDeckGo web components
  if (paragraph.nodeName.toLowerCase().startsWith('deckgo-')) {
    return true;
  }
  return ['code', 'pre'].includes(paragraph.nodeName.toLowerCase());
};
const setParagraphAttribute = ({ paragraph, attributeName }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((_mutations) => {
      addObserver.disconnect();
      resolve();
    });
    addObserver.observe(paragraph, { attributes: true });
    paragraph.setAttribute(attributeName, '');
  });
};

const blockquote = {
  text: 'blockquote',
  icon: 'blockquote',
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'blockquote' })],
    paragraph,
    container
  })
};

const code = {
  text: 'code',
  icon: 'code',
  createParagraphs: async ({ container, paragraph }) => {
    transformParagraph({
      elements: [createEmptyElement({ nodeName: 'code' }), createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};

const h1 = {
  text: 'huge_title',
  icon: `<span class='placeholder'>H1</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h1' })],
    paragraph,
    container
  })
};

const h2 = {
  text: 'large_title',
  icon: `<span class='placeholder'>H2</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h2' })],
    paragraph,
    container
  })
};

const h3 = {
  text: 'small_title',
  icon: `<span class='placeholder'>H3</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h3' })],
    paragraph,
    container
  })
};

const hr = {
  text: 'separator',
  icon: 'hr',
  createParagraphs: async ({ container, paragraph }) => {
    const hr = document.createElement('hr');
    transformParagraph({
      elements: [hr, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container,
      focus: 'last'
    });
  }
};

const img = {
  text: 'image',
  icon: 'img',
  files: {
    accept: 'image/x-png,image/jpeg,image/gif,image/svg+xml,image/webp',
    multiple: false
  },
  createParagraphs: async ({ container, paragraph, files }) => {
    const URL = window.URL || window.webkitURL;
    const imgUrl = URL.createObjectURL(files[0]);
    const img = document.createElement('img');
    img.src = imgUrl;
    img.setAttribute('loading', 'lazy');
    const emptyDiv = createEmptyElement({ nodeName: 'div' });
    transformParagraph({
      elements: [img, emptyDiv],
      paragraph,
      container,
      focus: 'last'
    });
  }
};

const createListItem = () => {
  const item = document.createElement('li');
  item.innerHTML = '\u200B';
  return item;
};
const ul = {
  text: 'unordered_list',
  icon: 'ul',
  createParagraphs: async ({ container, paragraph }) => {
    const ul = document.createElement('ul');
    ul.append(createListItem());
    await transformParagraph({
      elements: [ul, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};
const ol = {
  text: 'ordered_list',
  icon: 'ol',
  createParagraphs: async ({ container, paragraph }) => {
    const ol = document.createElement('ol');
    ol.append(createListItem());
    await transformParagraph({
      elements: [ol, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};

const DEFAULT_PALETTE = [
  {
    color: {
      hex: '#8ED1FC',
      rgb: '142,209,252'
    },
    alt: 'Light blue'
  },
  {
    color: {
      hex: '#0693E3',
      rgb: '6,147,227'
    },
    alt: 'Blue'
  },
  {
    color: {
      hex: '#7BDCB5',
      rgb: '123,220,181'
    },
    alt: 'Light green'
  },
  {
    color: {
      hex: '#00D084',
      rgb: '0,208,132'
    },
    alt: 'Green'
  },
  {
    color: {
      hex: '#FCB900',
      rgb: '252,185,0'
    },
    alt: 'Yellow'
  },
  {
    color: {
      hex: '#FF6900',
      rgb: '255,105,0'
    },
    alt: 'Orange'
  },
  {
    color: {
      hex: '#F78DA7',
      rgb: '247,141,167'
    },
    alt: 'Pink'
  },
  {
    color: {
      hex: '#EB144C',
      rgb: '235,20,76'
    },
    alt: 'Red'
  },
  {
    color: {
      hex: '#ffffff',
      rgb: '255,255,255'
    },
    alt: 'White',
    display: {
      borderColor: '#ddd',
      boxShadowColor: '221,221,221'
    }
  },
  {
    color: {
      hex: '#ABB8C3',
      rgb: '171,184,195'
    },
    alt: 'Grey'
  },
  {
    color: {
      hex: '#000000',
      rgb: '0,0,0'
    },
    alt: 'Black'
  }
];

var ToolbarActions;
(function (ToolbarActions) {
  ToolbarActions[ToolbarActions["STYLE"] = 0] = "STYLE";
  ToolbarActions[ToolbarActions["LINK"] = 1] = "LINK";
  ToolbarActions[ToolbarActions["COLOR"] = 2] = "COLOR";
  ToolbarActions[ToolbarActions["ALIGNMENT"] = 3] = "ALIGNMENT";
  ToolbarActions[ToolbarActions["LIST"] = 4] = "LIST";
  ToolbarActions[ToolbarActions["FONT_SIZE"] = 5] = "FONT_SIZE";
  ToolbarActions[ToolbarActions["BACKGROUND_COLOR"] = 6] = "BACKGROUND_COLOR";
})(ToolbarActions || (ToolbarActions = {}));
var ToolbarList;
(function (ToolbarList) {
  ToolbarList["ORDERED"] = "insertOrderedList";
  ToolbarList["UNORDERED"] = "insertUnorderedList";
})(ToolbarList || (ToolbarList = {}));
var ToolbarAlign;
(function (ToolbarAlign) {
  ToolbarAlign["LEFT"] = "left";
  ToolbarAlign["CENTER"] = "center";
  ToolbarAlign["RIGHT"] = "right";
})(ToolbarAlign || (ToolbarAlign = {}));
var ToolbarFontSize;
(function (ToolbarFontSize) {
  ToolbarFontSize["X_SMALL"] = "1";
  ToolbarFontSize["SMALL"] = "2";
  ToolbarFontSize["MEDIUM"] = "3";
  ToolbarFontSize["LARGE"] = "4";
  ToolbarFontSize["X_LARGE"] = "5";
  ToolbarFontSize["XX_LARGE"] = "6";
  ToolbarFontSize["XXX_LARGE"] = "7";
})(ToolbarFontSize || (ToolbarFontSize = {}));

export { findNodeAtDepths as A, f as B, isNodeList as C, DEFAULT_PALETTE as D, isParagraphCode as E, createEmptyParagraph as F, u as G, addParagraph as H, prependEmptyText as I, createNewEmptyLine as J, addEmptyText as K, m as L, createNewParagraph as M, isStartNode as N, isPhrasingContent as O, addParagraphs as P, insertNodeInRange as Q, isMetaContent as R, nodeIndex as S, ToolbarActions as T, a as U, i as V, code as a, blockquote as b, createEmptyElement as c, h2 as d, h3 as e, hr as f, ToolbarList as g, h1 as h, img as i, ToolbarAlign as j, ToolbarFontSize as k, c as l, findParagraph as m, toHTMLElement as n, ol as o, isParagraphNotEditable as p, isParagraphEmpty as q, focusParagraph as r, g as s, transformParagraph as t, ul as u, isParagraph as v, isTextNode as w, setParagraphAttribute as x, elementIndex as y, nodeDepths as z };

//# sourceMappingURL=toolbar-d36dad9c.js.map