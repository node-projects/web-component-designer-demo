const createEmptyElement = ({ nodeName }) => {
  const element = document.createElement(nodeName);
  element.innerHTML = '\u200B';
  return element;
};

var i=()=>{window&&window.getSelection?window.getSelection()?.empty?window.getSelection()?.empty():window.getSelection()?.removeAllRanges&&window.getSelection()?.removeAllRanges():document&&document.selection&&document.selection.empty();},c=()=>window&&window.getSelection?window.getSelection():document&&document.getSelection?document.getSelection():document&&document.selection?document.selection.createRange().text:null,a=e=>{let n=e?.anchorNode;return n?n.nodeType!==Node.TEXT_NODE&&n.nodeType!==Node.COMMENT_NODE?n:n.parentElement:null},u=e=>{d({element:e,collapse:"end"});},g=e=>{d({element:e,collapse:"start"});},d=({element:e,collapse:n})=>{if(!e)return;let t=document.createRange();t.selectNodeContents(e),t.collapse(n==="start"),l(t);},f=({element:e,offset:n})=>{if(!e)return;let t=document.createRange();t.setStart(e,n),l(t);},l=e=>{let n=c();n?.removeAllRanges(),n?.addRange(e),e.detach();},m=({target:e})=>{let t=c()?.getRangeAt(0),o=t?.cloneRange();if(!o||!t)return;let{endContainer:r,endOffset:s}=t;return o.selectNodeContents(e),o.setEnd(r,s),o.toString().length};

const isTextNode = (element) => {
  return (element === null || element === void 0 ? void 0 : element.nodeType) === Node.TEXT_NODE || (element === null || element === void 0 ? void 0 : element.nodeType) === Node.COMMENT_NODE;
};
const toHTMLElement = (element) => {
  return isTextNode(element) ? element.parentElement : element;
};
const elementIndex = (element) => {
  var _a;
  return Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []).indexOf(element);
};
const nodeIndex = (node) => {
  var _a;
  return Array.from(((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) || []).indexOf(node);
};
const nodeDepths = ({ target, paragraph }) => {
  const depths = [nodeIndex(target)];
  if (!paragraph) {
    return depths;
  }
  let parentElement = target.parentElement;
  while (parentElement && !parentElement.isSameNode(paragraph)) {
    depths.push(nodeIndex(parentElement));
    parentElement = parentElement.parentElement;
  }
  return depths.reverse();
};
const findNodeAtDepths = ({ parent, indexDepths }) => {
  const childNode = ((parent === null || parent === void 0 ? void 0 : parent.childNodes) ? Array.from(parent === null || parent === void 0 ? void 0 : parent.childNodes) : [])[indexDepths[0]];
  if (!childNode) {
    return undefined;
  }
  const [, ...rest] = indexDepths;
  if ((rest === null || rest === void 0 ? void 0 : rest.length) <= 0) {
    return childNode;
  }
  return findNodeAtDepths({ parent: childNode, indexDepths: rest });
};

const findParagraph = ({ element, container }) => {
  if (!container) {
    return undefined;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return undefined;
  }
  if (!container.parentNode) {
    return undefined;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return undefined;
  }
  if (parentElement.isEqualNode(container)) {
    return element;
  }
  return findParagraph({ element: parentElement, container });
};
/**
 * <article>
 *   <div>
 *     <span>
 *       => isStartNode = true
 *
 * <article>
 *   <div>
 *     Hello <span>
 *             => isStartNode = false
 */
const isStartNode = ({ element, container }) => {
  if (!container) {
    return false;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return false;
  }
  if (isParagraph({ element, container })) {
    return true;
  }
  // If node is the direct first child of it's parent, we can check the parent until we get the container
  if (nodeIndex(element) === 0) {
    return isStartNode({ element: element.parentElement, container });
  }
  return false;
};
const isParagraph = ({ element, container }) => {
  if (!element) {
    return false;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return false;
  }
  return parentElement === null || parentElement === void 0 ? void 0 : parentElement.isEqualNode(container);
};
const isTargetContainer = ({ target, container }) => target.isEqualNode(container);
const focusParagraph = ({ paragraph }) => {
  if (!isTextNode(paragraph)) {
    toHTMLElement(paragraph).focus();
  }
  u(paragraph);
};
const transformParagraph = ({ elements, paragraph, container, focus = 'first' }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    if (addedNodes.length <= 0) {
      return;
    }
    const { firstChild } = toHTMLElement(addedNodes[focus === 'first' ? 0 : addedNodes.length - 1]);
    u(firstChild);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  const anchor = toHTMLElement(paragraph.previousElementSibling);
  // We delete present paragraph and add the new element and assumes the mutation observer will trigger both delete and add in a single mutation.
  // Thanks to this, only one entry will be added in the undo-redo stack.
  container.removeChild(paragraph);
  if (!anchor) {
    container.prepend(...elements);
    return;
  }
  anchor.after(...elements);
};
const createEmptyParagraph = ({ paragraph, container }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    // Should not happen, fallback
    if (!paragraph) {
      container.append(div);
      return;
    }
    paragraph.after(div);
  });
};
const addParagraph = ({ paragraph, container, fragment }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    paragraph.after(fragment);
  });
};
const createNewEmptyLine = ({ paragraph, range }) => {
  const br = document.createElement('br');
  return insertNodeInRange({ observerRoot: paragraph, range, element: br });
};
const createNewParagraph = ({ container, range, text }) => {
  const div = document.createElement('div');
  div.innerHTML = text;
  return insertNodeInRange({ observerRoot: container, range, element: div });
};
const insertNodeInRange = ({ observerRoot, range, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(observerRoot, { childList: true, subtree: true });
    range.insertNode(element);
  });
};
const prependEmptyText = ({ paragraph }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    paragraph.prepend(text);
  });
};
const addEmptyText = ({ paragraph, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    element.after(text);
  });
};
const isParagraphEmpty = ({ paragraph }) => { var _a; return ['', '\n', '\u200B'].includes((_a = paragraph === null || paragraph === void 0 ? void 0 : paragraph.textContent) === null || _a === void 0 ? void 0 : _a.trim()); };
const isParagraphNotEditable = ({ paragraph }) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.getAttribute('contenteditable')) === 'false';
const isParagraphCode = ({ paragraph }) => {
  // DeckDeckGo web components
  if (paragraph.nodeName.toLowerCase().startsWith('deckgo-')) {
    return true;
  }
  return ['code', 'pre'].includes(paragraph.nodeName.toLowerCase());
};
const isParagraphList = ({ paragraph }) => ['ul', 'ol', 'dl'].includes(paragraph.nodeName.toLowerCase());

const code = {
  text: 'code',
  icon: 'code',
  createParagraphs: async ({ container, paragraph }) => {
    transformParagraph({
      elements: [createEmptyElement({ nodeName: 'code' }), createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};

const h1 = {
  text: 'huge_title',
  icon: `<span class='placeholder'>H1</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h1' })],
    paragraph,
    container
  })
};

const h2 = {
  text: 'large_title',
  icon: `<span class='placeholder'>H2</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h2' })],
    paragraph,
    container
  })
};

const h3 = {
  text: 'small_title',
  icon: `<span class='placeholder'>H3</span>`,
  createParagraphs: async ({ container, paragraph }) => transformParagraph({
    elements: [createEmptyElement({ nodeName: 'h3' })],
    paragraph,
    container
  })
};

const hr = {
  text: 'separator',
  icon: 'hr',
  createParagraphs: async ({ container, paragraph }) => {
    const hr = document.createElement('hr');
    transformParagraph({
      elements: [hr, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container,
      focus: 'last'
    });
  }
};

const img = {
  text: 'image',
  icon: 'img',
  files: {
    accept: 'image/x-png,image/jpeg,image/gif,image/svg+xml,image/webp',
    multiple: false
  },
  createParagraphs: async ({ container, paragraph, files }) => {
    const URL = window.URL || window.webkitURL;
    const imgUrl = URL.createObjectURL(files[0]);
    const img = document.createElement('img');
    img.src = imgUrl;
    img.setAttribute('loading', 'lazy');
    const emptyDiv = createEmptyElement({ nodeName: 'div' });
    transformParagraph({
      elements: [img, emptyDiv],
      paragraph,
      container,
      focus: 'last'
    });
  }
};

const createListItem = () => {
  const item = document.createElement('li');
  item.innerHTML = '\u200B';
  return item;
};
const ul = {
  text: 'list',
  icon: 'ul',
  createParagraphs: async ({ container, paragraph }) => {
    const ul = document.createElement('ul');
    ul.append(createListItem());
    await transformParagraph({
      elements: [ul, createEmptyElement({ nodeName: 'div' })],
      paragraph,
      container
    });
  }
};

const DEFAULT_PALETTE = [
  {
    color: {
      hex: '#8ED1FC',
      rgb: '142,209,252'
    },
    alt: 'Light blue'
  },
  {
    color: {
      hex: '#0693E3',
      rgb: '6,147,227'
    },
    alt: 'Blue'
  },
  {
    color: {
      hex: '#7BDCB5',
      rgb: '123,220,181'
    },
    alt: 'Light green'
  },
  {
    color: {
      hex: '#00D084',
      rgb: '0,208,132'
    },
    alt: 'Green'
  },
  {
    color: {
      hex: '#FCB900',
      rgb: '252,185,0'
    },
    alt: 'Yellow'
  },
  {
    color: {
      hex: '#FF6900',
      rgb: '255,105,0'
    },
    alt: 'Orange'
  },
  {
    color: {
      hex: '#F78DA7',
      rgb: '247,141,167'
    },
    alt: 'Pink'
  },
  {
    color: {
      hex: '#EB144C',
      rgb: '235,20,76'
    },
    alt: 'Red'
  },
  {
    color: {
      hex: '#ffffff',
      rgb: '255,255,255'
    },
    alt: 'White',
    display: {
      borderColor: '#ddd',
      boxShadowColor: '221,221,221'
    }
  },
  {
    color: {
      hex: '#ABB8C3',
      rgb: '171,184,195'
    },
    alt: 'Grey'
  },
  {
    color: {
      hex: '#000000',
      rgb: '0,0,0'
    },
    alt: 'Black'
  }
];

var ToolbarActions;
(function (ToolbarActions) {
  ToolbarActions[ToolbarActions["STYLE"] = 0] = "STYLE";
  ToolbarActions[ToolbarActions["LINK"] = 1] = "LINK";
  ToolbarActions[ToolbarActions["COLOR"] = 2] = "COLOR";
  ToolbarActions[ToolbarActions["ALIGNMENT"] = 3] = "ALIGNMENT";
  ToolbarActions[ToolbarActions["LIST"] = 4] = "LIST";
  ToolbarActions[ToolbarActions["FONT_SIZE"] = 5] = "FONT_SIZE";
  ToolbarActions[ToolbarActions["BACKGROUND_COLOR"] = 6] = "BACKGROUND_COLOR";
})(ToolbarActions || (ToolbarActions = {}));
var ToolbarList;
(function (ToolbarList) {
  ToolbarList["ORDERED"] = "insertOrderedList";
  ToolbarList["UNORDERED"] = "insertUnorderedList";
})(ToolbarList || (ToolbarList = {}));
var ToolbarAlign;
(function (ToolbarAlign) {
  ToolbarAlign["LEFT"] = "left";
  ToolbarAlign["CENTER"] = "center";
  ToolbarAlign["RIGHT"] = "right";
})(ToolbarAlign || (ToolbarAlign = {}));
var ToolbarFontSize;
(function (ToolbarFontSize) {
  ToolbarFontSize["X_SMALL"] = "1";
  ToolbarFontSize["SMALL"] = "2";
  ToolbarFontSize["MEDIUM"] = "3";
  ToolbarFontSize["LARGE"] = "4";
  ToolbarFontSize["X_LARGE"] = "5";
  ToolbarFontSize["XX_LARGE"] = "6";
  ToolbarFontSize["XXX_LARGE"] = "7";
})(ToolbarFontSize || (ToolbarFontSize = {}));

export { isParagraphList as A, isParagraphCode as B, createEmptyParagraph as C, DEFAULT_PALETTE as D, u as E, addParagraph as F, prependEmptyText as G, createNewEmptyLine as H, addEmptyText as I, m as J, createNewParagraph as K, isStartNode as L, a as M, i as N, ToolbarActions as T, code as a, h2 as b, createEmptyElement as c, h3 as d, hr as e, ToolbarList as f, ToolbarAlign as g, h1 as h, img as i, ToolbarFontSize as j, c as k, findParagraph as l, toHTMLElement as m, isParagraphEmpty as n, isParagraphNotEditable as o, focusParagraph as p, g as q, isParagraph as r, isTargetContainer as s, transformParagraph as t, ul as u, isTextNode as v, elementIndex as w, nodeDepths as x, findNodeAtDepths as y, f as z };
