import { h, Fragment, proxyCustomElement, HTMLElement, createEvent } from '@stencil/core/internal/client';
import { d as toHTMLElement, f as findParagraph, i as isParagraph, F as a, G as i } from './paragraph.utils.js';
import { d, p, f, l } from './chunk-MPAE6ITZ.js';
import { f as configStore } from './config.store.js';
import { T as ToolbarActions, a as ToolbarList, b as ToolbarAlign } from './toolbar.js';
import { a as actionUnderline, b as actionItalic, c as actionBold, d as defineCustomElement$2 } from './text.js';
import { f as findStyleNode, g as getBold, a as getItalic, b as getUnderline, c as getStrikeThrough, e as getList, h as getFontSize, i as getContentAlignment, d as defineCustomElement$7 } from './color2.js';
import { I as IconAlignLeft, a as IconAlignCenter, b as IconAlignRight, e as execCommandNative, d as defineCustomElement$9 } from './align.js';
import { r as removeLink, d as defineCustomElement$5 } from './link.js';
import { i as isMobile } from './mobile.utils.js';
import { a as getSelection, g as getRange } from './selection.utils.js';
import { i as i18n } from './i18n.store.js';
import { I as IconUl, a as IconOl } from './ul.js';
import { d as defineCustomElement$b } from './color.js';
import { d as defineCustomElement$a } from './input.js';
import { d as defineCustomElement$8 } from './button.js';
import { d as defineCustomElement$6 } from './font-size.js';
import { d as defineCustomElement$4 } from './list2.js';
import { d as defineCustomElement$3 } from './separator.js';
import { d as defineCustomElement$1 } from './triangle.js';

function execCommandList(selection, action, container) {
  const anchorNode = selection.anchorNode;
  if (!anchorNode) {
    return;
  }
  const anchor = toHTMLElement(findParagraph({ element: anchorNode, container }));
  if (!anchor) {
    return;
  }
  // Did the user select the all list
  if (anchor.nodeName.toLowerCase() === action.type) {
    removeList(anchor);
    return;
  }
  if (!['ol', 'ul', 'dl'].includes(anchor.nodeName.toLowerCase())) {
    createList(anchor, selection, action.type);
    return;
  }
  // Create a brand new list
  cloneList(anchor, selection, action.type);
  removeList(anchor, false);
}
function createList(container, selection, type) {
  const range = selection.getRangeAt(0);
  const fragment = range.extractContents();
  const list = document.createElement(type);
  const li = document.createElement('li');
  li.style.cssText = container.style.cssText;
  li.appendChild(fragment);
  list.appendChild(li);
  range.insertNode(list);
  selection.selectAllChildren(list);
}
function cloneList(container, selection, type) {
  const list = document.createElement(type);
  list.append(...Array.from(container.childNodes));
  Array.from(container.attributes).forEach((attr) => list.setAttribute(attr.nodeName, attr.nodeValue));
  container.parentElement.insertBefore(list, container);
  selection.selectAllChildren(list);
}
function removeList(list, preserveChildren = true) {
  if (list.hasChildNodes() && preserveChildren) {
    Array.from(list.childNodes).forEach((child) => {
      if (child.hasChildNodes() &&
        child.childNodes.length > 1 &&
        child.firstChild.nodeType !== Node.TEXT_NODE &&
        child.firstChild.nodeType !== Node.COMMENT_NODE) {
        const span = document.createElement('span');
        span.append(...Array.from(child.childNodes));
        list.parentElement.insertBefore(span, list);
      }
      else {
        const text = document.createTextNode(child.textContent);
        list.parentElement.insertBefore(text, list);
      }
    });
  }
  list.parentElement.removeChild(list);
}

function execCommandStyle(selection, action, container) {
  const anchor = a(selection);
  if (!anchor) {
    return;
  }
  const sameSelection = anchor && anchor.innerText === selection.toString();
  if (sameSelection &&
    !isParagraph({ element: anchor, container }) &&
    anchor.style[action.style] !== undefined) {
    updateSelection(anchor, action, container);
    return;
  }
  replaceSelection(anchor, action, selection, container);
}
function updateSelection(anchor, action, container) {
  anchor.style[action.style] = getStyleValue(container, action, container);
  cleanChildren(action, anchor);
}
function replaceSelection(anchor, action, selection, container) {
  const range = selection.getRangeAt(0);
  // User selected a all list?
  if (range.commonAncestorContainer &&
    ['ol', 'ul', 'dl'].some((listType) => listType === range.commonAncestorContainer.nodeName.toLowerCase())) {
    updateSelection(range.commonAncestorContainer, action, container);
    return;
  }
  const fragment = range.extractContents();
  const span = createSpan(anchor, action, container);
  span.appendChild(fragment);
  cleanChildren(action, span);
  flattenChildren(action, span);
  range.insertNode(span);
  selection.selectAllChildren(span);
}
function cleanChildren(action, span) {
  if (!span.hasChildNodes()) {
    return;
  }
  // Clean direct (> *) children with same style
  const children = Array.from(span.children).filter((element) => {
    return element.style[action.style] !== undefined && element.style[action.style] !== '';
  });
  if (children && children.length > 0) {
    children.forEach((element) => {
      element.style[action.style] = '';
      if (element.getAttribute('style') === '' || element.style === null) {
        element.removeAttribute('style');
      }
    });
  }
  // Direct children (> *) may have children (*) which need to be cleaned too
  Array.from(span.children).forEach((element) => cleanChildren(action, element));
}
function createSpan(anchor, action, container) {
  const span = document.createElement('span');
  span.style[action.style] = getStyleValue(anchor, action, container);
  return span;
}
// We assume that if the same style is applied, user want actually to remove it (same behavior as in MS Word)
// Note: initial may have no effect on the background-color
function getStyleValue(anchor, action, container) {
  if (!anchor) {
    return action.value;
  }
  if (action.initial(anchor)) {
    return 'initial';
  }
  const style = findStyleNode(anchor, action.style, container);
  if (action.initial(style)) {
    return 'initial';
  }
  return action.value;
}
// We try to not keep <span/> in the tree if we can use text
function flattenChildren(action, span) {
  if (!span.hasChildNodes()) {
    return;
  }
  // Flatten direct (> *) children with no style
  const children = Array.from(span.children).filter((element) => {
    const style = element.getAttribute('style');
    return !style || style === '';
  });
  if (children && children.length > 0) {
    children.forEach((element) => {
      // Can only be flattened if there is no other style applied to a children, like a color to part of a text with a background
      const styledChildren = element.querySelectorAll('[style]');
      if (!styledChildren || styledChildren.length === 0) {
        const text = document.createTextNode(element.textContent);
        element.parentElement.replaceChild(text, element);
      }
    });
    return;
  }
  // Direct children (> *) may have children (*) which need to be flattened too
  Array.from(span.children).forEach((element) => flattenChildren(action, element));
}

function execCommand(selection, action, container) {
  if (!document || !selection) {
    return;
  }
  if (action.cmd === 'style') {
    execCommandStyle(selection, action.detail, container);
  }
  else if (action.cmd === 'list') {
    execCommandList(selection, action.detail, container);
  }
}

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Aformat_color_fill%3A
const IconColor = () => (h("svg", { xmlns: "http://www.w3.org/2000/svg", "enable-background": "new 0 0 24 24", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  h("g", null,
    h("rect", { fill: "none", height: "24", width: "24" })),
  h("g", null,
    h("path", { d: "M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z" }))));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Alink%3A
const IconLink = () => (h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  h("path", { d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z" })));

// Source: https://fonts.google.com/icons?selected=Material%20Icons%20Outlined%3Apalette%3A
const IconPalette = () => (h("svg", { xmlns: "http://www.w3.org/2000/svg", "enable-background": "new 0 0 24 24", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  h("g", null,
    h("rect", { fill: "none", height: "24", width: "24" })),
  h("g", null,
    h("g", null,
      h("g", null,
        h("g", null,
          h("path", { d: "M12,22C6.49,22,2,17.51,2,12S6.49,2,12,2s10,4.04,10,9c0,3.31-2.69,6-6,6h-1.77c-0.28,0-0.5,0.22-0.5,0.5 c0,0.12,0.05,0.23,0.13,0.33c0.41,0.47,0.64,1.06,0.64,1.67C14.5,20.88,13.38,22,12,22z M12,4c-4.41,0-8,3.59-8,8s3.59,8,8,8 c0.28,0,0.5-0.22,0.5-0.5c0-0.16-0.08-0.28-0.14-0.35c-0.41-0.46-0.63-1.05-0.63-1.65c0-1.38,1.12-2.5,2.5-2.5H16 c2.21,0,4-1.79,4-4C20,7.14,16.41,4,12,4z" }),
          h("circle", { cx: "6.5", cy: "11.5", r: "1.5" }),
          h("circle", { cx: "9.5", cy: "7.5", r: "1.5" }),
          h("circle", { cx: "14.5", cy: "7.5", r: "1.5" }),
          h("circle", { cx: "17.5", cy: "11.5", r: "1.5" })))))));

const Style = ({ align, list, switchToolbarActions, disabledTitle, bold, italic, strikethrough, underline, link, onExecCommand, toggleLink }) => {
  const renderSeparator = () => h("stylo-toolbar-separator", null);
  const renderLinkSeparator = () => {
    if (!list && !align) {
      return undefined;
    }
    return renderSeparator();
  };
  const renderListAction = () => {
    return (h("stylo-toolbar-button", { onAction: () => switchToolbarActions(ToolbarActions.LIST), label: i18n.state.toolbar.style_list }, list === ToolbarList.UNORDERED ? h(IconUl, null) : h(IconOl, null)));
  };
  const renderAlignAction = () => {
    if (!configStore.state.toolbar.style.align) {
      return undefined;
    }
    return (h("stylo-toolbar-button", { onAction: () => switchToolbarActions(ToolbarActions.ALIGNMENT), label: i18n.state.toolbar.style_align }, align === ToolbarAlign.LEFT ? (h(IconAlignLeft, null)) : align === ToolbarAlign.CENTER ? (h(IconAlignCenter, null)) : (h(IconAlignRight, null))));
  };
  const renderFontSizeAction = () => {
    if (!configStore.state.toolbar.style.fontSize) {
      return undefined;
    }
    return (h(Fragment, null,
      h("stylo-toolbar-button", { onAction: () => switchToolbarActions(ToolbarActions.FONT_SIZE), label: i18n.state.toolbar.style_font_size },
        h("span", null,
          "A",
          h("small", null, "A"))),
      renderSeparator()));
  };
  const renderColorActions = () => {
    const result = [
      h("stylo-toolbar-button", { onAction: () => switchToolbarActions(ToolbarActions.COLOR), label: i18n.state.toolbar.style_color },
        h(IconPalette, null))
    ];
    if (configStore.state.toolbar.style.backgroundColor) {
      result.push(h("stylo-toolbar-button", { onAction: () => switchToolbarActions(ToolbarActions.BACKGROUND_COLOR), label: i18n.state.toolbar.style_background },
        h(IconColor, null)));
    }
    return result;
  };
  return (h(Fragment, null,
    h("stylo-toolbar-text", { disabledTitle: disabledTitle, bold: bold === 'bold', italic: italic === 'italic', underline: underline === 'underline', strikethrough: strikethrough === 'strikethrough', onExecCommand: ($event) => onExecCommand($event) }),
    renderSeparator(),
    renderFontSizeAction(),
    renderColorActions(),
    renderSeparator(),
    renderAlignAction(),
    renderListAction(),
    renderLinkSeparator(),
    h("stylo-toolbar-button", { onAction: toggleLink, cssClass: link ? 'active' : undefined, label: i18n.state.toolbar.link },
      h(IconLink, null))));
};

const toolbarCss = ":host{direction:ltr;position:absolute;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}div.tools{display:flex;justify-content:center;align-items:center;visibility:hidden;opacity:0;height:0;animation:0s ease 0s 1 normal none running none;transition:opacity 0.1s ease-out;position:absolute;top:var(--actions-top);left:var(--actions-left);right:var(--actions-right);transform:translate(var(--actions-translate-x), var(--actions-translate-y));z-index:var(--stylo-toolbar-zindex, 2);--box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.12);box-shadow:var(--stylo-box-shadow, var(--box-shadow));border:var(--stylo-border);background:var(--stylo-background, var(--white));color:var(--stylo-color, var(--white-contrast));border-radius:var(--stylo-border, 4px);padding:var(--stylo-toolbar-padding, 0 8px);min-width:var(--stylo-toolbar-min-width, 280px)}div.tools.tools-activated{visibility:visible;opacity:1;height:unset;min-height:var(--stylo-toolbar-min-height, 44px)}";

const Toolbar = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.toolbarActivated = createEvent(this, "toolbarActivated", 7);
    this.linkCreated = createEvent(this, "linkCreated", 7);
    this.styleDidChange = createEvent(this, "styleDidChange", 7);
    this.debounceDisplayToolsActivated = d(() => {
      this.displayToolsActivated = true;
      this.toolbarActivated.emit(true);
    });
    this.selection = null;
    this.selectionParagraph = undefined;
    this.anchorLink = null;
    this.rtl = p();
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (['Escape'].includes(code)) {
        this.reset(false);
        return;
      }
      this.styleKeyboardShortcuts($event);
    };
    this.startSelection = ($event) => {
      this.anchorEvent = {
        $event,
        composedPath: $event.composedPath()
      };
    };
    this.toggleLink = () => {
      if (this.link) {
        removeLink(this.containerRef);
        this.reset(true);
      }
      else {
        this.openLink();
      }
    };
    /***
     * The toolbar is already displayed and we want to switch the actions
     */
    this.switchToolbarActions = (actions) => (this.toolbarActions = actions);
    this.onExecCommand = ($event) => {
      this.execCommand($event.detail);
    };
    this.config = undefined;
    this.containerRef = undefined;
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
    this.align = undefined;
    this.list = undefined;
    this.fontSize = undefined;
    this.disabledTitle = false;
    this.toolsActivated = false;
    this.displayToolsActivated = false;
    this.link = false;
    this.toolbarActions = ToolbarActions.STYLE;
    this.toolsPosition = undefined;
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  componentWillLoad() {
    this.initDefaultContentAlign();
    this.applyStandaloneConfig();
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  onContainerRef() {
    if (!this.containerRef) {
      return;
    }
    this.removeListener();
    this.addListener();
  }
  onConfigChange() {
    this.applyStandaloneConfig();
  }
  applyStandaloneConfig() {
    if (!this.config) {
      return;
    }
    configStore.state.toolbar = Object.assign(Object.assign({}, configStore.state.toolbar), this.config);
  }
  styleKeyboardShortcuts($event) {
    const { metaKey, ctrlKey, key } = $event;
    if (!metaKey && !ctrlKey) {
      return;
    }
    if (!['b', 'i', 'u', 'k'].includes(key)) {
      return;
    }
    $event.preventDefault();
    $event.stopPropagation();
    switch (key) {
      case 'b':
        this.execCommand(actionBold);
        break;
      case 'i':
        this.execCommand(actionItalic);
        break;
      case 'u':
        this.execCommand(actionUnderline);
        break;
      case 'k':
        this.openLink();
        break;
    }
  }
  onContextMenu() {
    this.reset(false);
  }
  onSelectionChange() {
    if ([ToolbarActions.COLOR, ToolbarActions.BACKGROUND_COLOR, ToolbarActions.LINK].includes(this.toolbarActions)) {
      return;
    }
    this.displayTools();
  }
  onResize() {
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.reset(true);
  }
  onContainerClick($event) {
    if ([ToolbarActions.COLOR, ToolbarActions.BACKGROUND_COLOR, ToolbarActions.LINK].includes(this.toolbarActions)) {
      return;
    }
    $event.preventDefault();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('mousedown', this.startSelection, { passive: true });
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('touchstart', this.startSelection, { passive: true });
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('keydown', this.onKeyDown);
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('mousedown', this.startSelection);
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('touchstart', this.startSelection);
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('keydown', this.onKeyDown);
  }
  displayTools() {
    let selection = getSelection(this.containerRef);
    if (!this.anchorEvent) {
      this.reset(false);
      return;
    }
    const { $event, composedPath } = this.anchorEvent;
    if (this.containerRef &&
      !this.containerRef.contains($event.target) &&
      !this.containerRef.contains(composedPath[0])) {
      this.reset(false);
      return;
    }
    if (!selection || !selection.toString() || selection.toString().trim().length <= 0) {
      this.reset(false);
      return;
    }
    const activated = this.activateToolbar(selection);
    this.setToolsActivated(activated);
    if (!this.toolsActivated) {
      return;
    }
    this.selection = selection;
    this.selectionParagraph = findParagraph({
      element: !this.selection ? document.activeElement : this.selection.anchorNode,
      container: this.containerRef
    });
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      this.anchorLink = {
        range: range.cloneRange()
      };
      this.setToolbarAnchorPosition();
    }
  }
  setToolbarAnchorPosition() {
    if (!this.tools) {
      return;
    }
    const { $event } = this.anchorEvent;
    const eventX = l($event).clientX;
    const eventY = l($event).clientY;
    const { range } = getRange(this.containerRef);
    const selectionRect = range === null || range === void 0 ? void 0 : range.getBoundingClientRect();
    // Calculate the absolute position on the screen where the container should be (if it's above the selection)
    const targetAbsoluteX = selectionRect
      ? selectionRect.x + selectionRect.width / 2
      : eventX;
    const targetAbsoluteY = selectionRect ? selectionRect.y : eventY;
    const { x, y } = this.el.shadowRoot.host.getBoundingClientRect();
    // calculate the relative position between the containers
    const relativeX = targetAbsoluteX - x;
    const relativeY = targetAbsoluteY - y;
    const position = eventY > 100 ? 'above' : 'under';
    // TODO: this maybe not always be the case that the whole window size could be used for overlay
    const { innerWidth } = window;
    const topOffset = 16;
    const top = position === 'above' ? relativeY - topOffset : relativeY + ((selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.height) || 0) + 8;
    const safeAreaMarginX = 32;
    // Limit overflow right
    const overflowLeft = this.tools.offsetWidth / 2 + safeAreaMarginX > relativeX;
    const fixedLeft = ((selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.left) || eventX) - 40;
    const overflowRight = innerWidth > 0 && fixedLeft > innerWidth - (this.tools.offsetWidth / 2 + safeAreaMarginX);
    const left = overflowRight
      ? `${innerWidth - x - this.tools.offsetWidth - safeAreaMarginX}px`
      : overflowLeft
        ? `${safeAreaMarginX}px`
        : `${relativeX}px`;
    const right = `auto`;
    // To set the position of the tools
    this.toolsPosition = {
      top,
      left,
      right,
      position,
      align: overflowRight ? 'end' : overflowLeft ? 'start' : 'center',
      anchorLeft: overflowLeft
        ? relativeX - safeAreaMarginX
        : overflowRight
          ? relativeX - (innerWidth - safeAreaMarginX - this.tools.offsetWidth)
          : this.tools.offsetWidth / 2
    };
  }
  activateToolbar(selection) {
    const tools = selection && selection.toString() && selection.toString().length > 0;
    if (tools) {
      this.initStyle(selection);
      this.initLink(selection);
    }
    return tools;
  }
  initStyle(selection) {
    if (!selection || selection.rangeCount <= 0) {
      return;
    }
    const content = a(selection);
    if (!content) {
      return;
    }
    this.initStyleForNode(content);
  }
  initStyleForNode(node) {
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
    this.list = undefined;
    this.fontSize = undefined;
    this.initDefaultContentAlign();
    this.findStyle(node);
  }
  initDefaultContentAlign() {
    this.align = this.rtl ? ToolbarAlign.RIGHT : ToolbarAlign.LEFT;
  }
  // We iterate until we find the root container to detect if bold, underline or italic are active
  findStyle(node) {
    if (!node || node instanceof ShadowRoot) {
      return;
    }
    // Just in case
    if (node.nodeName.toUpperCase() === 'HTML' || node.nodeName.toUpperCase() === 'BODY') {
      return;
    }
    if (this.bold === undefined) {
      this.bold = getBold(toHTMLElement(node));
    }
    if (this.italic === undefined) {
      this.italic = getItalic(toHTMLElement(node));
    }
    if (this.underline === undefined) {
      this.underline = getUnderline(toHTMLElement(node));
    }
    if (this.strikethrough === undefined) {
      this.strikethrough = getStrikeThrough(toHTMLElement(node));
    }
    if (this.list === undefined) {
      this.list = getList(toHTMLElement(node));
    }
    if (this.fontSize === undefined) {
      this.fontSize = getFontSize(toHTMLElement(node));
    }
    if (isParagraph({ element: node, container: this.containerRef })) {
      const nodeName = node.nodeName.toUpperCase();
      this.disabledTitle =
        nodeName === 'H1' ||
          nodeName === 'H2' ||
          nodeName === 'H3' ||
          nodeName === 'H4' ||
          nodeName === 'H5' ||
          nodeName === 'H6';
      this.align = getContentAlignment(toHTMLElement(node));
      return;
    }
    this.findStyle(node.parentNode);
  }
  initLink(selection) {
    if (!selection) {
      return;
    }
    let content = selection.anchorNode;
    if (!content) {
      return;
    }
    if (content.nodeType === 3) {
      content = content.parentElement;
    }
    this.link = content.nodeName && content.nodeName.toLowerCase() === 'a';
  }
  /**
   * Reset the inline editor (= hide it) and optionally clear its selection.
   * @param clearSelection
   * @param blurActiveElement
   */
  reset(clearSelection, blurActiveElement) {
    if (clearSelection) {
      i();
    }
    this.setToolsActivated(false);
    if (clearSelection) {
      // We don't want to emit that state a zillion time but only when needed
      this.toolbarActivated.emit(false);
    }
    this.selection = null;
    this.selectionParagraph = null;
    this.toolbarActions = ToolbarActions.STYLE;
    this.anchorLink = null;
    this.link = false;
    if (blurActiveElement &&
      document.activeElement &&
      document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  }
  openLink() {
    this.toolbarActions = ToolbarActions.LINK;
  }
  setToolsActivated(activated) {
    this.toolsActivated = activated;
    if (activated) {
      this.debounceDisplayToolsActivated();
    }
    else {
      this.displayToolsActivated = false;
    }
  }
  execCommand(action) {
    // onSelectionChange is triggered if DOM changes, we still need to detect attributes changes to refresh style
    this.onAttributesChangesInitStyle();
    if (configStore.state.toolbar.command === 'native') {
      execCommandNative(action);
    }
    else {
      execCommand(this.selection, action, this.containerRef);
    }
    const { cmd } = action;
    if (cmd === 'list' || f()) {
      this.reset(true);
    }
    if (!this.selectionParagraph) {
      return;
    }
    this.styleDidChange.emit(toHTMLElement(this.selectionParagraph));
  }
  onAttributesChangesInitStyle() {
    const anchorNode = a(this.selection);
    if (!anchorNode) {
      return;
    }
    const observer = new MutationObserver(() => {
      observer.disconnect();
      this.initStyleForNode(anchorNode);
    });
    observer.observe(anchorNode, { attributes: true });
  }
  render() {
    var _a, _b;
    let classNames = this.displayToolsActivated ? 'tools tools-activated' : 'tools';
    const position = ((_a = this.toolsPosition) === null || _a === void 0 ? void 0 : _a.position) || 'above';
    const style = this.toolsPosition
      ? {
        '--actions-top': `${this.toolsPosition.top}px`,
        '--actions-left': this.toolsPosition.left,
        '--actions-right': this.toolsPosition.right,
        '--actions-translate-x': `${this.toolsPosition.align === 'center' ? '-50%' : '0'}`,
        '--actions-translate-y': `${this.toolsPosition.position === 'above' ? '-100%' : '0'}`
      }
      : undefined;
    return (h("div", { class: classNames, ref: (el) => (this.tools = el), style: style, onClick: ($event) => $event.stopPropagation(), onMouseDown: ($event) => this.onContainerClick($event), onTouchStart: ($event) => this.onContainerClick($event) }, h("stylo-toolbar-triangle", { class: position === 'above' ? 'bottom' : 'top', style: {
        '--stylo-toolbar-triangle-start': `${(_b = this.toolsPosition) === null || _b === void 0 ? void 0 : _b.anchorLeft}px`
      } }), this.renderActions()));
  }
  renderActions() {
    if (this.toolbarActions === ToolbarActions.LINK) {
      return (h("stylo-toolbar-link", { containerRef: this.containerRef, toolbarActions: this.toolbarActions, anchorLink: this.anchorLink, linkCreated: this.linkCreated, onLinkModified: ($event) => this.reset($event.detail), onClose: () => this.reset(false) }));
    }
    if (this.toolbarActions === ToolbarActions.COLOR ||
      this.toolbarActions === ToolbarActions.BACKGROUND_COLOR) {
      return (h("stylo-toolbar-color", { containerRef: this.containerRef, action: this.toolbarActions === ToolbarActions.BACKGROUND_COLOR ? 'background-color' : 'color', onExecCommand: this.onExecCommand, onClose: () => this.reset(false) }));
    }
    if (this.toolbarActions === ToolbarActions.ALIGNMENT) {
      return (h("stylo-toolbar-align", { containerRef: this.containerRef, anchorEvent: this.anchorEvent.$event, align: this.align, onAlignModified: () => this.reset(true) }));
    }
    if (this.toolbarActions === ToolbarActions.LIST) {
      return (h("stylo-toolbar-list", { list: this.list, onExecCommand: this.onExecCommand }));
    }
    if (this.toolbarActions === ToolbarActions.FONT_SIZE) {
      return (h("stylo-toolbar-font-size", { fontSize: this.fontSize, onExecCommand: this.onExecCommand }));
    }
    return (h(Style, { align: this.align, list: this.list, switchToolbarActions: this.switchToolbarActions, bold: this.bold, disabledTitle: this.disabledTitle, italic: this.italic, strikethrough: this.strikethrough, underline: this.underline, link: this.link, onExecCommand: this.onExecCommand, toggleLink: this.toggleLink }));
  }
  get el() { return this; }
  static get watchers() { return {
    "containerRef": ["onContainerRef"],
    "config": ["onConfigChange"]
  }; }
  static get style() { return toolbarCss; }
}, [1, "stylo-toolbar", {
    "config": [16],
    "containerRef": [16],
    "bold": [32],
    "italic": [32],
    "underline": [32],
    "strikethrough": [32],
    "align": [32],
    "list": [32],
    "fontSize": [32],
    "disabledTitle": [32],
    "toolsActivated": [32],
    "displayToolsActivated": [32],
    "link": [32],
    "toolbarActions": [32],
    "toolsPosition": [32]
  }, [[5, "contextmenu", "onContextMenu"], [5, "selectionchange", "onSelectionChange"], [9, "resize", "onResize"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-toolbar", "stylo-color", "stylo-color-input", "stylo-toolbar-align", "stylo-toolbar-button", "stylo-toolbar-color", "stylo-toolbar-font-size", "stylo-toolbar-link", "stylo-toolbar-list", "stylo-toolbar-separator", "stylo-toolbar-text", "stylo-toolbar-triangle"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-toolbar":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Toolbar);
      }
      break;
    case "stylo-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$b();
      }
      break;
    case "stylo-color-input":
      if (!customElements.get(tagName)) {
        defineCustomElement$a();
      }
      break;
    case "stylo-toolbar-align":
      if (!customElements.get(tagName)) {
        defineCustomElement$9();
      }
      break;
    case "stylo-toolbar-button":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
    case "stylo-toolbar-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$7();
      }
      break;
    case "stylo-toolbar-font-size":
      if (!customElements.get(tagName)) {
        defineCustomElement$6();
      }
      break;
    case "stylo-toolbar-link":
      if (!customElements.get(tagName)) {
        defineCustomElement$5();
      }
      break;
    case "stylo-toolbar-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$4();
      }
      break;
    case "stylo-toolbar-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "stylo-toolbar-text":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
    case "stylo-toolbar-triangle":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}
defineCustomElement();

export { Toolbar as T, defineCustomElement as d };
