import { h, proxyCustomElement, HTMLElement, createEvent, Host } from '@stencil/core/internal/client';
import { f as findParagraph, d as toHTMLElement, D as isParagraphNotEditable, a as isParagraphEmpty, E as focusParagraph, c as createEmptyElement, o as g } from './paragraph.utils.js';
import { d, f } from './chunk-MPAE6ITZ.js';
import { f as configStore } from './config.store.js';
import { c as containerStore } from './container.store.js';
import { i as i18n } from './i18n.store.js';
import { i as isMobile } from './mobile.utils.js';
import { a as getSelection } from './selection.utils.js';

// keyCode 229 = input is processing - Japanese entry
// https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
const isKeyboardEnter = ({ code, keyCode }) => ['Enter'].includes(code) && keyCode !== 229;

// Source: https://fonts.google.com/icons?selected=Material%20Icons%3Aadd%3A
const IconAdd = () => (h("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 0 24 24", width: "24px", fill: "currentColor" },
  h("path", { d: "M0 0h24v24H0z", fill: "none" }),
  h("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" })));

const addCss = ":host{display:block;position:absolute;top:var(--actions-top);left:var(--stylo-add-left, 8px);transition:top 0.1s ease;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff}button{display:flex;position:relative;isolation:isolate;overflow:hidden;background:transparent;border:none;outline:none;cursor:pointer;transition:color 0.25s ease-out, background 0.25s ease-out, transform 0.15s ease-out;flex-direction:column;justify-content:center;align-items:center;border-radius:50%;width:1.4rem;height:1.4rem;color:var(--stylo-add-color, var(--medium))}button:active{box-shadow:none;transform:translateX(1px) translateY(1px)}button:hover,button:focus{color:var(--light-contrast)}svg{width:1.2rem;height:1.2rem}";

const Add = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.selectParagraph = createEvent(this, "selectParagraph", 7);
    this.listPlugins = createEvent(this, "listPlugins", 7);
    this.hidePlugins = createEvent(this, "hidePlugins", 7);
    this.debouncePlaceholder = d(() => this.addPlaceholder(), 350);
    /**
     * When "enter" is pressed, create a new paragraph and select it.
     */
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (!['ArrowDown', 'ArrowUp'].includes(code) && !isKeyboardEnter($event)) {
        this.removePlaceholder();
      }
      if (['Backspace', 'Delete'].includes(code)) {
        this.displayOnMutations();
      }
    };
    this.onFocusout = () => {
      // Only if not mobile because the event bubble and is triggered often
      if (!f()) {
        return;
      }
      this.top = undefined;
    };
    this.initParagraph = ({ target, onlyIfEmptyParagraph }) => {
      if (!target) {
        this.hide();
        return;
      }
      const paragraph = findParagraph({
        element: target,
        container: containerStore.state.ref
      });
      this.paragraph = toHTMLElement(paragraph);
      if (!this.paragraph) {
        this.hide();
        return;
      }
      if (isParagraphNotEditable({ paragraph: this.paragraph })) {
        this.hide();
        return;
      }
      if (onlyIfEmptyParagraph && !isParagraphEmpty({ paragraph: this.paragraph })) {
        this.hide();
        return;
      }
      this.top = this.paragraph.offsetTop;
      this.editPlaceholder();
      this.selectParagraph.emit(this.paragraph);
    };
    this.top = undefined;
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.addEventListener('focusout', this.onFocusout);
    this.destroyListener = containerStore.onChange('ref', () => {
      this.removeContainerListener();
      this.addContainerListener();
    });
    this.addContainerListener();
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.removeEventListener('focusout', this.onFocusout);
    this.removeContainerListener();
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  addContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown, { passive: true });
  }
  removeContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  onKeyUp($event) {
    const { code } = $event;
    if (!['ArrowDown', 'ArrowUp', 'Backspace', 'Delete'].includes(code) &&
      !isKeyboardEnter($event)) {
      if (this.top !== undefined) {
        this.hide();
      }
      return;
    }
    if (['ArrowDown', 'ArrowUp'].includes(code)) {
      this.display({ onlyIfEmptyParagraph: false });
      return;
    }
  }
  /**
   * If user press "/" we want to display the list of plugins.
   */
  onBeforeInput({ data }) {
    if (!['/'].includes(data)) {
      this.hidePlugins.emit();
      return;
    }
    if (!this.paragraph || !this.paragraph.isConnected) {
      return;
    }
    if (!isParagraphEmpty({ paragraph: this.paragraph })) {
      this.hidePlugins.emit();
      return;
    }
    this.focusListPlugins();
  }
  /**
   * Hide or display the component, the "plus" button.
   */
  onClick({ target }) {
    var _a;
    // We use the target only if not the container - it can happen for example if the margin is clicked, in such case we want to use the selection
    this.display({
      onlyIfEmptyParagraph: false,
      target: ((_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.isEqualNode(target)) ? undefined : target
    });
  }
  onAddParagraphs({ detail: addedParagraphs }) {
    const { length, [length - 1]: last } = addedParagraphs;
    this.initParagraph({ target: last, onlyIfEmptyParagraph: false });
  }
  hide() {
    this.selectParagraph.emit(undefined);
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.top = undefined;
  }
  display({ onlyIfEmptyParagraph, target }) {
    var _a;
    this.initParagraph({
      target: target !== null && target !== void 0 ? target : (_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode,
      onlyIfEmptyParagraph
    });
  }
  displayOnMutations() {
    const onRender = (_mutations, observer) => {
      observer.disconnect();
      this.display({ onlyIfEmptyParagraph: true });
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, {
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  editPlaceholder() {
    this.removePlaceholder();
    this.debouncePlaceholder();
  }
  addPlaceholder() {
    var _a;
    if (!isParagraphEmpty({ paragraph: this.paragraph })) {
      return;
    }
    if (isParagraphNotEditable({ paragraph: this.paragraph })) {
      return;
    }
    if (!configStore.state.placeholders.includes((_a = this.paragraph) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase())) {
      return;
    }
    const cssBefore = window.getComputedStyle(this.paragraph, ':before');
    const cssAfter = window.getComputedStyle(this.paragraph, ':after');
    const emptyPseudoElement = ['""', 'none'];
    if (!emptyPseudoElement.includes(cssBefore.getPropertyValue('content')) ||
      !emptyPseudoElement.includes(cssAfter.getPropertyValue('content'))) {
      // An external source use :before or :after to style this paragraph, we don't want to add noise in the ui
      return;
    }
    this.paragraph.setAttribute('placeholder', i18n.state.add.placeholder);
  }
  removePlaceholder() {
    var _a;
    const placeholders = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.querySelectorAll('[placeholder]');
    placeholders === null || placeholders === void 0 ? void 0 : placeholders.forEach((element) => element.removeAttribute('placeholder'));
  }
  selectPlugins($event) {
    if (!this.paragraph || !containerStore.state.ref) {
      return;
    }
    $event.stopPropagation();
    if (isParagraphEmpty({ paragraph: this.paragraph }) &&
      !isParagraphNotEditable({ paragraph: this.paragraph })) {
      this.focusListPlugins();
      return;
    }
    focusParagraph({ paragraph: this.paragraph });
    const onRender = (mutations, observer) => {
      observer.disconnect();
      const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
      const div = addedNodes.find((node) => node.nodeName.toLowerCase() === 'div');
      g(div);
      this.listPlugins.emit(div);
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    this.paragraph.after(div);
    this.hide();
  }
  focusListPlugins() {
    focusParagraph({ paragraph: this.paragraph });
    this.listPlugins.emit(this.paragraph);
  }
  render() {
    const style = this.top === undefined ? { display: 'none' } : { '--actions-top': `${this.top}px` };
    return (h(Host, { style: style }, h("button", { type: "button", "aria-label": i18n.state.add.add_element, onClick: ($event) => this.selectPlugins($event), onKeyDown: ($event) => $event.stopPropagation(), onMouseDown: ($event) => $event.stopPropagation(), onTouchStart: ($event) => $event.stopPropagation() }, h(IconAdd, null))));
  }
  static get style() { return addCss; }
}, [1, "stylo-add", {
    "top": [32]
  }, [[5, "keyup", "onKeyUp"], [5, "beforeinput", "onBeforeInput"], [5, "click", "onClick"], [5, "addParagraphs", "onAddParagraphs"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-add"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-add":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Add);
      }
      break;
  } });
}
defineCustomElement();

export { Add as A, defineCustomElement as d, isKeyboardEnter as i };
