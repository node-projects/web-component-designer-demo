import { HTMLElement, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';
import { u, d as defineCustomElement$1 } from './input.js';
import { d } from './chunk-MPAE6ITZ.js';
import { D as DEFAULT_PALETTE } from './palette.js';

const colorCss = ":host{display:flex;align-items:center;flex-wrap:var(--stylo-color-flex-wrap, wrap);overflow:var(--stylo-color-overflow, visible);padding:var(--stylo-color-padding, 8px);width:var(--stylo-color-width, 288px)}button{width:var(--stylo-color-button-width, 28px);height:var(--stylo-color-button-height, 28px);margin:var(--stylo-color-button-margin, 4px);padding:0;outline:var(--stylo-color-button-outline, none);cursor:pointer;border:1px solid var(--stylo-palette-border-color, var(--stylo-palette-color-hex));border-radius:var(--stylo-color-button-border-radius, 2px);background:var(--stylo-palette-color-hex)}button.selected{box-shadow:0 0 4px 4px rgba(var(--stylo-palette-box-shadow-color, var(--stylo-palette-color-rgb)), 0.4)}button:not(.selected):hover,button:not(.selected):focus{box-shadow:0 0 2px 2px rgba(var(--stylo-palette-box-shadow-color, var(--stylo-palette-color-rgb)), 0.4)}";

let Color = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.colorChange = createEvent(this, "colorChange", 7);
    /**
     * The palette of color.
     */
    this.palette = DEFAULT_PALETTE;
    /**
     * An accessibility label for the color input field
     */
    this.inputAlt = 'Input a color (hex)';
    this.selectedColorPalette = false;
    this.debounceInitSelectedColorPalette = d(() => {
      this.selectedColorPalette = this.initSelectedColorPalette();
      this.selectedCustomColorRgb = !this.selectedColorPalette ? this.selectedColorRgb : undefined;
    }, 150);
    this.selectColor = ($event) => {
      const color = $event.detail;
      this.applyColorHexChange(color.hex, color.rgb);
      this.colorChange.emit(color);
    };
  }
  componentWillLoad() {
    this.selectedColorHex = this.colorHex;
    this.selectedColorRgb = this.colorRgb ? this.colorRgb : u(this.colorHex);
    this.selectedColorPalette = this.initSelectedColorPalette();
    if (!this.selectedColorPalette) {
      this.selectedCustomColorRgb = this.selectedColorRgb;
    }
  }
  async onColorHexChange() {
    this.applyColorHexChange(this.colorHex, undefined);
  }
  applyColorHexChange(colorHex, colorRgb) {
    this.selectedColorHex = colorHex;
    this.selectedColorRgb = colorRgb;
    this.debounceInitSelectedColorPalette();
    // Render component again
    this.palette = [...this.palette];
  }
  async onColorRgbChange() {
    this.selectedColorHex = undefined;
    this.selectedColorRgb = this.colorRgb;
    this.debounceInitSelectedColorPalette();
    // Render component again
    this.palette = [...this.palette];
  }
  pickColor(paletteColor) {
    if (!this.palette || this.palette.length <= 0) {
      return;
    }
    this.selectedColorHex = paletteColor.color ? paletteColor.color.hex : undefined;
    this.selectedColorRgb = paletteColor.color ? paletteColor.color.rgb : undefined;
    this.colorChange.emit(paletteColor.color);
    this.selectedColorPalette = true;
    this.selectedCustomColorRgb = undefined;
  }
  isHexColorSelected(element) {
    if (!element || !element.color || !element.color.hex) {
      return false;
    }
    if (!this.selectedColorHex) {
      return false;
    }
    return this.selectedColorHex.toUpperCase() === element.color.hex.toUpperCase();
  }
  isRgbColorSelected(element) {
    if (!element || !element.color || !element.color.rgb) {
      return false;
    }
    if (!this.selectedColorRgb) {
      return false;
    }
    return (this.selectedColorRgb.replace(/\s/g, '').toUpperCase() ===
      element.color.rgb.replace(/\s/g, '').toUpperCase());
  }
  initSelectedColorPalette() {
    if (!this.palette || this.palette.length <= 0) {
      return false;
    }
    const index = this.palette.findIndex((element) => {
      return this.isHexColorSelected(element) || this.isRgbColorSelected(element);
    });
    return index > -1;
  }
  render() {
    return (h(Host, null, this.renderPalette(), this.renderInput()));
  }
  renderPalette() {
    if (this.palette && this.palette.length > 0) {
      return this.palette.map((element) => {
        const style = {
          '--stylo-palette-color-hex': `${element.color.hex}`,
          '--stylo-palette-color-rgb': `${element.color.rgb}`
        };
        if (element.display) {
          style['--stylo-palette-border-color'] = element.display.borderColor;
          style['--stylo-palette-box-shadow-color'] = element.display.boxShadowColor;
        }
        return (h("button", { "aria-label": element.alt, class: this.isHexColorSelected(element) || this.isRgbColorSelected(element)
            ? 'selected'
            : undefined, style: style, onClick: () => this.pickColor(element) }));
      });
    }
    else {
      return undefined;
    }
  }
  renderInput() {
    return (h("stylo-color-input", { colorHex: this.selectedColorHex, colorRgb: this.selectedColorRgb, customColorRgb: this.selectedCustomColorRgb, inputAlt: this.inputAlt, onSelectHexColor: this.selectColor }));
  }
  get el() { return this; }
  static get watchers() { return {
    "colorHex": ["onColorHexChange"],
    "colorRgb": ["onColorRgbChange"]
  }; }
  static get style() { return colorCss; }
};
Color = /*@__PURE__*/ proxyCustomElement(Color, [1, "stylo-color", {
    "palette": [1040],
    "inputAlt": [1, "input-alt"],
    "colorHex": [1, "color-hex"],
    "colorRgb": [1, "color-rgb"],
    "selectedColorHex": [32],
    "selectedColorRgb": [32],
    "selectedColorPalette": [32],
    "selectedCustomColorRgb": [32]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-color", "stylo-color-input"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-color":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Color);
      }
      break;
    case "stylo-color-input":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}
defineCustomElement();

export { Color as C, defineCustomElement as d };
