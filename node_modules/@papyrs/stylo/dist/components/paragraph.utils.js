const createEmptyElement = ({ nodeName }) => {
  const element = document.createElement(nodeName);
  element.innerHTML = '\u200B';
  return element;
};

var i=()=>{window&&window.getSelection?window.getSelection()?.empty?window.getSelection()?.empty():window.getSelection()?.removeAllRanges&&window.getSelection()?.removeAllRanges():document&&document.selection&&document.selection.empty();},c=()=>window&&window.getSelection?window.getSelection():document&&document.getSelection?document.getSelection():document&&document.selection?document.selection.createRange().text:null,a=e=>{let n=e?.anchorNode;return n?n.nodeType!==Node.TEXT_NODE&&n.nodeType!==Node.COMMENT_NODE?n:n.parentElement:null},u=e=>{d({element:e,collapse:"end"});},g=e=>{d({element:e,collapse:"start"});},d=({element:e,collapse:n})=>{if(!e)return;let t=document.createRange();t.selectNodeContents(e),t.collapse(n==="start"),l(t);},f=({element:e,offset:n})=>{if(!e)return;let t=document.createRange();t.setStart(e,n),l(t);},l=e=>{let n=c();n?.removeAllRanges(),n?.addRange(e),e.detach();},m=({target:e})=>{let t=c()?.getRangeAt(0),o=t?.cloneRange();if(!o||!t)return;let{endContainer:r,endOffset:s}=t;return o.selectNodeContents(e),o.setEnd(r,s),o.toString().length};

const isTextNode = (element) => {
  return (element === null || element === void 0 ? void 0 : element.nodeType) === Node.TEXT_NODE || (element === null || element === void 0 ? void 0 : element.nodeType) === Node.COMMENT_NODE;
};
const toHTMLElement = (element) => {
  return isTextNode(element) ? element.parentElement : element;
};
const elementIndex = (element) => {
  var _a;
  return Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []).indexOf(element);
};
const nodeIndex = (node) => {
  var _a;
  return Array.from(((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) || []).indexOf(node);
};
const nodeDepths = ({ target, paragraph }) => {
  const depths = [nodeIndex(target)];
  if (!paragraph) {
    return depths;
  }
  let parentElement = target.parentElement;
  while (parentElement && !parentElement.isSameNode(paragraph)) {
    depths.push(nodeIndex(parentElement));
    parentElement = parentElement.parentElement;
  }
  return depths.reverse();
};
const findNodeAtDepths = ({ parent, indexDepths }) => {
  const childNode = ((parent === null || parent === void 0 ? void 0 : parent.childNodes) ? Array.from(parent === null || parent === void 0 ? void 0 : parent.childNodes) : [])[indexDepths[0]];
  if (!childNode) {
    return undefined;
  }
  const [, ...rest] = indexDepths;
  if ((rest === null || rest === void 0 ? void 0 : rest.length) <= 0) {
    return childNode;
  }
  return findNodeAtDepths({ parent: childNode, indexDepths: rest });
};

const findParagraph = ({ element, container }) => {
  if (!container) {
    return undefined;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return undefined;
  }
  if (!container.parentNode) {
    return undefined;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return undefined;
  }
  if (parentElement.isEqualNode(container)) {
    return element;
  }
  return findParagraph({ element: parentElement, container });
};
/**
 * <article>
 *   <div>
 *     <span>
 *       => isStartNode = true
 *
 * <article>
 *   <div>
 *     Hello <span>
 *             => isStartNode = false
 */
const isStartNode = ({ element, container }) => {
  if (!container) {
    return false;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return false;
  }
  if (isParagraph({ element, container })) {
    return true;
  }
  // If node is the direct first child of it's parent, we can check the parent until we get the container
  if (nodeIndex(element) === 0) {
    return isStartNode({ element: element.parentElement, container });
  }
  return false;
};
const isParagraph = ({ element, container }) => {
  if (!element) {
    return false;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return false;
  }
  return parentElement === null || parentElement === void 0 ? void 0 : parentElement.isEqualNode(container);
};
const isTargetContainer = ({ target, container }) => target.isEqualNode(container);
const focusParagraph = ({ paragraph }) => {
  if (!isTextNode(paragraph)) {
    toHTMLElement(paragraph).focus();
  }
  u(paragraph);
};
const transformParagraph = ({ elements, paragraph, container, focus = 'first' }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    if (addedNodes.length <= 0) {
      return;
    }
    const { firstChild } = toHTMLElement(addedNodes[focus === 'first' ? 0 : addedNodes.length - 1]);
    u(firstChild);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  const anchor = toHTMLElement(paragraph.previousElementSibling);
  // We delete present paragraph and add the new element and assumes the mutation observer will trigger both delete and add in a single mutation.
  // Thanks to this, only one entry will be added in the undo-redo stack.
  container.removeChild(paragraph);
  if (!anchor) {
    container.prepend(...elements);
    return;
  }
  anchor.after(...elements);
};
const createEmptyParagraph = ({ paragraph, container }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    // Should not happen, fallback
    if (!paragraph) {
      container.append(div);
      return;
    }
    paragraph.after(div);
  });
};
const addParagraph = ({ paragraph, container, fragment }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    paragraph.after(fragment);
  });
};
const createNewEmptyLine = ({ paragraph, range }) => {
  const br = document.createElement('br');
  return insertNodeInRange({ observerRoot: paragraph, range, element: br });
};
const createNewParagraph = ({ container, range, text }) => {
  const div = document.createElement('div');
  div.innerHTML = text;
  return insertNodeInRange({ observerRoot: container, range, element: div });
};
const insertNodeInRange = ({ observerRoot, range, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(observerRoot, { childList: true, subtree: true });
    range.insertNode(element);
  });
};
const prependEmptyText = ({ paragraph }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    paragraph.prepend(text);
  });
};
const addEmptyText = ({ paragraph, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    element.after(text);
  });
};
const isParagraphEmpty = ({ paragraph }) => { var _a; return ['', '\n', '\u200B'].includes((_a = paragraph === null || paragraph === void 0 ? void 0 : paragraph.textContent) === null || _a === void 0 ? void 0 : _a.trim()); };
const isParagraphNotEditable = ({ paragraph }) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.getAttribute('contenteditable')) === 'false';
const isParagraphCode = ({ paragraph }) => {
  // DeckDeckGo web components
  if (paragraph.nodeName.toLowerCase().startsWith('deckgo-')) {
    return true;
  }
  return ['code', 'pre'].includes(paragraph.nodeName.toLowerCase());
};
const isParagraphList = ({ paragraph }) => ['ul', 'ol', 'dl'].includes(paragraph.nodeName.toLowerCase());

export { isStartNode as A, a as B, i as C, toHTMLElement as a, isParagraphNotEditable as b, createEmptyElement as c, focusParagraph as d, c as e, findParagraph as f, g, isParagraph as h, isParagraphEmpty as i, isTargetContainer as j, isTextNode as k, elementIndex as l, findNodeAtDepths as m, nodeDepths as n, f as o, isParagraphList as p, isParagraphCode as q, createEmptyParagraph as r, addParagraph as s, transformParagraph as t, u, prependEmptyText as v, createNewEmptyLine as w, addEmptyText as x, m as y, createNewParagraph as z };
