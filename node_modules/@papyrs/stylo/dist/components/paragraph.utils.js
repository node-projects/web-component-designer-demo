const createEmptyElement = ({ nodeName }) => {
  const element = document.createElement(nodeName);
  element.innerHTML = '\u200B';
  return element;
};

var i=()=>{window&&window.getSelection?window.getSelection()?.empty?window.getSelection()?.empty():window.getSelection()?.removeAllRanges&&window.getSelection()?.removeAllRanges():document&&document.selection&&document.selection.empty();},c=()=>window&&window.getSelection?window.getSelection():document&&document.getSelection?document.getSelection():document&&document.selection?document.selection.createRange().text:null,a=e=>{let n=e?.anchorNode;return n?n.nodeType!==Node.TEXT_NODE&&n.nodeType!==Node.COMMENT_NODE?n:n.parentElement:null},u=e=>{d({element:e,collapse:"end"});},g=e=>{d({element:e,collapse:"start"});},d=({element:e,collapse:n})=>{if(!e)return;let t=document.createRange();t.selectNodeContents(e),t.collapse(n==="start"),l(t);},f=({element:e,offset:n})=>{if(!e)return;let t=document.createRange();t.setStart(e,n),l(t);},l=e=>{let n=c();n?.removeAllRanges(),n?.addRange(e),e.detach();},m=({target:e})=>{let t=c()?.getRangeAt(0),o=t?.cloneRange();if(!o||!t)return;let{endContainer:r,endOffset:s}=t;return o.selectNodeContents(e),o.setEnd(r,s),o.toString().length};

const isTextNode = (element) => {
  return (element === null || element === void 0 ? void 0 : element.nodeType) === Node.TEXT_NODE || (element === null || element === void 0 ? void 0 : element.nodeType) === Node.COMMENT_NODE;
};
const toHTMLElement = (element) => {
  return isTextNode(element) ? element.parentElement : element;
};
const elementIndex = (element) => {
  var _a;
  return Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []).indexOf(element);
};
const nodeIndex = (node) => {
  var _a;
  return Array.from(((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) || []).indexOf(node);
};
const nodeDepths = ({ target, paragraph }) => {
  const depths = [nodeIndex(target)];
  if (!paragraph) {
    return depths;
  }
  let parentElement = target.parentElement;
  while (parentElement && !parentElement.isSameNode(paragraph)) {
    depths.push(nodeIndex(parentElement));
    parentElement = parentElement.parentElement;
  }
  return depths.reverse();
};
const findNodeAtDepths = ({ parent, indexDepths }) => {
  const childNode = ((parent === null || parent === void 0 ? void 0 : parent.childNodes) ? Array.from(parent === null || parent === void 0 ? void 0 : parent.childNodes) : [])[indexDepths[0]];
  if (!childNode) {
    return undefined;
  }
  const [, ...rest] = indexDepths;
  if ((rest === null || rest === void 0 ? void 0 : rest.length) <= 0) {
    return childNode;
  }
  return findNodeAtDepths({ parent: childNode, indexDepths: rest });
};
// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories
const isPhrasingContent = (node) => isTextNode(node) ||
  [
    'abbr',
    'audio',
    'b',
    'bdo',
    'br',
    'button',
    'canvas',
    'cite',
    'code',
    'data',
    'datalist',
    'dfn',
    'em',
    'embed',
    'i',
    'iframe',
    'img',
    'input',
    'kbd',
    'label',
    'mark',
    'math',
    'meter',
    'noscript',
    'object',
    'output',
    'picture',
    'progress',
    'q',
    'ruby',
    'samp',
    'script',
    'select',
    'small',
    'span',
    'strong',
    'sub',
    'sup',
    'svg',
    'textarea',
    'time',
    'u',
    'var',
    'video',
    'wbr'
  ].includes(node.nodeName.toLowerCase()) ||
  ['a', 'area', 'del', 'ins', 'map'].includes(node.nodeName.toLowerCase());
const isMetaContent = ({ nodeName }) => ['base', 'link', 'meta', 'noscript', 'script', 'style', 'title'].includes(nodeName.toLowerCase());
const isNodeList = ({ node: { nodeName } }) => ['ul', 'ol', 'dl'].includes(nodeName.toLowerCase());

const findParagraph = ({ element, container }) => {
  if (!container) {
    return undefined;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return undefined;
  }
  if (!container.parentNode) {
    return undefined;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return undefined;
  }
  if (parentElement.isEqualNode(container)) {
    return element;
  }
  return findParagraph({ element: parentElement, container });
};
/**
 * <article>
 *   <div>
 *     <span>
 *       => isStartNode = true
 *
 * <article>
 *   <div>
 *     Hello <span>
 *             => isStartNode = false
 */
const isStartNode = ({ element, container }) => {
  if (!container) {
    return false;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return false;
  }
  if (isParagraph({ element, container })) {
    return true;
  }
  // If node is the direct first child of it's parent, we can check the parent until we get the container
  if (nodeIndex(element) === 0) {
    return isStartNode({ element: element.parentElement, container });
  }
  return false;
};
const isParagraph = ({ element, container }) => {
  if (!element) {
    return false;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return false;
  }
  return parentElement === null || parentElement === void 0 ? void 0 : parentElement.isEqualNode(container);
};
const focusParagraph = ({ paragraph }) => {
  if (!isTextNode(paragraph)) {
    toHTMLElement(paragraph).focus();
  }
  u(paragraph);
};
const transformParagraph = ({ elements, paragraph, container, focus = 'first' }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    if (addedNodes.length <= 0) {
      return;
    }
    const { firstChild } = toHTMLElement(addedNodes[focus === 'first' ? 0 : addedNodes.length - 1]);
    u(firstChild);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  paragraph.replaceWith(...elements);
};
const createEmptyParagraph = ({ paragraph, container }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    // Should not happen, fallback
    if (!paragraph) {
      container.append(div);
      return;
    }
    paragraph.after(div);
  });
};
const addParagraph = ({ paragraph, container, fragment }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    paragraph.after(fragment);
  });
};
const addParagraphs = ({ paragraph, container, nodes }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const mutation = mutations[mutations.length - 1];
    if (!mutation) {
      return;
    }
    const { addedNodes } = mutation;
    const last = addedNodes[addedNodes.length - 1];
    u(last);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  // User has deleted all paragraphs of the container previously
  if (!paragraph) {
    container.append(...nodes);
    return;
  }
  paragraph.after(...nodes);
};
const createNewEmptyLine = ({ paragraph, range }) => {
  const br = document.createElement('br');
  return insertNodeInRange({ observerRoot: paragraph, range, element: br });
};
const createNewParagraph = ({ container, range, text }) => {
  const div = document.createElement('div');
  div.innerHTML = text;
  return insertNodeInRange({ observerRoot: container, range, element: div });
};
const insertNodeInRange = ({ observerRoot, range, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      addObserver.disconnect();
      if (mutations.length === 0) {
        resolve(undefined);
        return;
      }
      const { addedNodes } = mutations[mutations.length - 1];
      if (!addedNodes || addedNodes.length === 0) {
        resolve(undefined);
        return;
      }
      resolve(addedNodes[addedNodes.length - 1]);
    });
    addObserver.observe(observerRoot, { childList: true, subtree: true });
    range.insertNode(element);
  });
};
const prependEmptyText = ({ paragraph }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    paragraph.prepend(text);
  });
};
const addEmptyText = ({ paragraph, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    element.after(text);
  });
};
const isParagraphEmpty = ({ paragraph }) => { var _a; return ['', '\n', '\u200B'].includes((_a = paragraph === null || paragraph === void 0 ? void 0 : paragraph.textContent) === null || _a === void 0 ? void 0 : _a.trim()); };
const isParagraphNotEditable = ({ paragraph }) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.getAttribute('contenteditable')) === 'false';
const isParagraphCode = ({ paragraph }) => {
  // DeckDeckGo web components
  if (paragraph.nodeName.toLowerCase().startsWith('deckgo-')) {
    return true;
  }
  return ['code', 'pre'].includes(paragraph.nodeName.toLowerCase());
};
const setParagraphAttribute = ({ paragraph, attributeName }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((_mutations) => {
      addObserver.disconnect();
      resolve();
    });
    addObserver.observe(paragraph, { attributes: true });
    paragraph.setAttribute(attributeName, '');
  });
};

export { insertNodeInRange as A, isMetaContent as B, nodeIndex as C, isParagraphNotEditable as D, focusParagraph as E, a as F, i as G, c as H, isParagraphEmpty as a, isTextNode as b, createEmptyElement as c, toHTMLElement as d, elementIndex as e, findParagraph as f, findNodeAtDepths as g, f as h, isParagraph as i, isNodeList as j, isParagraphCode as k, createEmptyParagraph as l, addParagraph as m, nodeDepths as n, g as o, prependEmptyText as p, createNewEmptyLine as q, addEmptyText as r, setParagraphAttribute as s, transformParagraph as t, u, m as v, createNewParagraph as w, isStartNode as x, isPhrasingContent as y, addParagraphs as z };
