import { HTMLElement, h, Fragment, proxyCustomElement } from '@stencil/core/internal/client';
import { d, f as f$1, b, w, a } from './chunk-MPAE6ITZ.js';
import { c as configStore, D as DEFAULT_PLUGINS, a as DEFAULT_TOOLBAR, b as DEFAULT_PLACEHOLDERS, d as DEFAULT_TEXT_PARAGRAPHS, e as DEFAULT_EXCLUDE_ATTRIBUTES } from './config.store.js';
import { c as containerStore } from './container.store.js';
import { h as isParagraph, i as isParagraphEmpty, f as findParagraph, j as isTargetContainer, k as isTextNode, a as toHTMLElement, l as elementIndex, n as nodeDepths, m as findNodeAtDepths, o as f, p as isParagraphList, q as isParagraphCode, r as createEmptyParagraph, u, s as addParagraph, v as prependEmptyText, g, w as createNewEmptyLine, x as addEmptyText, y as m, z as createNewParagraph, A as isStartNode } from './paragraph.utils.js';
import { a as getRange, g as getSelection } from './selection.utils.js';
import { c as createStore } from './index2.js';
import { i as i18n } from './i18n.store.js';
import { d as defineCustomElement$h } from './add.js';
import { d as defineCustomElement$g } from './color.js';
import { d as defineCustomElement$f } from './input.js';
import { d as defineCustomElement$e } from './list.js';
import { d as defineCustomElement$d } from './menus.js';
import { d as defineCustomElement$c } from './plugins.js';
import { d as defineCustomElement$b } from './toolbar2.js';
import { d as defineCustomElement$a } from './align.js';
import { d as defineCustomElement$9 } from './button.js';
import { d as defineCustomElement$8 } from './color2.js';
import { d as defineCustomElement$7 } from './font-size.js';
import { d as defineCustomElement$6 } from './link.js';
import { d as defineCustomElement$5 } from './list2.js';
import { d as defineCustomElement$4 } from './separator.js';
import { d as defineCustomElement$3 } from './text.js';
import { d as defineCustomElement$2 } from './triangle.js';

const emitAddParagraphs = ({ editorRef, addedParagraphs }) => emit({ editorRef, detail: addedParagraphs, message: 'addParagraphs' });
const emitDeleteParagraphs = ({ editorRef, removedParagraphs }) => emit({ editorRef, detail: removedParagraphs, message: 'deleteParagraphs' });
const emitUpdateParagraphs = ({ editorRef, updatedParagraphs }) => emit({ editorRef, detail: updatedParagraphs, message: 'updateParagraphs' });
const emit = ({ editorRef, message, detail }) => {
  const $event = new CustomEvent(message, { detail, bubbles: true });
  editorRef === null || editorRef === void 0 ? void 0 : editorRef.dispatchEvent($event);
};

const findAddedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const addedNodes = mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
  return filterAddedParagraphs({ nodes: addedNodes, container });
};
const findAddedNodesParagraphs = ({ mutations, container }) => {
  return mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .filter(({ addedNodes }) => !isParagraph({ element: addedNodes[0], container }))
    .filter(({ addedNodes }) => !isParagraphEmpty({
    paragraph: findParagraph({ element: addedNodes[0], container })
  }));
};
const findRemovedNodesParagraphs = ({ mutations, container }) => {
  return mutations
    .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
    .filter(({ target }) => !isTargetContainer({ target, container }));
};
const findRemovedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  return mutations
    .filter(({ target }) => isTargetContainer({ target, container }))
    .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
    .reduce((acc, { removedNodes, previousSibling }) => {
    const paragraphs = filterRemovedParagraphs({
      nodes: Array.from(removedNodes)
    });
    return [
      ...acc,
      ...paragraphs.map((paragraph) => ({
        paragraph,
        previousSibling: findPreviousElementSibling({ container, previousSibling })
      }))
    ];
  }, []);
};
/**
 * The mutation observer previous sibling can be a #text node. Because we assume every child of the container are HTML elements, we iterate until we find the closest one.
 */
const findPreviousElementSibling = ({ previousSibling, container }) => {
  if (!previousSibling) {
    return undefined;
  }
  if (container.isEqualNode(previousSibling)) {
    return undefined;
  }
  if (!isTextNode(previousSibling)) {
    return previousSibling;
  }
  return findPreviousElementSibling({ previousSibling: previousSibling.previousSibling, container });
};
const findUpdatedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const nodes = mutations.reduce((acc, { target }) => [...acc, target], []);
  return [
    ...new Set(nodes
      .map((node) => findParagraph({ element: node, container }))
      .filter((paragraph) => paragraph !== undefined &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE))
  ];
};
const filterAddedParagraphs = ({ nodes, container }) => {
  return nodes
    .filter((node) => isParagraph({ element: node, container }))
    .filter((paragraph) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE && (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE);
};
// We remove text node, should not happen we only want elements as children of the container
const filterRemovedParagraphs = ({ nodes }) => {
  return nodes
    .filter((paragraph) => !isTextNode(paragraph))
    .map((node) => node);
};
const findSelectionParagraphs = ({ container, filterEmptySelection }) => {
  const { range, selection } = getRange(container);
  if (!range || (filterEmptySelection && (selection === null || selection === void 0 ? void 0 : selection.toString().length) === 0)) {
    return undefined;
  }
  const start = toHTMLElement(findParagraph({ element: range.startContainer, container }));
  const end = toHTMLElement(findParagraph({ element: range.endContainer, container }));
  if (!end || !start || (start === null || start === void 0 ? void 0 : start.isSameNode(end))) {
    return start ? [start] : [];
  }
  if (start.nextElementSibling.isSameNode(end)) {
    return [start, end];
  }
  const nodes = [];
  let next = start.nextElementSibling;
  while (next !== null && !next.isSameNode(end)) {
    nodes.push(toHTMLElement(next));
    next = next.nextElementSibling;
  }
  return [start, ...nodes, end];
};
const filterAttributesMutations = ({ mutations, excludeAttributes }) => {
  const attributeMutations = mutations.filter(({ attributeName }) => attributeName !== null);
  // We consider only single change. If the mutations contains one attribute to exclude, we ignore all the mutations
  // If a web component attribute is updated, e.g theme="ubuntu", the component might update the class of the host
  // In such case, the mutation observer will be triggered twice
  const excludeMutations = attributeMutations.find(({ attributeName }) => excludeAttributes.includes(attributeName));
  if (excludeMutations !== undefined) {
    return [];
  }
  return attributeMutations;
};

class DataEvents {
  constructor() {
    this.stackDataMutations = [];
    this.debounceUpdateInput = d(() => this.updateData(), 500);
    this.onTreeMutation = (mutations) => {
      this.addParagraphs(mutations);
      this.deleteParagraphs(mutations);
      this.updateAddedNodesParagraphs(mutations);
    };
    this.onAttributesMutation = (mutations) => {
      this.updateParagraphs(filterAttributesMutations({
        mutations,
        excludeAttributes: configStore.state.excludeAttributes
      }));
    };
    this.onDataMutation = (mutations) => {
      this.stackDataMutations.push(...mutations);
      this.debounceUpdateInput();
    };
  }
  init({ editorRef }) {
    this.editorRef = editorRef;
    this.treeObserver = new MutationObserver(this.onTreeMutation);
    this.treeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    this.attributesObserver = new MutationObserver(this.onAttributesMutation);
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true, subtree: true });
    this.dataObserver = new MutationObserver(this.onDataMutation);
    this.dataObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.treeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.attributesObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.dataObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  addParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (addedParagraphs.length <= 0) {
      return;
    }
    emitAddParagraphs({ editorRef: this.editorRef, addedParagraphs });
  }
  deleteParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    // Only those the target is the container are paragraphs
    const removedNodes = mutations.reduce((acc, { removedNodes, target }) => {
      if (!target.isEqualNode(containerStore.state.ref)) {
        return acc;
      }
      return [...acc, ...Array.from(removedNodes)];
    }, []);
    // We remove text node, should not happen we only want elements as children of the container
    const removedParagraphs = removedNodes
      .filter((node) => !isTextNode(node))
      .map((node) => toHTMLElement(node));
    if (removedParagraphs.length <= 0) {
      return;
    }
    emitDeleteParagraphs({ editorRef: this.editorRef, removedParagraphs });
  }
  updateAddedNodesParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    this.updateParagraphs([...addedNodesMutations, ...removedNodesMutations]);
  }
  updateData() {
    if (!this.stackDataMutations || this.stackDataMutations.length <= 0) {
      return;
    }
    const mutations = [...this.stackDataMutations];
    this.stackDataMutations = [];
    this.updateParagraphs(mutations);
  }
  updateParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    const updatedParagraphs = findUpdatedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (updatedParagraphs.length <= 0) {
      return;
    }
    emitUpdateParagraphs({ editorRef: this.editorRef, updatedParagraphs });
  }
}

const { state, onChange, reset } = createStore({
  undo: undefined,
  redo: undefined,
  observe: true
});
const undoRedoStore = { state, onChange, reset };

const toUndoRedoSelection = (container) => {
  const { range, selection } = getRange();
  if (!range) {
    return undefined;
  }
  const { anchorNode, focusNode } = selection;
  const startParagraph = toHTMLElement(findParagraph({ element: anchorNode, container }));
  const endParagraph = toHTMLElement(findParagraph({ element: focusNode, container }));
  if (!startParagraph || !endParagraph) {
    return;
  }
  return {
    startIndex: elementIndex(startParagraph),
    startIndexDepths: nodeDepths({
      target: anchorNode,
      paragraph: findParagraph({ element: anchorNode, container })
    }),
    startOffset: selection.anchorOffset,
    endIndex: elementIndex(endParagraph),
    endIndexDepths: nodeDepths({
      target: focusNode,
      paragraph: findParagraph({ element: focusNode, container })
    }),
    endOffset: selection.focusOffset,
    reverse: !anchorNode.isEqualNode(range.startContainer)
  };
};
const redoSelection = ({ selection, container }) => {
  if (!selection) {
    return;
  }
  const { startIndex, startIndexDepths, startOffset, endIndex, endIndexDepths, endOffset, reverse } = selection;
  const startParagraph = container.children[Math.min(startIndex, container.children.length - 1)];
  const endParagraph = container.children[Math.min(endIndex, container.children.length - 1)];
  const startNode = findNodeAtDepths({
    parent: startParagraph,
    indexDepths: startIndexDepths
  });
  const endNode = findNodeAtDepths({
    parent: endParagraph,
    indexDepths: endIndexDepths
  });
  if (!startNode || !endNode) {
    return;
  }
  // Prevent error "DOMException: Failed to execute 'setStart' on 'Range': The offset 7 is larger than the node's length (1)."
  if (startNode.textContent.length < startOffset || endNode.textContent.length < endOffset) {
    return;
  }
  const range = document.createRange();
  if (!reverse) {
    range.setStart(startNode, startOffset);
    range.setEnd(endNode, endOffset);
  }
  else {
    range.setEnd(startNode, startOffset);
    range.setStart(endNode, endOffset);
  }
  const windowSelection = getSelection(container);
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.removeAllRanges();
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.addRange(range);
  range.detach();
};

const stackUndoInput = ({ container, data }) => {
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  undoRedoStore.state.undo.push({
    changes: data.map((undoRedoInput) => ({
      type: 'input',
      target: container,
      data: undoRedoInput
    }))
  });
  undoRedoStore.state.redo = [];
};
const stackUndoParagraphs = ({ container, addRemoveParagraphs, updateParagraphs, selection }) => {
  if (addRemoveParagraphs.length <= 0 && updateParagraphs.length <= 0) {
    return;
  }
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  const changes = {
    changes: [
      {
        type: 'paragraph',
        target: container,
        data: addRemoveParagraphs.map(({ outerHTML, index, mutation }) => ({
          outerHTML,
          mutation,
          index
        }))
      },
      {
        type: 'update',
        target: container,
        data: updateParagraphs
      }
    ],
    selection
  };
  undoRedoStore.state.undo.push(changes);
  undoRedoStore.state.redo = [];
};
const nextUndoChanges = () => nextChange(undoRedoStore.state.undo);
const nextRedoChanges = () => nextChange(undoRedoStore.state.redo);
const nextChange = (changes) => {
  if (!changes) {
    return undefined;
  }
  return changes[changes.length - 1];
};
const undo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.undo = [
    ...undoRedoStore.state.undo.slice(0, undoRedoStore.state.undo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.redo.push(value),
  undoChanges: nextUndoChanges()
});
const redo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.redo = [
    ...undoRedoStore.state.redo.slice(0, undoRedoStore.state.redo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.undo.push(value),
  undoChanges: nextRedoChanges()
});
const undoRedo = async ({ popFrom, pushTo, undoChanges }) => {
  if (!undoChanges) {
    return;
  }
  const currentSelection = toUndoRedoSelection(containerStore.state.ref);
  const { changes, selection } = undoChanges;
  let redoChanges = [];
  for (const undoChange of changes) {
    redoChanges = [await undoRedoChange({ undoChange }), ...redoChanges];
  }
  redoSelection({ container: containerStore.state.ref, selection });
  pushTo({ changes: redoChanges, selection: currentSelection });
  popFrom();
};
const undoRedoChange = async ({ undoChange }) => {
  const { type } = undoChange;
  if (type === 'input') {
    return undoRedoInput({ undoChange });
  }
  if (type === 'paragraph') {
    return undoRedoParagraph({ undoChange });
  }
  return undoRedoUpdate({ undoChange });
};
const undoRedoInput = async ({ undoChange }) => {
  var _a;
  const { data, target } = undoChange;
  const container = toHTMLElement(target);
  const { oldValue, offset: newCaretPosition, index, indexDepths } = data;
  const paragraph = container.children[index];
  let text = findNodeAtDepths({ parent: paragraph, indexDepths });
  if (!text || !isTextNode(text)) {
    // We try to find sibling in case the parent does not yet exist. If we find it, we can replicate such parent for the new text.
    // Useful notably when reverting lists and li.
    const cloneIndexDepths = [...indexDepths];
    cloneIndexDepths.pop();
    let parent = cloneIndexDepths.length <= 0
      ? text
        ? text.parentNode
        : undefined
      : findNodeAtDepths({ parent: paragraph, indexDepths: [...cloneIndexDepths] });
    if (!parent && isTextNode((_a = toHTMLElement(paragraph)) === null || _a === void 0 ? void 0 : _a.lastChild)) {
      text = toHTMLElement(paragraph).lastChild;
    }
    if (!text) {
      if (!parent) {
        parent = await createLast({ paragraph: toHTMLElement(paragraph) || container, container });
      }
      text = await prependText({ parent: toHTMLElement(parent), container });
    }
  }
  const { previousValue } = await updateNodeValue({ text, oldValue, container });
  f({
    element: text,
    offset: Math.min(oldValue.length > newCaretPosition ? newCaretPosition : oldValue.length, text.nodeValue.length)
  });
  return {
    type: 'input',
    target: container,
    data: {
      index,
      indexDepths,
      oldValue: previousValue,
      offset: newCaretPosition + (previousValue.length - oldValue.length)
    }
  };
};
const undoRedoParagraph = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const container = toHTMLElement(target);
  const paragraphs = data;
  let to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML, mutation } = paragraph;
    if (mutation === 'add') {
      await removeNode({ container, index });
      to = [
        {
          outerHTML,
          index,
          mutation: 'remove'
        },
        ...to
      ];
    }
    if (mutation === 'remove') {
      await insertNode({ container, index, outerHTML });
      to = [
        {
          outerHTML,
          mutation: 'add',
          index
        },
        ...to
      ];
    }
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
const undoRedoUpdate = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const paragraphs = data;
  const container = toHTMLElement(target);
  const to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML } = paragraph;
    const { previousOuterHTML } = await updateNode({
      container,
      index,
      outerHTML
    });
    to.push({ index, outerHTML: previousOuterHTML });
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
/**
 * Because we are using indexes to add or remove back and forth elements, we have to wait for changes to be applied to the DOM before iterating to next element to process.
 * That's why the mutation observer and promises.
 */
const insertNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const previousSiblingIndex = index - 1;
  if (previousSiblingIndex === -1) {
    container.insertAdjacentHTML('afterbegin', outerHTML);
    return;
  }
  container.children[Math.min(previousSiblingIndex, container.children.length - 1)].insertAdjacentHTML('afterend', outerHTML);
});
const removeNode = ({ container, index }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const element = container.children[Math.min(index, container.children.length - 1)];
  element === null || element === void 0 ? void 0 : element.parentElement.removeChild(element);
});
const updateNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const paragraph = container.children[Math.min(index, container.children.length - 1)];
  const previousOuterHTML = paragraph.outerHTML;
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve({ previousOuterHTML });
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  paragraph.outerHTML = outerHTML;
});
const prependText = ({ parent, container }) => new Promise((resolve) => {
  const text = document.createTextNode('');
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(text);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  parent.prepend(text);
});
const updateNodeValue = ({ container, oldValue, text }) => new Promise((resolve) => {
  const previousValue = text.nodeValue;
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve({ previousValue });
  });
  changeObserver.observe(container, { characterData: true, subtree: true });
  text.nodeValue = oldValue;
});
const createLast = ({ container, paragraph }) => new Promise((resolve) => {
  var _a;
  const anchor = ((_a = paragraph.lastElementChild) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) !== 'br'
    ? toHTMLElement(paragraph.lastElementChild)
    : document.createElement('span');
  const parent = toHTMLElement(anchor.cloneNode());
  parent.innerHTML = '';
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(parent);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  anchor.after(parent);
});

class EnterEvents {
  constructor() {
    this.onKeyDown = async ($event) => {
      const { code } = $event;
      if (!['Enter'].includes(code)) {
        return;
      }
      await this.createParagraph($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  async createParagraph($event) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchor = toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
    // Create only if we have an anchor otherwise let the browser deals with it
    if (!anchor) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: anchor, container: containerStore.state.ref }));
    // Same as above but should not happen
    if (!paragraph) {
      return;
    }
    // In "list" we use return to create new lines
    if (isParagraphList({ paragraph })) {
      return;
    }
    $event.preventDefault();
    // Extract the rest of the "line" (the paragraph) form the cursor position to end
    range.collapse(true);
    range.setEndAfter(paragraph);
    const fragment = range.cloneContents();
    const isEndOfParagraph = fragment.textContent === '';
    const { shiftKey } = $event;
    if (shiftKey || isParagraphCode({ paragraph })) {
      await this.createLineBreak({ anchor, paragraph, isEndOfParagraph, range });
      return;
    }
    // We created a new paragraph with the cursor at the end aka we pressed "Enter" with the cursor at the end of the paragraph
    if (isEndOfParagraph) {
      const newParagraph = await createEmptyParagraph({
        container: containerStore.state.ref,
        paragraph
      });
      u(newParagraph);
      return;
    }
    await this.createParagraphWithContent({
      range,
      paragraph
    });
  }
  async createParagraphWithContent({ paragraph, range }) {
    // We have to handle undo-redo manually because we want the redo to redo everything in one block
    undoRedoStore.state.observe = false;
    // We undo-redo stack an update of the current paragraph value
    const updateParagraphs = this.toUpdateParagraphs([paragraph]);
    // The new fragment is a div - i.e. is a paragraph
    const moveFragment = range.extractContents();
    const newParagraph = await addParagraph({
      container: containerStore.state.ref,
      paragraph,
      fragment: moveFragment
    });
    // We undo-redo stack the new paragraph to remove it on undo
    const addRemoveParagraphs = this.toAddParagraphs([toHTMLElement(newParagraph)]);
    // If original paragraph is now empty - the all content has been moved to a new paragraph - we add a zero length width otherwise the div has no height
    // We do not need to add this to undo-redo stack
    // Happens for example when user click enter at the begin of the paragraph
    if (paragraph.textContent === '') {
      await prependEmptyText({ paragraph });
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs,
      updateParagraphs
    });
    // We don't move the cursor, we keep the position at the beginning of the new paragraph
    undoRedoStore.state.observe = true;
    g(newParagraph);
  }
  toAddParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph),
      mutation: 'add'
    }));
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph)
    }));
  }
  async createLineBreak({ anchor, paragraph, isEndOfParagraph, range }) {
    undoRedoStore.state.observe = false;
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: this.toUpdateParagraphs([paragraph])
    });
    // Reset range end we do not want to select empty text
    range.setEndAfter(getSelection(containerStore.state.ref).anchorNode);
    const newNode = await createNewEmptyLine({
      paragraph: anchor,
      range
    });
    if (!isEndOfParagraph || !newNode) {
      g(newNode);
      undoRedoStore.state.observe = true;
      return;
    }
    const text = await addEmptyText({
      paragraph,
      element: newNode
    });
    g(text);
    undoRedoStore.state.observe = true;
  }
}

const beforeInputTransformer = [
  {
    match: ({ lastKey, key }) => {
      if (f$1()) {
        return ['‘', '’'].includes(lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) && key.key === ' ';
      }
      if (b()) {
        return (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === null && key.key === '`';
      }
      return (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '`' && key.key === '`';
    },
    transform: () => {
      return document.createElement('mark');
    },
    active: ({ nodeName }) => nodeName.toLowerCase() === 'mark',
    trim: () => (b() && !f$1() ? 0 : '`'.length),
    postTransform: () => replaceBacktick()
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '*' && key.key === '*',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontWeight = 'bold';
      return span;
    },
    active: (parent) => {
      const { fontWeight } = window.getComputedStyle(parent);
      return parseInt(fontWeight) > 400 || fontWeight === 'bold';
    },
    trim: () => '*'.length
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === ' ' && key.key === '_',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontStyle = 'italic';
      return span;
    },
    active: (parent) => {
      const { fontStyle } = window.getComputedStyle(parent);
      return fontStyle === 'italic';
    },
    trim: () => ''.length
  }
];
const transformInput = async ({ $event, transformInput }) => {
  const selection = getSelection(containerStore.state.ref);
  if (!selection) {
    return;
  }
  const { focusNode: target } = selection;
  if (!target) {
    return;
  }
  $event.preventDefault();
  // Disable undo-redo observer as we are about to play with the DOM
  undoRedoStore.state.observe = false;
  const parent = toHTMLElement(target);
  // Check if we can transform or end tag
  if (!canTransform({ target, parent, transformInput })) {
    return;
  }
  // We eiter remove the last character, a *, or split the text around the selection and *
  await updateText({ target, parent, transformInput });
  // We had fun, we can observe again the undo redo store to stack the next bold element we are about to create
  undoRedoStore.state.observe = true;
  await createNode({ target, parent, transformInput });
};
const replaceBacktick = () => {
  if (b()) {
    return Promise.resolve();
  }
  if (w()) {
    return replaceBacktickFirefox();
  }
  return replaceBacktickChrome();
};
/**
 * Firefox renders the new mark and let the backtick in the previous text element
 */
const replaceBacktickFirefox = async () => {
  var _a;
  const markElement = (_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode;
  const previousSibling = markElement === null || markElement === void 0 ? void 0 : markElement.previousSibling;
  if (!previousSibling) {
    return;
  }
  const text = isTextNode(previousSibling) ? previousSibling : previousSibling.firstChild;
  if (text.nodeValue.charAt(text.nodeValue.length - 1) !== '`') {
    return;
  }
  undoRedoStore.state.observe = false;
  await removeLastChar({ target: text });
  undoRedoStore.state.observe = true;
};
/**
 * Chrome renders the backtick in the new mark therefore we have to delete it the new element
 */
const replaceBacktickChrome = () => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async (mutation) => {
      changeObserver.disconnect();
      const target = mutation[0].target;
      undoRedoStore.state.observe = false;
      await replaceChar({ target, searchValue: '`', replaceValue: '' });
      undoRedoStore.state.observe = true;
      u(target);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  });
};
const replaceChar = ({ target, searchValue, replaceValue }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.replace(searchValue, replaceValue);
  });
};
const removeLastChar = ({ target }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(0, target.nodeValue.length - 1);
  });
};
const createNode = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      u((_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const { active, transform } = transformInput;
    if (active(parent)) {
      // We are in a bold node, therefore we want to exit it
      const newText = document.createTextNode('\u200B');
      parent.after(newText);
    }
    else {
      // We create the new node
      const newNode = transform();
      newNode.innerHTML = '\u200B';
      if (target.nextSibling) {
        parent.insertBefore(newNode, target.nextSibling);
      }
      else {
        parent.appendChild(newNode);
      }
    }
  });
};
const canTransform = ({ target, parent, transformInput }) => {
  const index = m({ target });
  // We are typing at the end of the node text, we can transform it
  if (target.nodeValue.length === index) {
    return true;
  }
  // We are typing in the middle of a text node, we can transform it or end it only if not yet transformed
  const { active } = transformInput;
  return !active(parent);
};
const updateText = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const index = m({ target });
    // Exact same length, so we remove the last characters
    if (target.nodeValue.length === index) {
      const changeObserver = new MutationObserver(() => {
        changeObserver.disconnect();
        resolve();
      });
      changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
      target.nodeValue = target.nodeValue.substring(0, target.nodeValue.length - transformInput.trim());
      return;
    }
    // The end results will be text followed by a span bold and then the remaining text
    const newText = await splitText({ target, index, transformInput });
    const changeObserver = new MutationObserver(() => {
      changeObserver.disconnect();
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    if (target.nextSibling) {
      parent.insertBefore(newText, target.nextSibling);
    }
    else {
      parent.appendChild(newText);
    }
  });
};
const splitText = ({ target, index, transformInput }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async () => {
      changeObserver.disconnect();
      const node = await removeChar({ target: newText, index: 1 });
      resolve(node);
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const newText = target.splitText(index - transformInput.trim());
  });
};
const removeChar = ({ target, index }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(index);
  });
};

class InputEvents {
  constructor() {
    this.lastBeforeInput = undefined;
    this.onBeforeInput = async ($event) => {
      await this.preventTextLeaves($event);
      await this.transformInput($event);
    };
    this.onKeyDown = ($event) => {
      // This should be an on keydown listener because Firefox do not provide the same range in before input
      this.deleteContentBackward($event);
    };
  }
  init() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keydown', this.onKeyDown);
  }
  async preventTextLeaves($event) {
    var _a;
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchorNode = selection === null || selection === void 0 ? void 0 : selection.anchorNode;
    if (!containerStore.state.ref.isEqualNode(anchorNode)) {
      return;
    }
    const { data } = $event;
    // User is not typing, for example an image is moved
    if (data === null) {
      return;
    }
    const { startOffset } = range;
    const target = findNodeAtDepths({
      parent: containerStore.state.ref,
      indexDepths: [startOffset]
    });
    // We create a div - i.e. new HTML element - only if the actual target an editable paragraph that accepts text
    if ((_a = configStore.state.textParagraphs) === null || _a === void 0 ? void 0 : _a.includes(target === null || target === void 0 ? void 0 : target.nodeName.toLowerCase())) {
      return;
    }
    // User is typing text at the root of the container therefore the browser will create a text node a direct descendant of the contenteditable
    // This can happen when user types for example before or after an image
    $event.preventDefault();
    const div = await createNewParagraph({
      container: containerStore.state.ref,
      range,
      text: data
    });
    u(div);
  }
  async transformInput($event) {
    var _a;
    const { data } = $event;
    const transformer = beforeInputTransformer.find(({ match }) => match({ key: { key: data }, lastKey: this.lastBeforeInput }));
    if (transformer !== undefined) {
      await transformInput({ $event, transformInput: transformer });
      await ((_a = transformer.postTransform) === null || _a === void 0 ? void 0 : _a.call(transformer));
      this.lastBeforeInput = undefined;
      return;
    }
    this.lastBeforeInput = { key: data };
  }
  deleteContentBackward($event) {
    const { key } = $event;
    if (!['Delete', 'Backspace'].includes(key)) {
      return;
    }
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    // If the commonAncestorContainer is the container then we have selected multiple paragraphs
    if (!containerStore.state.ref.isEqualNode(range === null || range === void 0 ? void 0 : range.commonAncestorContainer)) {
      return;
    }
    // If first char is a zeroWidthSpace and the offset start at the second character, reset range to begin
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    if (zeroWidthSpace) {
      range.setStart(range.startContainer, 0);
    }
    // We don't have a selection that starts at the beginning of an element and paragraph
    if (range.startOffset > 0) {
      return;
    }
    // We don't have a selection that starts at the beginning of a paragraph
    if (!isStartNode({ element: range.startContainer, container: containerStore.state.ref })) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: range.startContainer, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    // Reset range to begin of the paragraph in case it contains children
    const index = elementIndex(paragraph);
    range.setStart(containerStore.state.ref, index);
    $event.preventDefault();
    $event.stopImmediatePropagation();
    range.deleteContents();
  }
}

class TabEvents {
  constructor() {
    this.onKeyDown = ($event) => {
      const { key } = $event;
      if (!['Tab'].includes(key)) {
        return;
      }
      this.catchTab($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  catchTab($event) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const node = selection === null || selection === void 0 ? void 0 : selection.focusNode;
    if (!isTextNode(node)) {
      return;
    }
    $event.preventDefault();
    const span = document.createElement('span');
    span.innerHTML = '\u0009';
    range === null || range === void 0 ? void 0 : range.insertNode(span);
    u(span);
  }
}

class UndoRedoEvents {
  constructor() {
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.undoSelection = undefined;
    this.debounceUpdateInputs = d(() => this.stackUndoInputs(), 350);
    this.onKeydown = async ($event) => {
      const { key, ctrlKey, metaKey, shiftKey } = $event;
      if (key === 'Enter') {
        this.stackUndoInputs();
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && !shiftKey) {
        await this.undo($event);
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && shiftKey) {
        await this.redo($event);
        return;
      }
    };
    this.onKeyup = () => {
      var _a;
      this.onEventUpdateParagraphs((_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode);
    };
    this.onSelectionChange = () => (this.undoSelection = toUndoRedoSelection(containerStore.state.ref));
    this.onToolbarActivated = () => {
      this.copySelectedParagraphs({ filterEmptySelection: true });
    };
    this.onMenuActivated = ({ detail }) => {
      const { paragraph } = detail;
      this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
    };
    this.onSnapshotParagraph = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMouseTouchDown = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMutation = (mutations) => {
      const addRemoveParagraphs = this.onParagraphsMutations(mutations);
      const updateParagraphs = this.onNodesParagraphsMutation(mutations);
      stackUndoParagraphs({
        container: containerStore.state.ref,
        addRemoveParagraphs: addRemoveParagraphs,
        updateParagraphs,
        selection: this.undoSelection
      });
      // We assume that all paragraphs updates do contain attributes and input changes
      if (updateParagraphs.length > 0) {
        return;
      }
      this.onAttributesMutation(mutations);
      this.onCharacterDataMutations(mutations);
    };
  }
  init() {
    var _a, _b, _c, _d, _e;
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.observer = new MutationObserver(this.onMutation);
    this.observe();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.addEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.addEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.addEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.addEventListener('selectionchange', this.onSelectionChange);
    document.addEventListener('toolbarActivated', this.onToolbarActivated);
    document.addEventListener('menuActivated', this.onMenuActivated);
    this.unsubscribe = undoRedoStore.onChange('observe', (observe) => {
      if (observe) {
        // We re-active the selection as if we would have selected a paragraphs because we might need to record next update
        this.copySelectedParagraphs({ filterEmptySelection: false });
        this.undoInputs = undefined;
        this.observe();
        return;
      }
      this.disconnect();
    });
  }
  destroy() {
    var _a, _b, _c, _d, _e, _f;
    this.disconnect();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.removeEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.removeEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.removeEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.removeEventListener('selectionchange', this.onSelectionChange);
    document.removeEventListener('toolbarActivated', this.onToolbarActivated);
    document.removeEventListener('menuActivated', this.onMenuActivated);
    (_f = this.unsubscribe) === null || _f === void 0 ? void 0 : _f.call(this);
  }
  async undo($event) {
    $event.preventDefault();
    if (nextUndoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: undo });
  }
  async redo($event) {
    $event.preventDefault();
    if (nextRedoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: redo });
  }
  stackUndoInputs() {
    this.copySelectedParagraphs({ filterEmptySelection: false });
    if (!this.undoInputs) {
      return;
    }
    stackUndoInput({
      data: this.undoInputs,
      container: containerStore.state.ref
    });
    this.undoInputs = undefined;
  }
  async undoRedo({ undoRedo }) {
    // We skip mutations when we process undo redo
    this.disconnect();
    await undoRedo();
    this.observe();
  }
  observe() {
    this.observer.observe(containerStore.state.ref, {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      subtree: true
    });
  }
  disconnect() {
    var _a;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onEventUpdateParagraphs(target) {
    if (!target) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
  }
  // Copy current paragraphs value to a local state so we can add it to the undo redo global store in case of modifications
  copySelectedParagraphs({ filterEmptySelection }) {
    const paragraphs = findSelectionParagraphs({
      container: containerStore.state.ref,
      filterEmptySelection
    });
    if (!paragraphs) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs(paragraphs);
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph),
      paragraph
    }));
  }
  onCharacterDataMutations(mutations) {
    const characterMutations = mutations.filter(({ oldValue }) => oldValue !== null);
    // No character mutations
    if (characterMutations.length <= 0) {
      return;
    }
    if (!this.undoInputs) {
      this.undoInputs = characterMutations
        .map((mutation) => this.toUndoInput(mutation))
        .filter((undoInput) => undoInput !== undefined);
    }
    if (this.undoInputs.length <= 0) {
      this.undoInputs = undefined;
      return;
    }
    this.debounceUpdateInputs();
  }
  toUndoInput(mutation) {
    const target = mutation.target;
    const newValue = target.nodeValue;
    // Firefox triggers a character mutation that has same previous and new value when we delete a range in deleteContentBackward
    if (newValue === mutation.oldValue) {
      return undefined;
    }
    const paragraph = toHTMLElement(findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph || !target.parentNode) {
      return undefined;
    }
    // We find the list of node indexes of the parent of the modified text
    const depths = nodeDepths({ target, paragraph });
    return {
      oldValue: mutation.oldValue,
      offset: m({ target }) + (mutation.oldValue.length - newValue.length),
      index: elementIndex(paragraph),
      indexDepths: depths
    };
  }
  /**
   * Paragraphs added and removed
   */
  onParagraphsMutations(mutations) {
    const changes = [];
    // New paragraph
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    addedParagraphs.forEach((paragraph) => changes.push({
      outerHTML: this.cleanOuterHTML(paragraph),
      mutation: 'add',
      index: paragraph.previousElementSibling
        ? elementIndex(toHTMLElement(paragraph.previousElementSibling)) + 1
        : 0
    }));
    // Paragraphs removed
    const removedParagraphs = findRemovedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const lowerIndex = Math.min(...removedParagraphs.map(({ previousSibling }) => previousSibling ? elementIndex(toHTMLElement(previousSibling)) + 1 : 0));
    removedParagraphs.forEach(({ paragraph }, index) => {
      const elementIndex = index + (Number.isFinite(lowerIndex) ? lowerIndex : 0);
      const undoParagraph = this.undoUpdateParagraphs.find(({ index }) => index === elementIndex);
      // cleanOuterHTML is only there as fallback, we should find the previous outerHTML value in undoUpdateParagraphs
      return changes.push({
        outerHTML: (undoParagraph === null || undoParagraph === void 0 ? void 0 : undoParagraph.outerHTML) || this.cleanOuterHTML(paragraph),
        mutation: 'remove',
        index: elementIndex
      });
    });
    return changes;
  }
  /**
   * Nodes within paragraphs added and removed.
   *
   * If we stack an update of the paragraph we shall not also stack an "input" update at the same time.
   *
   * @return did update
   */
  onNodesParagraphsMutation(mutations) {
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const needsUpdate = addedNodesMutations.length > 0 || removedNodesMutations.length > 0;
    if (!needsUpdate) {
      return [];
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    // Check that the nodes of the paragraphs to update were not already been added to the undoRedo store in `onParagraphsMutations`
    const filterUndoUpdateParagraphs = this.undoUpdateParagraphs.filter(({ paragraph }) => paragraph.isConnected &&
      addedParagraphs.find((element) => element.isEqualNode(paragraph)) === undefined);
    if (filterUndoUpdateParagraphs.length <= 0) {
      this.copySelectedParagraphs({ filterEmptySelection: true });
      return [];
    }
    this.copySelectedParagraphs({ filterEmptySelection: true });
    this.undoInputs = undefined;
    return filterUndoUpdateParagraphs;
  }
  cleanOuterHTML(paragraph) {
    const clone = paragraph.cloneNode(true);
    clone.removeAttribute('placeholder');
    return clone.outerHTML;
  }
  onAttributesMutation(mutations) {
    const updateParagraphs = findUpdatedParagraphs({
      mutations: filterAttributesMutations({
        mutations,
        excludeAttributes: configStore.state.excludeAttributes
      }),
      container: containerStore.state.ref
    });
    if (updateParagraphs.length <= 0) {
      return;
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return;
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: this.undoUpdateParagraphs,
      selection: this.undoSelection
    });
    this.undoUpdateParagraphs = this.toUpdateParagraphs(updateParagraphs);
  }
}

const injectCSS = ({ rootNode }) => {
  let style = (rootNode === document ? document.head : rootNode).querySelector('style[stylo-editor]');
  if (style !== null) {
    return;
  }
  style = document.createElement('style');
  style.setAttribute('stylo-editor', '');
  style.innerHTML = `
    .stylo-container > * {
      white-space: pre-wrap;
    }

    .stylo-container > *:after {
      content: attr(placeholder);
      color: #6e6d6f;
    }
  `;
  if (rootNode === document) {
    document.head.append(style);
    return;
  }
  rootNode.prepend(style);
};

const editorCss = ":host{display:block}";

let Editor = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.contentEditable = true;
    this.debounceSize = d(() => this.applySize(), 250);
    this.undoRedoEvents = new UndoRedoEvents();
    this.enterEvents = new EnterEvents();
    this.inputEvents = new InputEvents();
    this.tabEvents = new TabEvents();
    this.dataEvents = new DataEvents();
    this.mobile = a();
  }
  componentWillLoad() {
    this.init();
    this.applyConfig();
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', this.debounceSize);
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', this.debounceSize);
    this.destroy();
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onContainerRefChange() {
    this.destroy();
    this.init();
  }
  onConfigChange() {
    this.destroy();
    this.applyConfig();
    this.initEvents();
  }
  applySize() {
    var _a;
    if (a()) {
      return;
    }
    containerStore.state.size = (_a = this.containerRef) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  }
  init() {
    containerStore.state.ref = this.containerRef;
    if (!this.containerRef) {
      return;
    }
    injectCSS({ rootNode: this.containerRef.getRootNode() });
    containerStore.state.ref.classList.add('stylo-container');
    this.containerRefEditable();
    this.applySize();
    this.initEvents();
  }
  /**
   * Observe and init containerref "contenteditable" state. Notably useful in case consumer toggles such state.
   */
  containerRefEditable() {
    var _a;
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.attributesObserver = new MutationObserver((mutations) => {
      const contentEditableChanged = mutations.find(({ attributeName }) => ['contenteditable'].includes(attributeName.toLowerCase()));
      if (!contentEditableChanged) {
        return;
      }
      this.contentEditable = this.isContentEditable();
      if (this.contentEditable) {
        this.initEvents();
        return;
      }
      this.destroy();
    });
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true });
    this.contentEditable = this.isContentEditable();
  }
  isContentEditable() {
    return ['true', ''].includes(this.containerRef.getAttribute('contenteditable'));
  }
  applyConfig() {
    if (!this.config) {
      return;
    }
    const { plugins, toolbar, i18n: customI18n, placeholders, textParagraphs, menus, excludeAttributes } = this.config;
    i18n.state.custom = customI18n === null || customI18n === void 0 ? void 0 : customI18n.custom;
    i18n.state.lang = (customI18n === null || customI18n === void 0 ? void 0 : customI18n.lang) || 'en';
    configStore.state.plugins = plugins || DEFAULT_PLUGINS;
    configStore.state.toolbar = toolbar
      ? Object.assign(Object.assign({}, configStore.state.toolbar), toolbar) : DEFAULT_TOOLBAR;
    configStore.state.placeholders = placeholders || DEFAULT_PLACEHOLDERS;
    configStore.state.textParagraphs = textParagraphs || DEFAULT_TEXT_PARAGRAPHS;
    configStore.state.menus = menus;
    configStore.state.excludeAttributes = [
      ...DEFAULT_EXCLUDE_ATTRIBUTES,
      ...(excludeAttributes || [])
    ];
  }
  destroy() {
    this.undoRedoEvents.destroy();
    this.inputEvents.destroy();
    this.enterEvents.destroy();
    this.tabEvents.destroy();
    this.dataEvents.destroy();
    undoRedoStore.state.undo = [];
    undoRedoStore.state.redo = [];
  }
  initEvents() {
    if (!this.contentEditable) {
      return;
    }
    this.inputEvents.init();
    this.enterEvents.init();
    this.tabEvents.init();
    this.dataEvents.init({ editorRef: this.el });
    this.undoRedoEvents.init();
  }
  render() {
    var _a;
    if (!this.contentEditable) {
      return undefined;
    }
    return (h(Fragment, null, h("stylo-add", null), h("stylo-plugins", null), this.renderToolbar(), ((_a = configStore.state.menus) === null || _a === void 0 ? void 0 : _a.length) && h("stylo-menus", null)));
  }
  renderToolbar() {
    if (this.mobile) {
      return undefined;
    }
    return h("stylo-toolbar", { containerRef: this.containerRef });
  }
  get el() { return this; }
  static get watchers() { return {
    "containerRef": ["onContainerRefChange"],
    "config": ["onConfigChange"]
  }; }
  static get style() { return editorCss; }
};
Editor = /*@__PURE__*/ proxyCustomElement(Editor, [0, "stylo-editor", {
    "config": [16],
    "containerRef": [16],
    "contentEditable": [32]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-editor", "stylo-add", "stylo-color", "stylo-color-input", "stylo-list", "stylo-menus", "stylo-plugins", "stylo-toolbar", "stylo-toolbar-align", "stylo-toolbar-button", "stylo-toolbar-color", "stylo-toolbar-font-size", "stylo-toolbar-link", "stylo-toolbar-list", "stylo-toolbar-separator", "stylo-toolbar-text", "stylo-toolbar-triangle"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-editor":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Editor);
      }
      break;
    case "stylo-add":
      if (!customElements.get(tagName)) {
        defineCustomElement$h();
      }
      break;
    case "stylo-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$g();
      }
      break;
    case "stylo-color-input":
      if (!customElements.get(tagName)) {
        defineCustomElement$f();
      }
      break;
    case "stylo-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$e();
      }
      break;
    case "stylo-menus":
      if (!customElements.get(tagName)) {
        defineCustomElement$d();
      }
      break;
    case "stylo-plugins":
      if (!customElements.get(tagName)) {
        defineCustomElement$c();
      }
      break;
    case "stylo-toolbar":
      if (!customElements.get(tagName)) {
        defineCustomElement$b();
      }
      break;
    case "stylo-toolbar-align":
      if (!customElements.get(tagName)) {
        defineCustomElement$a();
      }
      break;
    case "stylo-toolbar-button":
      if (!customElements.get(tagName)) {
        defineCustomElement$9();
      }
      break;
    case "stylo-toolbar-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
    case "stylo-toolbar-font-size":
      if (!customElements.get(tagName)) {
        defineCustomElement$7();
      }
      break;
    case "stylo-toolbar-link":
      if (!customElements.get(tagName)) {
        defineCustomElement$6();
      }
      break;
    case "stylo-toolbar-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$5();
      }
      break;
    case "stylo-toolbar-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$4();
      }
      break;
    case "stylo-toolbar-text":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "stylo-toolbar-triangle":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const StyloEditor = Editor;
const defineCustomElement = defineCustomElement$1;

export { StyloEditor, defineCustomElement };
