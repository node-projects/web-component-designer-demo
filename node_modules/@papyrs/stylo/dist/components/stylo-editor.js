import { proxyCustomElement, HTMLElement, h, Fragment } from '@stencil/core/internal/client';
import { d, f as f$1, b, w } from './chunk-MPAE6ITZ.js';
import { e as configStore, D as DEFAULT_PLUGINS, f as DEFAULT_TOOLBAR, g as DEFAULT_PLACEHOLDERS, j as DEFAULT_TEXT_PARAGRAPHS, k as DEFAULT_EXCLUDE_ATTRIBUTES, l as DEFAULT_PARAGRAPH_IDENTIFIER } from './config.store.js';
import { c as containerStore } from './container.store.js';
import { i as isParagraph, a as isParagraphEmpty, f as findParagraph, b as isTextNode, d as toHTMLElement, s as setParagraphAttribute, e as elementIndex, n as nodeDepths, g as findNodeAtDepths, h as f, j as isParagraphList, k as isParagraphCode, l as createEmptyParagraph, u, m as addParagraph, p as prependEmptyText, o as g, q as createNewEmptyLine, r as addEmptyText, v as m, w as createNewParagraph, x as isStartNode, y as isPhrasingContent, z as addParagraphs, t as transformParagraph, A as insertNodeInRange, B as isMetaContent } from './paragraph.utils.js';
import { g as getRange, a as getSelection$1, d as deleteRange } from './selection.utils.js';
import { c as createStore } from './index2.js';
import { i as isKeyboardEnter, d as defineCustomElement$h } from './add.js';
import { i as i18n } from './i18n.store.js';
import { i as isMobile } from './mobile.utils.js';
import { d as defineCustomElement$g } from './color.js';
import { d as defineCustomElement$f } from './input.js';
import { d as defineCustomElement$e } from './list.js';
import { d as defineCustomElement$d } from './menus.js';
import { d as defineCustomElement$c } from './plugins.js';
import { d as defineCustomElement$b } from './toolbar2.js';
import { d as defineCustomElement$a } from './align.js';
import { d as defineCustomElement$9 } from './button.js';
import { d as defineCustomElement$8 } from './color2.js';
import { d as defineCustomElement$7 } from './font-size.js';
import { d as defineCustomElement$6 } from './link.js';
import { d as defineCustomElement$5 } from './list2.js';
import { d as defineCustomElement$4 } from './separator.js';
import { d as defineCustomElement$3 } from './text.js';
import { d as defineCustomElement$2 } from './triangle.js';

const emitAddParagraphs = ({ editorRef, addedParagraphs }) => emit({ editorRef, detail: addedParagraphs, message: 'addParagraphs' });
const emitDeleteParagraphs = ({ editorRef, removedParagraphs }) => emit({ editorRef, detail: removedParagraphs, message: 'deleteParagraphs' });
const emitUpdateParagraphs = ({ editorRef, updatedParagraphs }) => emit({ editorRef, detail: updatedParagraphs, message: 'updateParagraphs' });
const emit = ({ editorRef, message, detail }) => {
  const $event = new CustomEvent(message, { detail, bubbles: true });
  editorRef === null || editorRef === void 0 ? void 0 : editorRef.dispatchEvent($event);
};

const findAddedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const addedNodes = mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
  return filterAddedParagraphs({ nodes: addedNodes, container });
};
const findAddedNodesParagraphs = ({ mutations, container }) => {
  return mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .filter(({ addedNodes }) => !isParagraph({ element: addedNodes[0], container }))
    .filter(({ addedNodes }) => !isParagraphEmpty({
    paragraph: findParagraph({ element: addedNodes[0], container })
  }));
};
const hasNodeParagraph = ({ removedNodes, paragraphIdentifier }) => Array.from(removedNodes).find((removedNode) => { var _a; return !isTextNode(removedNode) && ((_a = toHTMLElement(removedNode)) === null || _a === void 0 ? void 0 : _a.hasAttribute(paragraphIdentifier)); }) !== undefined;
const findRemovedNodesParagraphs = ({ mutations, paragraphIdentifier }) => mutations
  .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
  .filter(({ removedNodes }) => !hasNodeParagraph({ removedNodes, paragraphIdentifier }));
const findRemovedParagraphs = ({ mutations, container, paragraphIdentifier }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  return mutations
    .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
    .reduce((acc, { removedNodes, previousSibling }) => {
    const paragraphs = filterRemovedParagraphs({
      nodes: Array.from(removedNodes),
      paragraphIdentifier
    });
    return [
      ...acc,
      ...paragraphs.map((paragraph) => ({
        paragraph,
        previousSibling: findPreviousElementSibling({ container, previousSibling })
      }))
    ];
  }, []);
};
/**
 * The mutation observer previous sibling can be a #text node. Because we assume every child of the container are HTML elements, we iterate until we find the closest one.
 */
const findPreviousElementSibling = ({ previousSibling, container }) => {
  if (!previousSibling) {
    return undefined;
  }
  if (container.isEqualNode(previousSibling)) {
    return undefined;
  }
  if (!isTextNode(previousSibling)) {
    return previousSibling;
  }
  return findPreviousElementSibling({ previousSibling: previousSibling.previousSibling, container });
};
const findUpdatedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const nodes = mutations.reduce((acc, { target }) => [...acc, target], []);
  return [
    ...new Set(nodes
      .map((node) => findParagraph({ element: node, container }))
      .filter((paragraph) => paragraph !== undefined &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE))
  ];
};
const filterAddedParagraphs = ({ nodes, container }) => {
  return nodes
    .filter((node) => isParagraph({ element: node, container }))
    .filter((paragraph) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE && (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE);
};
const filterRemovedParagraphs = ({ nodes, paragraphIdentifier }) => {
  return nodes
    .filter((paragraph) => !isTextNode(paragraph))
    .map((node) => node)
    .filter((element) => element === null || element === void 0 ? void 0 : element.hasAttribute(paragraphIdentifier));
};
const findSelectionParagraphs = ({ container, filterEmptySelection }) => {
  const { range, selection } = getRange(container);
  if (!range || (filterEmptySelection && (selection === null || selection === void 0 ? void 0 : selection.toString().length) === 0)) {
    return undefined;
  }
  const start = toHTMLElement(findParagraph({ element: range.startContainer, container }));
  const end = toHTMLElement(findParagraph({ element: range.endContainer, container }));
  if (!end || !start || (start === null || start === void 0 ? void 0 : start.isSameNode(end))) {
    return start ? [start] : [];
  }
  if (start.nextElementSibling.isSameNode(end)) {
    return [start, end];
  }
  const nodes = [];
  let next = start.nextElementSibling;
  while (next !== null && !next.isSameNode(end)) {
    nodes.push(toHTMLElement(next));
    next = next.nextElementSibling;
  }
  return [start, ...nodes, end];
};
const filterAttributesMutations = ({ mutations, excludeAttributes }) => {
  const attributeMutations = mutations.filter(({ attributeName }) => attributeName !== null);
  // We consider only single change. If the mutations contains one attribute to exclude, we ignore all the mutations
  // If a web component attribute is updated, e.g theme="ubuntu", the component might update the class of the host
  // In such case, the mutation observer will be triggered twice
  const excludeMutations = attributeMutations.find(({ attributeName }) => excludeAttributes.includes(attributeName));
  if (excludeMutations !== undefined) {
    return [];
  }
  return attributeMutations;
};

class DataEvents {
  constructor() {
    this.stackDataMutations = [];
    this.debounceUpdateInput = d(() => this.updateData(), 500);
    this.onTreeMutation = async (mutations) => {
      const addedParagraphs = await this.addParagraphs(mutations);
      this.deleteParagraphs(mutations);
      this.updateAddedNodesParagraphs({ addedParagraphs, mutations });
    };
    this.onAttributesMutation = (mutations) => {
      this.updateParagraphs({
        mutations: filterAttributesMutations({
          mutations,
          excludeAttributes: configStore.state.attributes.exclude
        })
      });
    };
    this.onDataMutation = (mutations) => {
      this.stackDataMutations.push(...mutations);
      this.debounceUpdateInput();
    };
  }
  init({ editorRef }) {
    this.editorRef = editorRef;
    this.treeObserver = new MutationObserver(this.onTreeMutation);
    this.treeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    this.attributesObserver = new MutationObserver(this.onAttributesMutation);
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true, subtree: true });
    this.dataObserver = new MutationObserver(this.onDataMutation);
    this.dataObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.treeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.attributesObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.dataObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  async addParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (addedParagraphs.length <= 0) {
      return [];
    }
    await Promise.all(addedParagraphs.map((paragraph) => setParagraphAttribute({
      paragraph,
      attributeName: configStore.state.attributes.paragraphIdentifier
    })));
    emitAddParagraphs({ editorRef: this.editorRef, addedParagraphs });
    return addedParagraphs;
  }
  deleteParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    const removedNodes = mutations.reduce((acc, { removedNodes }) => [...acc, ...Array.from(removedNodes)], []);
    const removedParagraphs = removedNodes
      .filter((node) => !isTextNode(node))
      .filter((removedNode) => addedNodes.find((addedNode) => addedNode.isEqualNode(removedNode)) === undefined)
      .map((node) => toHTMLElement(node))
      .filter((element) => element === null || element === void 0 ? void 0 : element.hasAttribute(configStore.state.attributes.paragraphIdentifier));
    if (removedParagraphs.length <= 0) {
      return;
    }
    emitDeleteParagraphs({ editorRef: this.editorRef, removedParagraphs });
  }
  updateAddedNodesParagraphs({ mutations, addedParagraphs }) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    this.updateParagraphs({
      mutations: [...addedNodesMutations, ...removedNodesMutations],
      addedParagraphs
    });
  }
  updateData() {
    if (!this.stackDataMutations || this.stackDataMutations.length <= 0) {
      return;
    }
    const mutations = [...this.stackDataMutations];
    this.stackDataMutations = [];
    this.updateParagraphs({ mutations });
  }
  updateParagraphs({ mutations, addedParagraphs = [] }) {
    if (!containerStore.state.ref) {
      return;
    }
    const updatedParagraphs = findUpdatedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (updatedParagraphs.length <= 0) {
      return;
    }
    // Browser might report an update for a node that might have just been added. We do not consider these as updates.
    // Useful when client persist paragraphs because the updated node might not be persisted yet since it was just added and emitted as such.
    const justAdded = (element) => addedParagraphs.find((addedParagraph) => addedParagraph.isSameNode(element)) !==
      undefined;
    const existingUpdatedParagraphs = updatedParagraphs.filter((element) => !justAdded(element));
    if (existingUpdatedParagraphs.length <= 0) {
      return;
    }
    emitUpdateParagraphs({ editorRef: this.editorRef, updatedParagraphs: existingUpdatedParagraphs });
  }
}

const { state, onChange, reset } = createStore({
  undo: undefined,
  redo: undefined,
  observe: true
});
const undoRedoStore = { state, onChange, reset };

const toUndoRedoSelection = (container) => {
  const { range, selection } = getRange();
  if (!range) {
    return undefined;
  }
  const { anchorNode, focusNode } = selection;
  const startParagraph = toHTMLElement(findParagraph({ element: anchorNode, container }));
  const endParagraph = toHTMLElement(findParagraph({ element: focusNode, container }));
  if (!startParagraph || !endParagraph) {
    return;
  }
  return {
    startIndex: elementIndex(startParagraph),
    startIndexDepths: nodeDepths({
      target: anchorNode,
      paragraph: findParagraph({ element: anchorNode, container })
    }),
    startOffset: selection.anchorOffset,
    endIndex: elementIndex(endParagraph),
    endIndexDepths: nodeDepths({
      target: focusNode,
      paragraph: findParagraph({ element: focusNode, container })
    }),
    endOffset: selection.focusOffset,
    reverse: !anchorNode.isEqualNode(range.startContainer)
  };
};
const redoSelection = ({ selection, container }) => {
  if (!selection) {
    return;
  }
  const { startIndex, startIndexDepths, startOffset, endIndex, endIndexDepths, endOffset, reverse } = selection;
  const startParagraph = container.children[Math.min(startIndex, container.children.length - 1)];
  const endParagraph = container.children[Math.min(endIndex, container.children.length - 1)];
  const startNode = findNodeAtDepths({
    parent: startParagraph,
    indexDepths: startIndexDepths
  });
  const endNode = findNodeAtDepths({
    parent: endParagraph,
    indexDepths: endIndexDepths
  });
  if (!startNode || !endNode) {
    return;
  }
  // Prevent error "DOMException: Failed to execute 'setStart' on 'Range': The offset 7 is larger than the node's length (1)."
  if (startNode.textContent.length < startOffset || endNode.textContent.length < endOffset) {
    return;
  }
  const range = document.createRange();
  if (!reverse) {
    range.setStart(startNode, startOffset);
    range.setEnd(endNode, endOffset);
  }
  else {
    range.setEnd(startNode, startOffset);
    range.setStart(endNode, endOffset);
  }
  const windowSelection = getSelection$1(container);
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.removeAllRanges();
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.addRange(range);
  range.detach();
};

const stackUndoInput = ({ container, data }) => {
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  undoRedoStore.state.undo.push({
    changes: data.map((undoRedoInput) => ({
      type: 'input',
      target: container,
      data: undoRedoInput
    }))
  });
  undoRedoStore.state.redo = [];
};
const stackUndoParagraphs = ({ container, addRemoveParagraphs, updateParagraphs, selection }) => {
  if (addRemoveParagraphs.length <= 0 && updateParagraphs.length <= 0) {
    return;
  }
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  const changes = {
    changes: [
      {
        type: 'paragraph',
        target: container,
        data: addRemoveParagraphs.map(({ outerHTML, index, mutation }) => ({
          outerHTML,
          mutation,
          index
        }))
      },
      {
        type: 'update',
        target: container,
        data: updateParagraphs
      }
    ],
    selection
  };
  undoRedoStore.state.undo.push(changes);
  undoRedoStore.state.redo = [];
};
const nextUndoChanges = () => nextChange(undoRedoStore.state.undo);
const nextRedoChanges = () => nextChange(undoRedoStore.state.redo);
const nextChange = (changes) => {
  if (!changes) {
    return undefined;
  }
  return changes[changes.length - 1];
};
const undo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.undo = [
    ...undoRedoStore.state.undo.slice(0, undoRedoStore.state.undo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.redo.push(value),
  undoChanges: nextUndoChanges()
});
const redo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.redo = [
    ...undoRedoStore.state.redo.slice(0, undoRedoStore.state.redo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.undo.push(value),
  undoChanges: nextRedoChanges()
});
const undoRedo = async ({ popFrom, pushTo, undoChanges }) => {
  if (!undoChanges) {
    return;
  }
  const currentSelection = toUndoRedoSelection(containerStore.state.ref);
  const { changes, selection } = undoChanges;
  let redoChanges = [];
  for (const undoChange of changes) {
    redoChanges = [await undoRedoChange({ undoChange }), ...redoChanges];
  }
  redoSelection({ container: containerStore.state.ref, selection });
  pushTo({ changes: redoChanges, selection: currentSelection });
  popFrom();
};
const undoRedoChange = async ({ undoChange }) => {
  const { type } = undoChange;
  if (type === 'input') {
    return undoRedoInput({ undoChange });
  }
  if (type === 'paragraph') {
    return undoRedoParagraph({ undoChange });
  }
  return undoRedoUpdate({ undoChange });
};
const undoRedoInput = async ({ undoChange }) => {
  var _a;
  const { data, target } = undoChange;
  const container = toHTMLElement(target);
  const { oldValue, offset: newCaretPosition, index, indexDepths } = data;
  const paragraph = container.children[index];
  let text = findNodeAtDepths({ parent: paragraph, indexDepths });
  if (!text || !isTextNode(text)) {
    // We try to find sibling in case the parent does not yet exist. If we find it, we can replicate such parent for the new text.
    // Useful notably when reverting lists and li.
    const cloneIndexDepths = [...indexDepths];
    cloneIndexDepths.pop();
    let parent = cloneIndexDepths.length <= 0
      ? text
        ? text.parentNode
        : undefined
      : findNodeAtDepths({ parent: paragraph, indexDepths: [...cloneIndexDepths] });
    if (!parent && isTextNode((_a = toHTMLElement(paragraph)) === null || _a === void 0 ? void 0 : _a.lastChild)) {
      text = toHTMLElement(paragraph).lastChild;
    }
    if (!text) {
      if (!parent) {
        parent = await createLast({ paragraph: toHTMLElement(paragraph) || container, container });
      }
      text = await prependText({ parent: toHTMLElement(parent), container });
    }
  }
  const { previousValue } = await updateNodeValue({ text, oldValue, container });
  f({
    element: text,
    offset: Math.max(Math.min(oldValue.length > newCaretPosition ? newCaretPosition : oldValue.length, text.nodeValue.length), 0)
  });
  return {
    type: 'input',
    target: container,
    data: {
      index,
      indexDepths: nodeDepths({ target: text !== null && text !== void 0 ? text : target, paragraph }),
      oldValue: previousValue,
      offset: newCaretPosition + (previousValue.length - oldValue.length)
    }
  };
};
const undoRedoParagraph = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const container = toHTMLElement(target);
  const paragraphs = data;
  let to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML, mutation } = paragraph;
    if (mutation === 'add') {
      await removeNode({ container, index });
      to = [
        {
          outerHTML,
          index,
          mutation: 'remove'
        },
        ...to
      ];
    }
    if (mutation === 'remove') {
      await insertNode({ container, index, outerHTML });
      to = [
        {
          outerHTML,
          mutation: 'add',
          index
        },
        ...to
      ];
    }
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
const undoRedoUpdate = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const paragraphs = data;
  const container = toHTMLElement(target);
  const to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML } = paragraph;
    const { previousOuterHTML } = await updateNode({
      container,
      index,
      outerHTML
    });
    to.push({ index, outerHTML: previousOuterHTML });
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
/**
 * Because we are using indexes to add or remove back and forth elements, we have to wait for changes to be applied to the DOM before iterating to next element to process.
 * That's why the mutation observer and promises.
 */
const insertNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const previousSiblingIndex = index - 1;
  if (previousSiblingIndex === -1) {
    container.insertAdjacentHTML('afterbegin', outerHTML);
    return;
  }
  container.children[Math.min(previousSiblingIndex, container.children.length - 1)].insertAdjacentHTML('afterend', outerHTML);
});
const removeNode = ({ container, index }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const element = container.children[Math.min(index, container.children.length - 1)];
  element === null || element === void 0 ? void 0 : element.parentElement.removeChild(element);
});
const updateNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const paragraph = container.children[Math.min(index, container.children.length - 1)];
  const previousOuterHTML = paragraph.outerHTML;
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve({ previousOuterHTML });
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  paragraph.outerHTML = outerHTML;
});
const prependText = ({ parent, container }) => new Promise((resolve) => {
  const text = document.createTextNode('');
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(text);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  parent.prepend(text);
});
const updateNodeValue = ({ container, oldValue, text }) => new Promise((resolve) => {
  const previousValue = text.nodeValue;
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve({ previousValue });
  });
  changeObserver.observe(container, { characterData: true, subtree: true });
  text.nodeValue = oldValue;
});
const createLast = ({ container, paragraph }) => new Promise((resolve) => {
  var _a;
  const anchor = ((_a = paragraph.lastElementChild) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) !== 'br'
    ? toHTMLElement(paragraph.lastElementChild)
    : document.createElement('span');
  const parent = toHTMLElement(anchor.cloneNode());
  parent.innerHTML = '';
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(parent);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  anchor.after(parent);
});

class EnterEvents {
  constructor() {
    this.onKeyDown = async ($event) => {
      if (!isKeyboardEnter($event)) {
        return;
      }
      await this.createParagraph($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  async createParagraph($event) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchor = toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
    // Create only if we have an anchor otherwise let the browser deals with it
    if (!anchor) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: anchor, container: containerStore.state.ref }));
    // Same as above but should not happen
    if (!paragraph) {
      return;
    }
    // In "list" we use return to create new lines
    if (isParagraphList({ paragraph })) {
      return;
    }
    $event.preventDefault();
    // We undo-redo stack an update of the current paragraph value
    const undoParagraphs = this.toUpdateParagraphs([paragraph]);
    deleteRange(range);
    // Extract the rest of the "line" (the paragraph) form the cursor position to end
    range.collapse(true);
    range.setEndAfter(paragraph);
    const fragment = range.cloneContents();
    const isEndOfParagraph = fragment.textContent === '';
    const { shiftKey } = $event;
    if (shiftKey || isParagraphCode({ paragraph })) {
      await this.createLineBreak({ anchor, paragraph, isEndOfParagraph, range, undoParagraphs });
      return;
    }
    // We created a new paragraph with the cursor at the end aka we pressed "Enter" with the cursor at the end of the paragraph
    if (isEndOfParagraph) {
      const newParagraph = await createEmptyParagraph({
        container: containerStore.state.ref,
        paragraph
      });
      u(newParagraph);
      return;
    }
    await this.createParagraphWithContent({
      range,
      paragraph,
      undoParagraphs
    });
  }
  async createParagraphWithContent({ paragraph, range, undoParagraphs }) {
    // We have to handle undo-redo manually because we want the redo to redo everything in one block
    undoRedoStore.state.observe = false;
    // The new fragment is a div - i.e. is a paragraph
    const moveFragment = range.extractContents();
    const newParagraph = await addParagraph({
      container: containerStore.state.ref,
      paragraph,
      fragment: moveFragment
    });
    // We undo-redo stack the new paragraph to remove it on undo
    const addRemoveParagraphs = this.toAddParagraphs([toHTMLElement(newParagraph)]);
    // If original paragraph is now empty - the all content has been moved to a new paragraph - we add a zero length width otherwise the div has no height
    // We do not need to add this to undo-redo stack
    // Happens for example when user click enter at the begin of the paragraph
    if (paragraph.textContent === '') {
      await prependEmptyText({ paragraph });
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs,
      updateParagraphs: undoParagraphs
    });
    // We don't move the cursor, we keep the position at the beginning of the new paragraph
    undoRedoStore.state.observe = true;
    g(newParagraph);
  }
  toAddParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph),
      mutation: 'add'
    }));
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph)
    }));
  }
  async createLineBreak({ anchor, paragraph, isEndOfParagraph, range, undoParagraphs }) {
    undoRedoStore.state.observe = false;
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: undoParagraphs
    });
    // Reset range end we do not want to select empty text
    range.setEndAfter(getSelection$1(containerStore.state.ref).anchorNode);
    const newNode = await createNewEmptyLine({
      paragraph: anchor,
      range
    });
    if (!isEndOfParagraph || !newNode) {
      g(newNode);
      undoRedoStore.state.observe = true;
      return;
    }
    const text = await addEmptyText({
      paragraph,
      element: newNode
    });
    g(text);
    undoRedoStore.state.observe = true;
  }
}

const beforeInputTransformer = [
  {
    match: ({ lastKey, key }) => {
      if (f$1()) {
        return ['‘', '’'].includes(lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) && key.key === ' ';
      }
      if (b()) {
        return (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === null && key.key === '`';
      }
      return (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '`' && key.key === '`';
    },
    transform: () => {
      return document.createElement('mark');
    },
    active: ({ nodeName }) => nodeName.toLowerCase() === 'mark',
    trim: () => (b() && !f$1() ? 0 : '`'.length),
    postTransform: () => replaceBacktick()
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '*' && key.key === '*',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontWeight = 'bold';
      return span;
    },
    active: (parent) => {
      const { fontWeight } = window.getComputedStyle(parent);
      return parseInt(fontWeight) > 400 || fontWeight === 'bold';
    },
    trim: () => '*'.length
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === ' ' && key.key === '_',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontStyle = 'italic';
      return span;
    },
    active: (parent) => {
      const { fontStyle } = window.getComputedStyle(parent);
      return fontStyle === 'italic';
    },
    trim: () => ''.length
  }
];
const transformInput = async ({ $event, transformInput }) => {
  const selection = getSelection$1(containerStore.state.ref);
  if (!selection) {
    return;
  }
  const { focusNode: target } = selection;
  if (!target) {
    return;
  }
  $event.preventDefault();
  // Disable undo-redo observer as we are about to play with the DOM
  undoRedoStore.state.observe = false;
  const parent = toHTMLElement(target);
  // Check if we can transform or end tag
  if (!canTransform({ target, parent, transformInput })) {
    return;
  }
  // We eiter remove the last character, a *, or split the text around the selection and *
  await updateText({ target, parent, transformInput });
  // We had fun, we can observe again the undo redo store to stack the next bold element we are about to create
  undoRedoStore.state.observe = true;
  await createNode({ target, parent, transformInput });
};
const replaceBacktick = () => {
  if (b()) {
    return Promise.resolve();
  }
  if (w()) {
    return replaceBacktickFirefox();
  }
  return replaceBacktickChrome();
};
/**
 * Firefox renders the new mark and let the backtick in the previous text element
 */
const replaceBacktickFirefox = async () => {
  var _a;
  const markElement = (_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode;
  const previousSibling = markElement === null || markElement === void 0 ? void 0 : markElement.previousSibling;
  if (!previousSibling) {
    return;
  }
  const text = isTextNode(previousSibling) ? previousSibling : previousSibling.firstChild;
  if (text.nodeValue.charAt(text.nodeValue.length - 1) !== '`') {
    return;
  }
  undoRedoStore.state.observe = false;
  await removeLastChar({ target: text });
  undoRedoStore.state.observe = true;
};
/**
 * Chrome renders the backtick in the new mark therefore we have to delete it the new element
 */
const replaceBacktickChrome = () => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async (mutation) => {
      changeObserver.disconnect();
      const target = mutation[0].target;
      undoRedoStore.state.observe = false;
      await replaceChar({ target, searchValue: '`', replaceValue: '' });
      undoRedoStore.state.observe = true;
      u(target);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  });
};
const replaceChar = ({ target, searchValue, replaceValue }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.replace(searchValue, replaceValue);
  });
};
const removeLastChar = ({ target }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(0, target.nodeValue.length - 1);
  });
};
const createNode = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      u((_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const { active, transform } = transformInput;
    if (active(parent)) {
      // We are in a bold node, therefore we want to exit it
      const newText = document.createTextNode('\u200B');
      parent.after(newText);
    }
    else {
      // We create the new node
      const newNode = transform();
      newNode.innerHTML = '\u200B';
      if (target.nextSibling) {
        parent.insertBefore(newNode, target.nextSibling);
      }
      else {
        parent.appendChild(newNode);
      }
    }
  });
};
const canTransform = ({ target, parent, transformInput }) => {
  const index = m({ target });
  // We are typing at the end of the node text, we can transform it
  if (target.nodeValue.length === index) {
    return true;
  }
  // We are typing in the middle of a text node, we can transform it or end it only if not yet transformed
  const { active } = transformInput;
  return !active(parent);
};
const updateText = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const index = m({ target });
    // Exact same length, so we remove the last characters
    if (target.nodeValue.length === index) {
      const changeObserver = new MutationObserver(() => {
        changeObserver.disconnect();
        resolve();
      });
      changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
      target.nodeValue = target.nodeValue.substring(0, target.nodeValue.length - transformInput.trim());
      return;
    }
    // The end results will be text followed by a span bold and then the remaining text
    const newText = await splitText({ target, index, transformInput });
    const changeObserver = new MutationObserver(() => {
      changeObserver.disconnect();
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    if (target.nextSibling) {
      parent.insertBefore(newText, target.nextSibling);
    }
    else {
      parent.appendChild(newText);
    }
  });
};
const splitText = ({ target, index, transformInput }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async () => {
      changeObserver.disconnect();
      const node = await removeChar({ target: newText, index: 1 });
      resolve(node);
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const newText = target.splitText(index - transformInput.trim());
  });
};
const removeChar = ({ target, index }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(index);
  });
};

class InputEvents {
  constructor() {
    this.lastBeforeInput = undefined;
    this.onBeforeInput = async ($event) => {
      await this.preventTextLeaves($event);
      await this.transformInput($event);
    };
    this.onKeyDown = ($event) => {
      // This should be an on keydown listener because Firefox do not provide the same range in before input
      this.deleteSelection($event);
    };
  }
  init() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keydown', this.onKeyDown);
  }
  async preventTextLeaves($event) {
    var _a;
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchorNode = selection === null || selection === void 0 ? void 0 : selection.anchorNode;
    if (!containerStore.state.ref.isEqualNode(anchorNode)) {
      return;
    }
    const { data } = $event;
    // User is not typing, for example an image is moved
    if (data === null) {
      return;
    }
    const { startOffset } = range;
    const target = findNodeAtDepths({
      parent: containerStore.state.ref,
      indexDepths: [startOffset]
    });
    // We create a div - i.e. new HTML element - only if the actual target is not an editable paragraph that accepts text
    if ((_a = configStore.state.textParagraphs) === null || _a === void 0 ? void 0 : _a.includes(target === null || target === void 0 ? void 0 : target.nodeName.toLowerCase())) {
      // We set the range to the start of the target because if we don't, the browser might create a text element before the target anyway
      range.setStart(target, 0);
      return;
    }
    // User is typing text at the root of the container therefore the browser will create a text node a direct descendant of the contenteditable
    // This can happen when user types for example before or after an image
    $event.preventDefault();
    const div = await createNewParagraph({
      container: containerStore.state.ref,
      range,
      text: data
    });
    u(div);
  }
  async transformInput($event) {
    var _a;
    const { data } = $event;
    const transformer = beforeInputTransformer.find(({ match }) => match({ key: { key: data }, lastKey: this.lastBeforeInput }));
    if (transformer !== undefined) {
      await transformInput({ $event, transformInput: transformer });
      await ((_a = transformer.postTransform) === null || _a === void 0 ? void 0 : _a.call(transformer));
      this.lastBeforeInput = undefined;
      return;
    }
    this.lastBeforeInput = { key: data };
  }
  deleteSelection($event) {
    const { key } = $event;
    if (!['Delete', 'Backspace'].includes(key)) {
      return;
    }
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    // If the commonAncestorContainer is the container then we have selected multiple paragraphs
    if (!containerStore.state.ref.isEqualNode(range === null || range === void 0 ? void 0 : range.commonAncestorContainer)) {
      return;
    }
    // If first char is a zeroWidthSpace and the offset start at the second character, reset range to begin
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    if (zeroWidthSpace) {
      range.setStart(range.startContainer, 0);
    }
    // We don't have a selection that starts at the beginning of an element and paragraph
    if (range.startOffset > 0) {
      return;
    }
    // We don't have a selection that starts at the beginning of a paragraph
    if (!isStartNode({ element: range.startContainer, container: containerStore.state.ref })) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: range.startContainer, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    // Reset range to begin of the paragraph in case it contains children
    range.setStartBefore(paragraph);
    $event.preventDefault();
    $event.stopImmediatePropagation();
    range.deleteContents();
  }
}

class PasteEvents {
  constructor() {
    this.onPaste = async ($event) => {
      const pasteHTML = $event.clipboardData.getData('text/html');
      const div = document.createElement('div');
      div.innerHTML = pasteHTML;
      // User either paste a non-html content or paste text with adapt style - i.e. paste text/plain within a paragraph
      if (div.children.length <= 0) {
        return;
      }
      const { range, selection } = getRange(containerStore.state.ref);
      if (!range) {
        return;
      }
      const anchor = toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
      // No anchor so we let the browser deals with it
      if (!anchor) {
        return;
      }
      $event.preventDefault();
      // Undefined if user has removed all paragraphs of the container previously
      const paragraph = toHTMLElement(findParagraph({ element: anchor, container: containerStore.state.ref }));
      this.cleanAttributes(div);
      this.cleanMetas(div);
      const notOnlyText = Array.from(div.childNodes).find((node) => !isPhrasingContent(node)) !== undefined;
      deleteRange(range);
      // If there is only text nodes and span, we consider the paste content as part of a paragraph. e.g. copy/paste a text and a link
      if (!notOnlyText) {
        // addParagraphs fallbacks to container append - this happens in case user delete all the content before parsing
        if (!paragraph) {
          addParagraphs({
            paragraph,
            container: containerStore.state.ref,
            nodes: [div]
          });
          return;
        }
        await this.insertNodes({ range, div });
        return;
      }
      const elements = Array.from(div.childNodes).map((node) => {
        if (isTextNode(node) || node.nodeName.toLowerCase().trim() === 'span') {
          const div = document.createElement('div');
          div.appendChild(node);
          return div;
        }
        return node;
      });
      const empty = isParagraphEmpty({ paragraph });
      if (empty) {
        transformParagraph({
          elements,
          paragraph,
          container: containerStore.state.ref
        });
        return;
      }
      // Extract the rest of the "line" (the paragraph) form the cursor position to end
      const moveFragment = this.splitCurrentParagraph({
        range,
        paragraph
      });
      addParagraphs({
        paragraph,
        container: containerStore.state.ref,
        nodes: [...elements, ...(moveFragment !== undefined ? [moveFragment] : [])]
      });
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('paste', this.onPaste);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('paste', this.onPaste);
  }
  async insertNodes({ range, div }) {
    // convert to fragment to add all nodes at the range position
    const fragment = document.createDocumentFragment();
    fragment.append(...Array.from(div.childNodes));
    const last = await insertNodeInRange({
      observerRoot: containerStore.state.ref,
      range,
      element: fragment
    });
    u(last);
  }
  splitCurrentParagraph({ range, paragraph }) {
    if (!paragraph) {
      return undefined;
    }
    range.collapse(true);
    range.setEndAfter(paragraph);
    return range.extractContents();
  }
  cleanAttributes(div) {
    const attributes = [
      ...new Set([...configStore.state.attributes.exclude, 'class', 'style'])
    ];
    const cleanAttr = ({ element, attributes }) => {
      for (const attr of attributes) {
        element.removeAttribute(attr);
      }
    };
    const children = div.querySelectorAll(attributes.map((attr) => `[${attr}]`).join(','));
    for (const child of Array.from(children)) {
      cleanAttr({ element: child, attributes });
    }
    return div;
  }
  // clean all meta, style and title pasted tags
  cleanMetas(div) {
    const metas = Array.from(div.children).filter((node) => isMetaContent(node));
    for (const element of metas) {
      element.parentElement.removeChild(element);
    }
    return div;
  }
}

class PlaceholderEvents {
  constructor() {
    this.onSelectParagraph = ({ detail }) => {
      var _a, _b, _c, _d, _e, _f;
      const firstParagraph = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.firstElementChild;
      const secondParagraph = (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.children[1];
      const first = firstParagraph && detail && detail.isEqualNode(firstParagraph);
      const second = secondParagraph && detail && detail.isEqualNode(secondParagraph);
      (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.removeEventListener('keydown', this.onKeyChange);
      (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.removeEventListener('keyup', this.onKeyChange);
      if (first || second) {
        (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.addEventListener('keydown', this.onKeyChange);
        (_f = containerStore.state.ref) === null || _f === void 0 ? void 0 : _f.addEventListener('keyup', this.onKeyChange);
      }
      this.classesEmpty();
      this.cleanEmpty();
    };
    this.onKeyChange = () => {
      var _a;
      const paragraph = findParagraph({
        element: (_a = getSelection()) === null || _a === void 0 ? void 0 : _a.anchorNode,
        container: containerStore.state.ref
      });
      if (!paragraph || isTextNode(paragraph)) {
        return;
      }
      // Workaround: add a bit of delay if user enters and deletes text quickly in the first paragraphs to detect the classes empty
      setTimeout(() => this.toggleClassEmpty(paragraph), 250);
    };
  }
  init({ editorRef }) {
    var _a, _b;
    this.editorRef = editorRef;
    (_a = this.editorRef) === null || _a === void 0 ? void 0 : _a.addEventListener('selectParagraph', this.onSelectParagraph);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('focusin', this.onSelectParagraph, { passive: true });
    this.classesEmpty();
  }
  destroy() {
    var _a, _b;
    (_a = this.editorRef) === null || _a === void 0 ? void 0 : _a.removeEventListener('selectParagraph', this.onSelectParagraph);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('focusin', this.onSelectParagraph);
  }
  classesEmpty() {
    var _a, _b;
    const firstParagraph = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.firstElementChild;
    const secondParagraph = (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.children[1];
    this.classEmpty(firstParagraph);
    this.classEmpty(secondParagraph);
  }
  classEmpty(element) {
    if (!element) {
      return;
    }
    const paragraph = findParagraph({
      element,
      container: containerStore.state.ref
    });
    if (!paragraph || isTextNode(paragraph)) {
      return;
    }
    this.toggleClassEmpty(paragraph);
  }
  toggleClassEmpty(paragraph) {
    var _a;
    const { classList, nodeName } = paragraph;
    if (!configStore.state.textParagraphs.includes(nodeName.toLowerCase())) {
      classList.remove('stylo-placeholder-empty');
      return;
    }
    const empty = isParagraphEmpty({ paragraph });
    const index = elementIndex(paragraph);
    // We add a placeholder for the title if empty.
    // We can display a placeholder for the second element if there are no other paragraphs, a bit weird to display a placeholder if user has began typing in another paragraph
    if (empty && (index === 0 || ((_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.children.length) <= 2)) {
      classList.add('stylo-placeholder-empty');
      return;
    }
    classList.remove('stylo-placeholder-empty');
  }
  /**
   * If a paragraph is added between the two first placeholder the new div might be created with a copy of this class so we clean it
   */
  cleanEmpty() {
    var _a;
    const elements = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.stylo-empty');
    const others = Array.from(elements || []).filter((element) => elementIndex(element) > 1);
    for (const other of others) {
      other.classList.remove('stylo-empty');
    }
  }
}

class TabEvents {
  constructor() {
    this.onKeyDown = ($event) => {
      const { key, shiftKey } = $event;
      if (!['Tab'].includes(key) || shiftKey) {
        return;
      }
      this.catchTab($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  catchTab($event) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    $event.preventDefault();
    const node = selection === null || selection === void 0 ? void 0 : selection.focusNode;
    if (!isTextNode(node)) {
      const paragraph = findParagraph({
        element: node,
        container: containerStore.state.ref
      });
      if (paragraph !== undefined) {
        this.createTabulation({ range });
        return;
      }
      return;
    }
    this.createTabulation({ range });
  }
  createTabulation({ range }) {
    const span = document.createElement('span');
    span.innerHTML = '\u0009';
    range === null || range === void 0 ? void 0 : range.insertNode(span);
    u(span);
  }
}

class UndoRedoEvents {
  constructor() {
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.undoSelection = undefined;
    this.debounceUpdateInputs = d(() => this.stackUndoInputs(), 350);
    this.onKeydown = async ($event) => {
      const { key, ctrlKey, metaKey, shiftKey } = $event;
      if (isKeyboardEnter($event)) {
        this.stackUndoInputs();
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && !shiftKey) {
        await this.undo($event);
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && shiftKey) {
        await this.redo($event);
        return;
      }
      if (key === 'Backspace') {
        this.stackBackspace();
      }
    };
    this.onKeyup = () => {
      var _a;
      this.onEventUpdateParagraphs((_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode);
    };
    this.onSelectionChange = () => (this.undoSelection = toUndoRedoSelection(containerStore.state.ref));
    this.onToolbarActivated = () => {
      this.copySelectedParagraphs({ filterEmptySelection: true });
    };
    this.onMenuActivated = ({ detail }) => {
      const { paragraph } = detail;
      this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
    };
    this.onSnapshotParagraph = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMouseTouchDown = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMutation = (mutations) => {
      const addRemoveParagraphs = this.onParagraphsMutations(mutations);
      const updateParagraphs = this.onNodesParagraphsMutation(mutations);
      stackUndoParagraphs({
        container: containerStore.state.ref,
        addRemoveParagraphs: addRemoveParagraphs,
        updateParagraphs,
        selection: this.undoSelection
      });
      // We assume that all paragraphs updates do contain attributes and input changes
      if (updateParagraphs.length > 0) {
        return;
      }
      this.onAttributesMutation(mutations);
      this.onCharacterDataMutations(mutations);
    };
  }
  init() {
    var _a, _b, _c, _d, _e;
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.observer = new MutationObserver(this.onMutation);
    this.observe();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.addEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.addEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.addEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.addEventListener('selectionchange', this.onSelectionChange);
    document.addEventListener('toolbarActivated', this.onToolbarActivated);
    document.addEventListener('menuActivated', this.onMenuActivated);
    this.unsubscribe = undoRedoStore.onChange('observe', (observe) => {
      if (observe) {
        // We re-active the selection as if we would have selected a paragraphs because we might need to record next update
        this.copySelectedParagraphs({ filterEmptySelection: false });
        this.undoInputs = undefined;
        this.observe();
        return;
      }
      this.disconnect();
    });
  }
  destroy() {
    var _a, _b, _c, _d, _e, _f;
    this.disconnect();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.removeEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.removeEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.removeEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.removeEventListener('selectionchange', this.onSelectionChange);
    document.removeEventListener('toolbarActivated', this.onToolbarActivated);
    document.removeEventListener('menuActivated', this.onMenuActivated);
    (_f = this.unsubscribe) === null || _f === void 0 ? void 0 : _f.call(this);
  }
  async undo($event) {
    $event.preventDefault();
    if (nextUndoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: undo });
  }
  async redo($event) {
    $event.preventDefault();
    if (nextRedoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: redo });
  }
  stackUndoInputs() {
    this.copySelectedParagraphs({ filterEmptySelection: false });
    if (!this.undoInputs) {
      return;
    }
    stackUndoInput({
      data: this.undoInputs,
      container: containerStore.state.ref
    });
    this.undoInputs = undefined;
  }
  // When user hits backspace at the begin of a paragraph we should stack previous paragraph for update and current one because it will be removed
  stackBackspace() {
    var _a;
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    // Begin of paragraph?
    if (!(range.startOffset === 0 || zeroWidthSpace)) {
      return;
    }
    const anchorNode = (_a = getSelection$1(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode;
    if (!anchorNode) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({
      element: anchorNode,
      container: containerStore.state.ref
    }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([
      ...(paragraph.previousElementSibling
        ? [paragraph.previousElementSibling]
        : []),
      paragraph
    ]);
  }
  async undoRedo({ undoRedo }) {
    // We skip mutations when we process undo redo
    this.disconnect();
    await undoRedo();
    this.observe();
  }
  observe() {
    this.observer.observe(containerStore.state.ref, {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      subtree: true
    });
  }
  disconnect() {
    var _a;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onEventUpdateParagraphs(target) {
    if (!target) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
  }
  // Copy current paragraphs value to a local state so we can add it to the undo redo global store in case of modifications
  copySelectedParagraphs({ filterEmptySelection }) {
    const paragraphs = findSelectionParagraphs({
      container: containerStore.state.ref,
      filterEmptySelection
    });
    if (!paragraphs) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs(paragraphs);
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: this.cleanOuterHTML(paragraph),
      index: elementIndex(paragraph),
      paragraph
    }));
  }
  onCharacterDataMutations(mutations) {
    const characterMutations = mutations.filter(({ oldValue }) => oldValue !== null);
    // No character mutations
    if (characterMutations.length <= 0) {
      return;
    }
    if (!this.undoInputs) {
      this.undoInputs = characterMutations
        .map((mutation) => this.toUndoInput(mutation))
        .filter((undoInput) => undoInput !== undefined);
    }
    if (this.undoInputs.length <= 0) {
      this.undoInputs = undefined;
      return;
    }
    this.debounceUpdateInputs();
  }
  toUndoInput(mutation) {
    const target = mutation.target;
    const newValue = target.nodeValue;
    // Firefox triggers a character mutation that has same previous and new value when we delete a range in deleteContentBackward
    if (newValue === mutation.oldValue) {
      return undefined;
    }
    const paragraph = toHTMLElement(findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph || !target.parentNode) {
      return undefined;
    }
    // We find the list of node indexes of the parent of the modified text
    const depths = nodeDepths({ target, paragraph });
    return {
      oldValue: mutation.oldValue,
      offset: m({ target }) + (mutation.oldValue.length - newValue.length),
      index: elementIndex(paragraph),
      indexDepths: depths
    };
  }
  /**
   * Paragraphs added and removed
   */
  onParagraphsMutations(mutations) {
    const changes = [];
    // New paragraph
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    addedParagraphs.forEach((paragraph) => changes.push({
      outerHTML: this.cleanOuterHTML(paragraph),
      mutation: 'add',
      index: paragraph.previousElementSibling
        ? elementIndex(toHTMLElement(paragraph.previousElementSibling)) + 1
        : 0
    }));
    // Sort descending because undo-redo will remove the items in that order with their index
    changes.sort(({ index: indexA }, { index: indexB }) => indexB - indexA);
    // Paragraphs removed
    const removedParagraphs = findRemovedParagraphs({
      mutations,
      container: containerStore.state.ref,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    const lowerIndex = Math.min(...removedParagraphs.map(({ previousSibling }) => previousSibling ? elementIndex(toHTMLElement(previousSibling)) + 1 : 0));
    removedParagraphs.forEach(({ paragraph }, index) => {
      const elementIndex = index + (Number.isFinite(lowerIndex) ? lowerIndex : 0);
      const undoParagraph = this.undoUpdateParagraphs.find(({ index }) => index === elementIndex);
      // cleanOuterHTML is only there as fallback, we should find the previous outerHTML value in undoUpdateParagraphs
      return changes.push({
        outerHTML: (undoParagraph === null || undoParagraph === void 0 ? void 0 : undoParagraph.outerHTML) || this.cleanOuterHTML(paragraph),
        mutation: 'remove',
        index: elementIndex
      });
    });
    return changes;
  }
  /**
   * Nodes within paragraphs added and removed.
   *
   * If we stack an update of the paragraph we shall not also stack an "input" update at the same time.
   *
   * @return did update
   */
  onNodesParagraphsMutation(mutations) {
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    const needsUpdate = addedNodesMutations.length > 0 || removedNodesMutations.length > 0;
    if (!needsUpdate) {
      return [];
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    // Check that the nodes of the paragraphs to update were not already been added to the undoRedo store in `onParagraphsMutations`
    const filterUndoUpdateParagraphs = this.undoUpdateParagraphs.filter(({ paragraph }) => paragraph.isConnected &&
      addedParagraphs.find((element) => element.isEqualNode(paragraph)) === undefined);
    if (filterUndoUpdateParagraphs.length <= 0) {
      this.copySelectedParagraphs({ filterEmptySelection: true });
      return [];
    }
    this.copySelectedParagraphs({ filterEmptySelection: true });
    this.undoInputs = undefined;
    return filterUndoUpdateParagraphs;
  }
  cleanOuterHTML(paragraph) {
    const clone = paragraph.cloneNode(true);
    clone.removeAttribute('placeholder');
    return clone.outerHTML;
  }
  onAttributesMutation(mutations) {
    const updateParagraphs = findUpdatedParagraphs({
      mutations: filterAttributesMutations({
        mutations,
        excludeAttributes: configStore.state.attributes.exclude
      }),
      container: containerStore.state.ref
    });
    if (updateParagraphs.length <= 0) {
      return;
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return;
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: this.undoUpdateParagraphs,
      selection: this.undoSelection
    });
    this.undoUpdateParagraphs = this.toUpdateParagraphs(updateParagraphs);
  }
}

const injectCSS = ({ rootNode }) => {
  let style = (rootNode === document ? document.head : rootNode).querySelector('style[stylo-editor]');
  if (style !== null) {
    return;
  }
  style = document.createElement('style');
  style.setAttribute('stylo-editor', '');
  style.innerHTML = `
    .stylo-container > * {
      white-space: pre-wrap;
      position: relative;
    }

    .stylo-container > *:after {
      content: attr(placeholder);
      color: var(--stylo-placeholder-color, rgba(55, 53, 47, 0.5));
      position: absolute;
      top: 0;
    }
  `;
  if (rootNode === document) {
    document.head.append(style);
    return;
  }
  rootNode.prepend(style);
};

const editorCss = ":host{display:block}";

const Editor = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.contentEditable = true;
    this.debounceSize = d(() => this.applySize(), 250);
    this.undoRedoEvents = new UndoRedoEvents();
    this.enterEvents = new EnterEvents();
    this.placeHolderEvents = new PlaceholderEvents();
    this.inputEvents = new InputEvents();
    this.tabEvents = new TabEvents();
    this.dataEvents = new DataEvents();
    this.pasteEvents = new PasteEvents();
    this.mobile = isMobile();
  }
  componentWillLoad() {
    this.init();
    this.applyConfig();
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', this.debounceSize);
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', this.debounceSize);
    this.destroy();
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onContainerRefChange() {
    this.destroy();
    this.init();
  }
  onConfigChange() {
    this.destroy();
    this.applyConfig();
    this.initEvents();
  }
  applySize() {
    var _a;
    if (this.mobile) {
      return;
    }
    containerStore.state.size = (_a = this.containerRef) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  }
  init() {
    containerStore.state.ref = this.containerRef;
    if (!this.containerRef) {
      return;
    }
    injectCSS({ rootNode: this.containerRef.getRootNode() });
    containerStore.state.ref.classList.add('stylo-container');
    this.containerRefEditable();
    this.applySize();
    this.initEvents();
  }
  /**
   * Observe and init containerref "contenteditable" state. Notably useful in case consumer toggles such state.
   */
  containerRefEditable() {
    var _a;
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.attributesObserver = new MutationObserver((mutations) => {
      const contentEditableChanged = mutations.find(({ attributeName }) => ['contenteditable'].includes(attributeName.toLowerCase()));
      if (!contentEditableChanged) {
        return;
      }
      this.contentEditable = this.isContentEditable();
      if (this.contentEditable) {
        this.initEvents();
        return;
      }
      this.destroy();
    });
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true });
    this.contentEditable = this.isContentEditable();
  }
  isContentEditable() {
    return ['true', ''].includes(this.containerRef.getAttribute('contenteditable'));
  }
  applyConfig() {
    var _a, _b;
    if (!this.config) {
      return;
    }
    const { plugins, toolbar, i18n: customI18n, placeholders, textParagraphs, menus, attributes } = this.config;
    i18n.state.custom = customI18n === null || customI18n === void 0 ? void 0 : customI18n.custom;
    i18n.state.lang = (customI18n === null || customI18n === void 0 ? void 0 : customI18n.lang) || 'en';
    configStore.state.plugins = plugins || DEFAULT_PLUGINS;
    configStore.state.toolbar = toolbar
      ? Object.assign(Object.assign({}, configStore.state.toolbar), toolbar) : DEFAULT_TOOLBAR;
    configStore.state.placeholders = placeholders || DEFAULT_PLACEHOLDERS;
    configStore.state.textParagraphs = textParagraphs || DEFAULT_TEXT_PARAGRAPHS;
    configStore.state.menus = menus;
    const paragraphIdentifier = (_a = attributes === null || attributes === void 0 ? void 0 : attributes.paragraphIdentifier) !== null && _a !== void 0 ? _a : DEFAULT_PARAGRAPH_IDENTIFIER;
    configStore.state.attributes = {
      paragraphIdentifier,
      exclude: [
        ...new Set([
          ...((_b = attributes === null || attributes === void 0 ? void 0 : attributes.exclude) !== null && _b !== void 0 ? _b : []),
          ...DEFAULT_EXCLUDE_ATTRIBUTES,
          paragraphIdentifier
        ])
      ]
    };
  }
  destroy() {
    this.undoRedoEvents.destroy();
    this.inputEvents.destroy();
    this.enterEvents.destroy();
    this.placeHolderEvents.destroy();
    this.tabEvents.destroy();
    this.dataEvents.destroy();
    this.pasteEvents.destroy();
    undoRedoStore.state.undo = [];
    undoRedoStore.state.redo = [];
  }
  initEvents() {
    if (!this.contentEditable) {
      return;
    }
    this.inputEvents.init();
    this.enterEvents.init();
    this.placeHolderEvents.init({ editorRef: this.el });
    this.tabEvents.init();
    this.dataEvents.init({ editorRef: this.el });
    this.undoRedoEvents.init();
    this.pasteEvents.init();
  }
  render() {
    var _a;
    if (!this.contentEditable) {
      return undefined;
    }
    return (h(Fragment, null, h("stylo-add", null), h("stylo-plugins", null), this.renderToolbar(), ((_a = configStore.state.menus) === null || _a === void 0 ? void 0 : _a.length) && h("stylo-menus", null)));
  }
  renderToolbar() {
    if (this.mobile) {
      return undefined;
    }
    return h("stylo-toolbar", { containerRef: this.containerRef });
  }
  get el() { return this; }
  static get watchers() { return {
    "containerRef": ["onContainerRefChange"],
    "config": ["onConfigChange"]
  }; }
  static get style() { return editorCss; }
}, [0, "stylo-editor", {
    "config": [16],
    "containerRef": [16],
    "contentEditable": [32]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-editor", "stylo-add", "stylo-color", "stylo-color-input", "stylo-list", "stylo-menus", "stylo-plugins", "stylo-toolbar", "stylo-toolbar-align", "stylo-toolbar-button", "stylo-toolbar-color", "stylo-toolbar-font-size", "stylo-toolbar-link", "stylo-toolbar-list", "stylo-toolbar-separator", "stylo-toolbar-text", "stylo-toolbar-triangle"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-editor":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Editor);
      }
      break;
    case "stylo-add":
      if (!customElements.get(tagName)) {
        defineCustomElement$h();
      }
      break;
    case "stylo-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$g();
      }
      break;
    case "stylo-color-input":
      if (!customElements.get(tagName)) {
        defineCustomElement$f();
      }
      break;
    case "stylo-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$e();
      }
      break;
    case "stylo-menus":
      if (!customElements.get(tagName)) {
        defineCustomElement$d();
      }
      break;
    case "stylo-plugins":
      if (!customElements.get(tagName)) {
        defineCustomElement$c();
      }
      break;
    case "stylo-toolbar":
      if (!customElements.get(tagName)) {
        defineCustomElement$b();
      }
      break;
    case "stylo-toolbar-align":
      if (!customElements.get(tagName)) {
        defineCustomElement$a();
      }
      break;
    case "stylo-toolbar-button":
      if (!customElements.get(tagName)) {
        defineCustomElement$9();
      }
      break;
    case "stylo-toolbar-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
    case "stylo-toolbar-font-size":
      if (!customElements.get(tagName)) {
        defineCustomElement$7();
      }
      break;
    case "stylo-toolbar-link":
      if (!customElements.get(tagName)) {
        defineCustomElement$6();
      }
      break;
    case "stylo-toolbar-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$5();
      }
      break;
    case "stylo-toolbar-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$4();
      }
      break;
    case "stylo-toolbar-text":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "stylo-toolbar-triangle":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const StyloEditor = Editor;
const defineCustomElement = defineCustomElement$1;

export { StyloEditor, defineCustomElement };
