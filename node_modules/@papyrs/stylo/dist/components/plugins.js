import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { e as configStore } from './config.store.js';
import { c as containerStore } from './container.store.js';
import { i as isMobile } from './mobile.utils.js';
import { E as focusParagraph, d as toHTMLElement } from './paragraph.utils.js';
import { d as defineCustomElement$1 } from './list.js';

const pluginsCss = ":host{display:flex;flex-direction:column;position:absolute;top:var(--actions-top);left:var(--actions-left);transform:translate(0, var(--actions-translate-y)) scale(0.95);opacity:0;margin:2px 0;width:220px;max-height:220px;overflow:auto;--light:#f4f5f8;--light-contrast:#000000;--medium:#6e6d6f;--medium-contrast:#000000;--black:#000000;--black-contrast:#ffffff;--white:#ffffff;--white-contrast:#000000;--highlight:#3880ff;--highlight-rgb:56, 128, 255;--highlight-contrast:#ffffff;background:var(--stylo-background, var(--white));color:var(--stylo-color, var(--white-contrast));border-radius:var(--stylo-border, 4px);--box-shadow:0 4px 16px 0 rgba(0, 0, 0, 0.12);box-shadow:var(--stylo-box-shadow, var(--box-shadow));border:var(--stylo-border);pointer-events:none;transition-property:opacity, transform;transition-duration:0.15s, 0.15s;transition-timing-function:cubic-bezier(0.175, 0.885, 0.32, 1.275), cubic-bezier(0.175, 0.885, 0.32, 1.275)}:host(.display){opacity:1;transform:translate(0, var(--actions-translate-y)) scale(1);pointer-events:all}input{visibility:hidden;opacity:0}";

const Plugins = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.display = false;
    this.position = undefined;
  }
  componentWillLoad() {
    this.destroyListener = containerStore.onChange('size', () => {
      if (isMobile()) {
        return;
      }
      this.hide();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  /**
   * If user click anywhere not in the stylo-editor, hide the transform options
   */
  onClick(_$event) {
    this.hide();
  }
  onHidePlugins() {
    this.hide();
  }
  hide() {
    this.display = false;
    // To make the visual transition not glitchy, we hide first and then move the component outside
    setTimeout(() => (this.position = undefined), 150);
  }
  onListPlugins({ detail: paragraph }) {
    if (!paragraph) {
      this.hide();
      return;
    }
    const { height, top } = paragraph.getBoundingClientRect();
    // top + size + margin
    const downward = top + 220 + 16 < (window.innerHeight || screen.height);
    this.position = {
      top: paragraph.offsetTop + (downward ? height : -1 * height),
      left: paragraph.offsetLeft,
      downward
    };
    this.paragraph = paragraph;
    this.displayAndFocus();
  }
  displayAndFocus() {
    const onRender = async (_mutations, observer) => {
      var _a;
      if (this.el.style.visibility !== 'visible') {
        return;
      }
      observer.disconnect();
      await ((_a = this.el.shadowRoot.querySelector('stylo-list')) === null || _a === void 0 ? void 0 : _a.focusFirstButton());
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(this.el, { attributes: true, subtree: true });
    setTimeout(() => (this.display = true), 150);
  }
  onCancelPlugins() {
    this.hide();
    focusParagraph({ paragraph: this.paragraph });
  }
  async onApplyPlugin(plugin) {
    if (!containerStore.state.ref || !this.paragraph) {
      return;
    }
    this.hide();
    const { files } = plugin;
    if (files !== undefined) {
      this.openFilePicker(plugin);
      return;
    }
    await this.transformParagraph({ plugin });
  }
  async transformParagraph({ plugin, files }) {
    const { createParagraphs } = plugin;
    await createParagraphs({
      paragraph: toHTMLElement(this.paragraph),
      container: containerStore.state.ref,
      files
    });
  }
  openFilePicker(plugin) {
    const input = this.filePicker(plugin);
    input === null || input === void 0 ? void 0 : input.click();
  }
  async onFilePickerChange(plugin) {
    const input = this.filePicker(plugin);
    if (!input || input.files.length <= 0) {
      return;
    }
    await this.transformParagraph({ plugin, files: input.files });
    // Reset input otherwise a new data cannot be selected
    input.value = '';
  }
  filePicker({ files }) {
    const { accept } = files;
    return this.el.shadowRoot.querySelector(`input[accept="${accept}"]`);
  }
  render() {
    const style = Object.assign(Object.assign({ visibility: this.display ? 'visible' : 'hidden' }, (!this.display && { height: '0px' })), (this.position === undefined
      ? {}
      : {
        '--actions-top': `${this.position.top}px`,
        '--actions-left': `${this.position.left}px`,
        '--actions-translate-y': `${this.position.downward ? '0' : '-100%'}`
      }));
    return (h(Host, { style: style, class: `${this.display ? 'display' : 'hidden'}` }, this.renderList(), this.renderInputs()));
  }
  renderInputs() {
    return configStore.state.plugins
      .filter(({ files }) => files !== undefined)
      .map((plugin) => {
      const { accept, multiple } = plugin.files;
      return (h("input", { type: "file", accept: accept, multiple: multiple, onChange: async () => await this.onFilePickerChange(plugin) }));
    });
  }
  renderList() {
    return (h("stylo-list", { onApplyPlugin: async ({ detail }) => await this.onApplyPlugin(detail), onCancelPlugins: () => this.onCancelPlugins(), display: this.display }));
  }
  get el() { return this; }
  static get style() { return pluginsCss; }
}, [1, "stylo-plugins", {
    "display": [32],
    "position": [32]
  }, [[5, "click", "onClick"], [5, "hidePlugins", "onHidePlugins"], [5, "listPlugins", "onListPlugins"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-plugins", "stylo-list"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-plugins":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Plugins);
      }
      break;
    case "stylo-list":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}
defineCustomElement();

export { Plugins as P, defineCustomElement as d };
