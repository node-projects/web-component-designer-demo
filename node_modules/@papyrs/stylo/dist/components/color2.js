import { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';
import { u, d as defineCustomElement$1 } from './input.js';
import { i as isParagraph, d as toHTMLElement, F as a } from './paragraph.utils.js';
import { e as configStore } from './config.store.js';
import { g as getRange, a as getSelection } from './selection.utils.js';
import { p } from './chunk-MPAE6ITZ.js';
import { c as ToolbarFontSize, b as ToolbarAlign, a as ToolbarList } from './toolbar.js';
import { d as defineCustomElement$2 } from './color.js';

const findStyleNode = (node, style, container) => {
  // Just in case
  if (node.nodeName.toUpperCase() === 'HTML' || node.nodeName.toUpperCase() === 'BODY') {
    return null;
  }
  if (!node.parentNode) {
    return null;
  }
  if (isParagraph({ element: node, container })) {
    return null;
  }
  const { style: elementStyle } = toHTMLElement(node);
  const hasStyle = elementStyle[style] !== null && elementStyle[style] !== undefined && elementStyle[style] !== '';
  if (hasStyle) {
    return node;
  }
  return findStyleNode(node.parentNode, style, container);
};
const getBold = (element) => {
  if (isTag(element, 'b')) {
    return 'bold';
  }
  if (isTag(element, 'strong')) {
    return 'bold';
  }
  return element.style.fontWeight === 'bold'
    ? 'bold'
    : element.style.fontWeight === 'initial'
      ? 'initial'
      : undefined;
};
const getFontSize = (element) => {
  if (!element) {
    return undefined;
  }
  if (element.hasAttribute('size')) {
    return element.getAttribute('size');
  }
  return element.style.fontSize !== ''
    ? ToolbarFontSize[element.style.fontSize.replace('-', '_').toUpperCase()]
    : undefined;
};
const getContentAlignment = (element) => {
  const style = window.getComputedStyle(element);
  if (style.textAlign === 'center') {
    return ToolbarAlign.CENTER;
  }
  else if (style.textAlign === 'right') {
    return ToolbarAlign.RIGHT;
  }
  else if (style.textAlign === 'left') {
    return ToolbarAlign.LEFT;
  }
  return p() ? ToolbarAlign.RIGHT : ToolbarAlign.LEFT;
};
const getList = (element) => {
  if (!element) {
    return undefined;
  }
  if (element.nodeName &&
    element.nodeName.toLowerCase() === 'li' &&
    element.parentElement &&
    element.parentElement.nodeName) {
    return element.parentElement.nodeName.toLowerCase() === 'ol'
      ? ToolbarList.ORDERED
      : element.parentElement.nodeName.toLowerCase() === 'ul'
        ? ToolbarList.UNORDERED
        : undefined;
  }
  return undefined;
};
const getStrikeThrough = (element) => {
  var _a, _b, _c, _d, _e;
  if (isTag(element, 'strike')) {
    return 'strikethrough';
  }
  if (((_a = element.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('line-through')) > -1 ||
    ((_b = element.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('line-through')) > -1) {
    return 'strikethrough';
  }
  if (((_c = element.style.textDecoration) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1 ||
    ((_d = element.style.textDecorationLine) === null || _d === void 0 ? void 0 : _d.indexOf('initial')) > -1) {
    return 'initial';
  }
  if (!element.hasChildNodes()) {
    return undefined;
  }
  const children = element.children;
  if (children && children.length > 0) {
    const selectedChild = Array.from(children).find((child) => {
      var _a, _b, _c;
      return (((_a = child.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('line-through')) > -1 ||
        ((_b = child.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('line-through')) > -1 ||
        ((_c = child.style.textDecorationLine) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1);
    });
    if (selectedChild) {
      return ((_e = selectedChild.style.fontStyle) === null || _e === void 0 ? void 0 : _e.indexOf('line-through')) > -1
        ? 'strikethrough'
        : 'initial';
    }
  }
  return undefined;
};
const getUnderline = (element) => {
  var _a, _b, _c, _d, _e;
  if (isTag(element, 'u')) {
    return 'underline';
  }
  if (((_a = element.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('underline')) > -1 ||
    ((_b = element.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('underline')) > -1) {
    return 'underline';
  }
  if (((_c = element.style.textDecoration) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1 ||
    ((_d = element.style.textDecorationLine) === null || _d === void 0 ? void 0 : _d.indexOf('initial')) > -1) {
    return 'initial';
  }
  if (!element.hasChildNodes()) {
    return undefined;
  }
  const children = element.children;
  if (children && children.length > 0) {
    const selectedChild = Array.from(children).find((child) => {
      var _a, _b, _c;
      return (((_a = child.style.textDecoration) === null || _a === void 0 ? void 0 : _a.indexOf('underline')) > -1 ||
        ((_b = child.style.textDecorationLine) === null || _b === void 0 ? void 0 : _b.indexOf('underline')) > -1 ||
        ((_c = child.style.textDecorationLine) === null || _c === void 0 ? void 0 : _c.indexOf('initial')) > -1);
    });
    if (selectedChild) {
      return ((_e = selectedChild.style.fontStyle) === null || _e === void 0 ? void 0 : _e.indexOf('underline')) > -1 ? 'underline' : 'initial';
    }
  }
  return undefined;
};
const getItalic = (element) => {
  if (isTag(element, 'i')) {
    return 'italic';
  }
  if (isTag(element, 'em')) {
    return 'italic';
  }
  if (element.style.fontStyle === 'italic') {
    return 'italic';
  }
  if (element.style.fontStyle === 'initial') {
    return 'initial';
  }
  if (!element.hasChildNodes()) {
    return undefined;
  }
  const children = element.children;
  if (children && children.length > 0) {
    const selectedChild = Array.from(children).find((child) => {
      return child.style.fontStyle === 'italic' || child.style.fontStyle === 'initial';
    });
    if (selectedChild) {
      return selectedChild.style.fontStyle === 'italic' ? 'italic' : 'initial';
    }
  }
  return undefined;
};
const isTag = (element, tagName) => {
  if (!element) {
    return false;
  }
  if (element.nodeName.toLowerCase() === tagName) {
    return true;
  }
  if (element.hasChildNodes()) {
    const children = element.getElementsByTagName(tagName);
    return children && children.length > 0;
  }
  return false;
};

const colorCss = ":host{padding:4px 0}:host stylo-color{pointer-events:all}";

const Color = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.execCommand = createEvent(this, "execCommand", 7);
    this.close = createEvent(this, "close", 7);
    this.closeToolbar = () => {
      this.close.emit();
    };
  }
  componentWillLoad() {
    this.initColor();
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('click', this.closeToolbar, { passive: true });
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('click', this.closeToolbar);
  }
  initColor() {
    const { range, selection } = getRange(this.containerRef);
    this.range = range;
    const anchor = a(selection);
    if (!anchor) {
      return;
    }
    const style = findStyleNode(anchor, this.action === 'color' ? 'color' : 'background-color', this.containerRef);
    if (!style) {
      return;
    }
    const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(toHTMLElement(style));
    this.colorRgb = (this.action === 'color' ? css.color : css.backgroundColor)
      .replace('rgb(', '')
      .replace(')', '');
  }
  selectColor($event) {
    const selection = getSelection(this.containerRef);
    if (!selection || !$event || !$event.detail) {
      return;
    }
    if (!this.action) {
      return;
    }
    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
    selection === null || selection === void 0 ? void 0 : selection.addRange(this.range);
    const observer = new MutationObserver((_mutations) => {
      observer.disconnect();
      // No node were added so the style was modified
      this.range = selection === null || selection === void 0 ? void 0 : selection.getRangeAt(0);
    });
    const anchorNode = a(selection);
    if (!anchorNode) {
      return;
    }
    observer.observe(anchorNode, { childList: true });
    this.execCommand.emit({
      cmd: 'style',
      detail: {
        style: this.action,
        value: $event.detail.hex,
        initial: (element) => {
          const rgb = u($event.detail.hex);
          return (element &&
            (element.style[this.action] === $event.detail.hex ||
              element.style[this.action] === `rgb(${rgb})`));
        }
      }
    });
  }
  render() {
    return (h("stylo-color", { "color-rgb": this.colorRgb, onColorChange: ($event) => this.selectColor($event), palette: configStore.state.toolbar.palette }));
  }
  static get style() { return colorCss; }
}, [1, "stylo-toolbar-color", {
    "action": [1],
    "containerRef": [16],
    "colorRgb": [32]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["stylo-toolbar-color", "stylo-color", "stylo-color-input"];
  components.forEach(tagName => { switch (tagName) {
    case "stylo-toolbar-color":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Color);
      }
      break;
    case "stylo-color":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
    case "stylo-color-input":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}
defineCustomElement();

export { Color as C, getItalic as a, getUnderline as b, getStrikeThrough as c, defineCustomElement as d, getList as e, findStyleNode as f, getBold as g, getFontSize as h, getContentAlignment as i };
