import { moveCursorToEnd } from '@deckdeckgo/utils';
import configStore from '../stores/config.store';
import containerStore from '../stores/container.store';
import { findNodeAtDepths, toHTMLElement } from '../utils/node.utils';
import { createNewParagraph, findParagraph, isStartNode } from '../utils/paragraph.utils';
import { getRange, getSelection } from '../utils/selection.utils';
import { beforeInputTransformer, transformInput } from '../utils/transform.utils';
export class InputEvents {
  constructor() {
    this.lastBeforeInput = undefined;
    this.lastKey = undefined;
    this.onBeforeInput = async ($event) => {
      await this.preventTextLeaves($event);
      // Use for comparison purpose in transformInput
      const { data: key } = $event;
      this.lastBeforeInput = { key };
    };
    this.onKeyDown = async ($event) => {
      await this.transformInput($event);
      // This should be an on keydown listener because Firefox do not provide the same range in before input
      this.deleteSelection($event);
    };
  }
  init() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a, _b;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('beforeinput', this.onBeforeInput);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keydown', this.onKeyDown);
  }
  async preventTextLeaves($event) {
    var _a;
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchorNode = selection === null || selection === void 0 ? void 0 : selection.anchorNode;
    if (!containerStore.state.ref.isEqualNode(anchorNode)) {
      return;
    }
    const { data } = $event;
    // User is not typing, for example an image is moved
    if (data === null) {
      return;
    }
    const { startOffset } = range;
    const target = findNodeAtDepths({
      parent: containerStore.state.ref,
      indexDepths: [startOffset]
    });
    // We create a div - i.e. new HTML element - only if the actual target is not an editable paragraph that accepts text
    if ((_a = configStore.state.textParagraphs) === null || _a === void 0 ? void 0 : _a.includes(target === null || target === void 0 ? void 0 : target.nodeName.toLowerCase())) {
      // We set the range to the start of the target because if we don't, the browser might create a text element before the target anyway
      range.setStart(target, 0);
      return;
    }
    // User is typing text at the root of the container therefore the browser will create a text node a direct descendant of the contenteditable
    // This can happen when user types for example before or after an image
    $event.preventDefault();
    const div = await createNewParagraph({
      container: containerStore.state.ref,
      range,
      text: data
    });
    moveCursorToEnd(div);
  }
  async transformInput($event) {
    var _a;
    const { key } = $event;
    const selection = getSelection(containerStore.state.ref);
    if (!selection) {
      return;
    }
    const { focusNode: target } = selection;
    const parent = toHTMLElement(target);
    const isActive = beforeInputTransformer.find(({ active }) => active(parent)) !== undefined;
    // We are in an active mark up, therefore we do not check to transform. User can escape by moving to next text node
    if (isActive) {
      return;
    }
    const transformer = beforeInputTransformer.find(({ match }) => match({ key: { key }, lastKey: this.lastKey, lastBeforeInput: this.lastBeforeInput }));
    if (transformer !== undefined) {
      await transformInput({ $event, transformInput: transformer, target, parent });
      await ((_a = transformer.postTransform) === null || _a === void 0 ? void 0 : _a.call(transformer));
      this.lastKey = undefined;
      return;
    }
    this.lastKey = { key };
  }
  deleteSelection($event) {
    const { key } = $event;
    if (!['Delete', 'Backspace'].includes(key)) {
      return;
    }
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    // If the commonAncestorContainer is the container then we have selected multiple paragraphs
    if (!containerStore.state.ref.isEqualNode(range === null || range === void 0 ? void 0 : range.commonAncestorContainer)) {
      return;
    }
    // If first char is a zeroWidthSpace and the offset start at the second character, reset range to begin
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    if (zeroWidthSpace) {
      range.setStart(range.startContainer, 0);
    }
    // We don't have a selection that starts at the beginning of an element and paragraph
    if (range.startOffset > 0) {
      return;
    }
    // We don't have a selection that starts at the beginning of a paragraph
    if (!isStartNode({ element: range.startContainer, container: containerStore.state.ref })) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: range.startContainer, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    // Reset range to begin of the paragraph in case it contains children
    range.setStartBefore(paragraph);
    $event.preventDefault();
    $event.stopImmediatePropagation();
    range.deleteContents();
  }
}
