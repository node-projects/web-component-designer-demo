import { debounce } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import configStore from '../stores/config.store.js';
import containerStore from '../stores/container.store.js';
import { emitAddParagraphs, emitDeleteParagraphs, emitUpdateParagraphs } from '../utils/events.utils.js';
import { isTextNode, toHTMLElement } from '../utils/node.utils.js';
import { filterAttributesMutations, findAddedNodesParagraphs, findAddedParagraphs, findRemovedNodesParagraphs, findUpdatedParagraphs } from '../utils/paragraphs.utils.js';
export class DataEvents {
  constructor() {
    this.stackDataMutations = [];
    this.debounceUpdateInput = debounce(() => this.updateData(), 500);
    this.onTreeMutation = (mutations) => {
      this.addParagraphs(mutations);
      this.deleteParagraphs(mutations);
      this.updateAddedNodesParagraphs(mutations);
    };
    this.onAttributesMutation = (mutations) => {
      this.updateParagraphs(filterAttributesMutations({
        mutations,
        excludeAttributes: configStore.state.excludeAttributes
      }));
    };
    this.onDataMutation = (mutations) => {
      this.stackDataMutations.push(...mutations);
      this.debounceUpdateInput();
    };
  }
  init({ editorRef }) {
    this.editorRef = editorRef;
    this.treeObserver = new MutationObserver(this.onTreeMutation);
    this.treeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    this.attributesObserver = new MutationObserver(this.onAttributesMutation);
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true, subtree: true });
    this.dataObserver = new MutationObserver(this.onDataMutation);
    this.dataObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.treeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.attributesObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.dataObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  addParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (addedParagraphs.length <= 0) {
      return;
    }
    emitAddParagraphs({ editorRef: this.editorRef, addedParagraphs });
  }
  deleteParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    // Only those the target is the container are paragraphs
    const removedNodes = mutations.reduce((acc, { removedNodes, target }) => {
      if (!target.isEqualNode(containerStore.state.ref)) {
        return acc;
      }
      return [...acc, ...Array.from(removedNodes)];
    }, []);
    // We remove text node, should not happen we only want elements as children of the container
    const removedParagraphs = removedNodes
      .filter((node) => !isTextNode(node))
      .map((node) => toHTMLElement(node));
    if (removedParagraphs.length <= 0) {
      return;
    }
    emitDeleteParagraphs({ editorRef: this.editorRef, removedParagraphs });
  }
  updateAddedNodesParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    this.updateParagraphs([...addedNodesMutations, ...removedNodesMutations]);
  }
  updateData() {
    if (!this.stackDataMutations || this.stackDataMutations.length <= 0) {
      return;
    }
    const mutations = [...this.stackDataMutations];
    this.stackDataMutations = [];
    this.updateParagraphs(mutations);
  }
  updateParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    const updatedParagraphs = findUpdatedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (updatedParagraphs.length <= 0) {
      return;
    }
    emitUpdateParagraphs({ editorRef: this.editorRef, updatedParagraphs });
  }
}
