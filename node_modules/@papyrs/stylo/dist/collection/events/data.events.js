import { debounce } from '@deckdeckgo/utils';
import configStore from '../stores/config.store';
import containerStore from '../stores/container.store';
import { emitAddParagraphs, emitDeleteParagraphs, emitUpdateParagraphs } from '../utils/events.utils';
import { isTextNode, toHTMLElement } from '../utils/node.utils';
import { setParagraphAttribute } from '../utils/paragraph.utils';
import { filterAttributesMutations, findAddedNodesParagraphs, findAddedParagraphs, findRemovedNodesParagraphs, findUpdatedParagraphs } from '../utils/paragraphs.utils';
export class DataEvents {
  constructor() {
    this.stackDataMutations = [];
    this.debounceUpdateInput = debounce(() => this.updateData(), 500);
    this.onTreeMutation = async (mutations) => {
      const addedParagraphs = await this.addParagraphs(mutations);
      this.deleteParagraphs(mutations);
      this.updateAddedNodesParagraphs({ addedParagraphs, mutations });
    };
    this.onAttributesMutation = (mutations) => {
      this.updateParagraphs({
        mutations: filterAttributesMutations({
          mutations,
          excludeAttributes: configStore.state.attributes.exclude
        })
      });
    };
    this.onDataMutation = (mutations) => {
      this.stackDataMutations.push(...mutations);
      this.debounceUpdateInput();
    };
  }
  init({ editorRef }) {
    this.editorRef = editorRef;
    this.treeObserver = new MutationObserver(this.onTreeMutation);
    this.treeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    this.attributesObserver = new MutationObserver(this.onAttributesMutation);
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true, subtree: true });
    this.dataObserver = new MutationObserver(this.onDataMutation);
    this.dataObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.treeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.attributesObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.dataObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
  }
  async addParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (addedParagraphs.length <= 0) {
      return [];
    }
    await Promise.all(addedParagraphs.map((paragraph) => setParagraphAttribute({
      paragraph,
      attributeName: configStore.state.attributes.paragraphIdentifier
    })));
    emitAddParagraphs({ editorRef: this.editorRef, addedParagraphs });
    return addedParagraphs;
  }
  deleteParagraphs(mutations) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    const removedNodes = mutations.reduce((acc, { removedNodes }) => [...acc, ...Array.from(removedNodes)], []);
    const removedParagraphs = removedNodes
      .filter((node) => !isTextNode(node))
      .filter((removedNode) => addedNodes.find((addedNode) => addedNode.isEqualNode(removedNode)) === undefined)
      .map((node) => toHTMLElement(node))
      .filter((element) => element === null || element === void 0 ? void 0 : element.hasAttribute(configStore.state.attributes.paragraphIdentifier));
    if (removedParagraphs.length <= 0) {
      return;
    }
    emitDeleteParagraphs({ editorRef: this.editorRef, removedParagraphs });
  }
  updateAddedNodesParagraphs({ mutations, addedParagraphs }) {
    if (!containerStore.state.ref) {
      return;
    }
    if (!mutations || mutations.length <= 0) {
      return;
    }
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    this.updateParagraphs({
      mutations: [...addedNodesMutations, ...removedNodesMutations],
      addedParagraphs
    });
  }
  updateData() {
    if (!this.stackDataMutations || this.stackDataMutations.length <= 0) {
      return;
    }
    const mutations = [...this.stackDataMutations];
    this.stackDataMutations = [];
    this.updateParagraphs({ mutations });
  }
  updateParagraphs({ mutations, addedParagraphs = [] }) {
    if (!containerStore.state.ref) {
      return;
    }
    const updatedParagraphs = findUpdatedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    if (updatedParagraphs.length <= 0) {
      return;
    }
    // Browser might report an update for a node that might have just been added. We do not consider these as updates.
    // Useful when client persist paragraphs because the updated node might not be persisted yet since it was just added and emitted as such.
    const justAdded = (element) => addedParagraphs.find((addedParagraph) => addedParagraph.isSameNode(element)) !==
      undefined;
    const existingUpdatedParagraphs = updatedParagraphs.filter((element) => !justAdded(element));
    if (existingUpdatedParagraphs.length <= 0) {
      return;
    }
    emitUpdateParagraphs({ editorRef: this.editorRef, updatedParagraphs: existingUpdatedParagraphs });
  }
}
//# sourceMappingURL=data.events.js.map
