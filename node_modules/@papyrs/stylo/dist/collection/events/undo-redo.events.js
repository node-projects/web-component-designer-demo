import { caretPosition, debounce } from '@deckdeckgo/utils';
import configStore from '../stores/config.store';
import containerStore from '../stores/container.store';
import undoRedoStore from '../stores/undo-redo.store';
import { isKeyboardEnter } from '../utils/keyboard.utils';
import { elementIndex, nodeDepths, toHTMLElement } from '../utils/node.utils';
import { findParagraph } from '../utils/paragraph.utils';
import { filterAttributesMutations, findAddedNodesParagraphs, findAddedParagraphs, findRemovedNodesParagraphs, findRemovedParagraphs, findSelectionParagraphs, findUpdatedParagraphs } from '../utils/paragraphs.utils';
import { getRange, getSelection } from '../utils/selection.utils';
import { toUndoRedoSelection } from '../utils/undo-redo-selection.utils';
import { nextRedoChanges, nextUndoChanges, redo, stackUndoInput, stackUndoParagraphs, undo } from '../utils/undo-redo.utils';
export class UndoRedoEvents {
  constructor() {
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.undoSelection = undefined;
    this.debounceUpdateInputs = debounce(() => this.stackUndoInputs(), 350);
    this.onKeydown = async ($event) => {
      const { key, ctrlKey, metaKey, shiftKey } = $event;
      if (isKeyboardEnter($event)) {
        this.stackUndoInputs();
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && !shiftKey) {
        await this.undo($event);
        return;
      }
      if (key === 'z' && (ctrlKey || metaKey) && shiftKey) {
        await this.redo($event);
        return;
      }
      if (key === 'Backspace') {
        this.stackBackspace();
      }
    };
    this.onKeyup = () => {
      var _a;
      this.onEventUpdateParagraphs((_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode);
    };
    this.onSelectionChange = () => (this.undoSelection = toUndoRedoSelection(containerStore.state.ref));
    this.onToolbarActivated = () => {
      this.copySelectedParagraphs({ filterEmptySelection: true });
    };
    this.onMenuActivated = ({ detail }) => {
      const { paragraph } = detail;
      this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
    };
    this.onSnapshotParagraph = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMouseTouchDown = ({ target }) => {
      this.onEventUpdateParagraphs(target);
    };
    this.onMutation = (mutations) => {
      const addRemoveParagraphs = this.onParagraphsMutations(mutations);
      const updateParagraphs = this.onNodesParagraphsMutation(mutations);
      stackUndoParagraphs({
        container: containerStore.state.ref,
        addRemoveParagraphs: addRemoveParagraphs,
        updateParagraphs,
        selection: this.undoSelection
      });
      // We assume that all paragraphs updates do contain attributes and input changes
      if (updateParagraphs.length > 0) {
        return;
      }
      this.onAttributesMutation(mutations);
      this.onCharacterDataMutations(mutations);
    };
  }
  init() {
    var _a, _b, _c, _d, _e;
    this.undoInputs = undefined;
    this.undoUpdateParagraphs = [];
    this.observer = new MutationObserver(this.onMutation);
    this.observe();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.addEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.addEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.addEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.addEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.addEventListener('selectionchange', this.onSelectionChange);
    document.addEventListener('toolbarActivated', this.onToolbarActivated);
    document.addEventListener('menuActivated', this.onMenuActivated);
    this.unsubscribe = undoRedoStore.onChange('observe', (observe) => {
      if (observe) {
        // We re-active the selection as if we would have selected a paragraphs because we might need to record next update
        this.copySelectedParagraphs({ filterEmptySelection: false });
        this.undoInputs = undefined;
        this.observe();
        return;
      }
      this.disconnect();
    });
  }
  destroy() {
    var _a, _b, _c, _d, _e, _f;
    this.disconnect();
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeydown);
    (_b = containerStore.state.ref) === null || _b === void 0 ? void 0 : _b.removeEventListener('keyup', this.onKeyup);
    (_c = containerStore.state.ref) === null || _c === void 0 ? void 0 : _c.removeEventListener('mousedown', this.onMouseTouchDown);
    (_d = containerStore.state.ref) === null || _d === void 0 ? void 0 : _d.removeEventListener('touchstart', this.onMouseTouchDown);
    (_e = containerStore.state.ref) === null || _e === void 0 ? void 0 : _e.removeEventListener('snapshotParagraph', this.onSnapshotParagraph);
    document.removeEventListener('selectionchange', this.onSelectionChange);
    document.removeEventListener('toolbarActivated', this.onToolbarActivated);
    document.removeEventListener('menuActivated', this.onMenuActivated);
    (_f = this.unsubscribe) === null || _f === void 0 ? void 0 : _f.call(this);
  }
  async undo($event) {
    $event.preventDefault();
    if (nextUndoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: undo });
  }
  async redo($event) {
    $event.preventDefault();
    if (nextRedoChanges() === undefined) {
      return;
    }
    await this.undoRedo({ undoRedo: redo });
  }
  stackUndoInputs() {
    this.copySelectedParagraphs({ filterEmptySelection: false });
    if (!this.undoInputs) {
      return;
    }
    stackUndoInput({
      data: this.undoInputs,
      container: containerStore.state.ref
    });
    this.undoInputs = undefined;
  }
  // When user hits backspace at the begin of a paragraph we should stack previous paragraph for update and current one because it will be removed
  stackBackspace() {
    var _a;
    const { range } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const zeroWidthSpace = range.startOffset === 1 && range.startContainer.textContent.charAt(0) === '\u200B';
    // Begin of paragraph?
    if (!(range.startOffset === 0 || zeroWidthSpace)) {
      return;
    }
    const anchorNode = (_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode;
    if (!anchorNode) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({
      element: anchorNode,
      container: containerStore.state.ref
    }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([
      ...(paragraph.previousElementSibling
        ? [paragraph.previousElementSibling]
        : []),
      paragraph
    ]);
  }
  async undoRedo({ undoRedo }) {
    // We skip mutations when we process undo redo
    this.disconnect();
    await undoRedo();
    this.observe();
  }
  observe() {
    this.observer.observe(containerStore.state.ref, {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      subtree: true
    });
  }
  disconnect() {
    var _a;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onEventUpdateParagraphs(target) {
    if (!target) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs([paragraph]);
  }
  // Copy current paragraphs value to a local state so we can add it to the undo redo global store in case of modifications
  copySelectedParagraphs({ filterEmptySelection }) {
    const paragraphs = findSelectionParagraphs({
      container: containerStore.state.ref,
      filterEmptySelection
    });
    if (!paragraphs) {
      return;
    }
    this.undoUpdateParagraphs = this.toUpdateParagraphs(paragraphs);
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: this.cleanOuterHTML(paragraph),
      index: elementIndex(paragraph),
      paragraph
    }));
  }
  onCharacterDataMutations(mutations) {
    const characterMutations = mutations.filter(({ oldValue }) => oldValue !== null);
    // No character mutations
    if (characterMutations.length <= 0) {
      return;
    }
    if (!this.undoInputs) {
      this.undoInputs = characterMutations
        .map((mutation) => this.toUndoInput(mutation))
        .filter((undoInput) => undoInput !== undefined);
    }
    if (this.undoInputs.length <= 0) {
      this.undoInputs = undefined;
      return;
    }
    this.debounceUpdateInputs();
  }
  toUndoInput(mutation) {
    const target = mutation.target;
    const newValue = target.nodeValue;
    // Firefox triggers a character mutation that has same previous and new value when we delete a range in deleteContentBackward
    if (newValue === mutation.oldValue) {
      return undefined;
    }
    const paragraph = toHTMLElement(findParagraph({ element: target, container: containerStore.state.ref }));
    if (!paragraph || !target.parentNode) {
      return undefined;
    }
    // We find the list of node indexes of the parent of the modified text
    const depths = nodeDepths({ target, paragraph });
    return {
      oldValue: mutation.oldValue,
      offset: caretPosition({ target }) + (mutation.oldValue.length - newValue.length),
      index: elementIndex(paragraph),
      indexDepths: depths
    };
  }
  /**
   * Paragraphs added and removed
   */
  onParagraphsMutations(mutations) {
    const changes = [];
    // New paragraph
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    addedParagraphs.forEach((paragraph) => changes.push({
      outerHTML: this.cleanOuterHTML(paragraph),
      mutation: 'add',
      index: paragraph.previousElementSibling
        ? elementIndex(toHTMLElement(paragraph.previousElementSibling)) + 1
        : 0
    }));
    // Sort descending because undo-redo will remove the items in that order with their index
    changes.sort(({ index: indexA }, { index: indexB }) => indexB - indexA);
    // Paragraphs removed
    const removedParagraphs = findRemovedParagraphs({
      mutations,
      container: containerStore.state.ref,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    const lowerIndex = Math.min(...removedParagraphs.map(({ previousSibling }) => previousSibling ? elementIndex(toHTMLElement(previousSibling)) + 1 : 0));
    removedParagraphs.forEach(({ paragraph }, index) => {
      const elementIndex = index + (Number.isFinite(lowerIndex) ? lowerIndex : 0);
      const undoParagraph = this.undoUpdateParagraphs.find(({ index }) => index === elementIndex);
      // cleanOuterHTML is only there as fallback, we should find the previous outerHTML value in undoUpdateParagraphs
      return changes.push({
        outerHTML: (undoParagraph === null || undoParagraph === void 0 ? void 0 : undoParagraph.outerHTML) || this.cleanOuterHTML(paragraph),
        mutation: 'remove',
        index: elementIndex
      });
    });
    return changes;
  }
  /**
   * Nodes within paragraphs added and removed.
   *
   * If we stack an update of the paragraph we shall not also stack an "input" update at the same time.
   *
   * @return did update
   */
  onNodesParagraphsMutation(mutations) {
    const addedNodesMutations = findAddedNodesParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    const removedNodesMutations = findRemovedNodesParagraphs({
      mutations,
      paragraphIdentifier: configStore.state.attributes.paragraphIdentifier
    });
    const needsUpdate = addedNodesMutations.length > 0 || removedNodesMutations.length > 0;
    if (!needsUpdate) {
      return [];
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return [];
    }
    const addedParagraphs = findAddedParagraphs({
      mutations,
      container: containerStore.state.ref
    });
    // Check that the nodes of the paragraphs to update were not already been added to the undoRedo store in `onParagraphsMutations`
    const filterUndoUpdateParagraphs = this.undoUpdateParagraphs.filter(({ paragraph }) => paragraph.isConnected &&
      addedParagraphs.find((element) => element.isEqualNode(paragraph)) === undefined);
    if (filterUndoUpdateParagraphs.length <= 0) {
      this.copySelectedParagraphs({ filterEmptySelection: true });
      return [];
    }
    this.copySelectedParagraphs({ filterEmptySelection: true });
    this.undoInputs = undefined;
    return filterUndoUpdateParagraphs;
  }
  cleanOuterHTML(paragraph) {
    const clone = paragraph.cloneNode(true);
    clone.removeAttribute('placeholder');
    return clone.outerHTML;
  }
  onAttributesMutation(mutations) {
    const updateParagraphs = findUpdatedParagraphs({
      mutations: filterAttributesMutations({
        mutations,
        excludeAttributes: configStore.state.attributes.exclude
      }),
      container: containerStore.state.ref
    });
    if (updateParagraphs.length <= 0) {
      return;
    }
    if (this.undoUpdateParagraphs.length <= 0) {
      return;
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: this.undoUpdateParagraphs,
      selection: this.undoSelection
    });
    this.undoUpdateParagraphs = this.toUpdateParagraphs(updateParagraphs);
  }
}
//# sourceMappingURL=undo-redo.events.js.map
