import { moveCursorToEnd } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import configStore from '../stores/config.store.js';
import containerStore from '../stores/container.store.js';
import { isMetaContent, isPhrasingContent, isTextNode, toHTMLElement } from '../utils/node.utils.js';
import { addParagraphs, findParagraph, insertNodeInRange, isParagraphEmpty, transformParagraph } from '../utils/paragraph.utils.js';
import { deleteRange, getRange } from '../utils/selection.utils.js';
import { createLinkElement } from '../utils/link.utils.js';
export class PasteEvents {
  constructor() {
    this.onPaste = async ($event) => {
      const pasteHTML = $event.clipboardData.getData('text/html');
      const div = document.createElement('div');
      div.innerHTML = pasteHTML;
      console.log($event.clipboardData.getData('text/plain'), '---', $event.clipboardData.getData('text/html'));
      // User either paste a non-html content or paste text with adapt style - i.e. paste text/plain within a paragraph
      const plainText = div.children.length <= 0;
      if (plainText) {
        const text = $event.clipboardData.getData('text/plain');
        const isUrl = (text) => {
          try {
            const { protocol } = new URL(text);
            return ['http:', 'https:'].includes(protocol);
          }
          catch (_) {
            return false;
          }
        };
        // If user paste a link as plain text we convert it to link
        if (isUrl(text)) {
          const a = createLinkElement({ linkUrl: text });
          a.innerHTML = text;
          div.append(a);
        }
      }
      // It's still plain text and we did not extract any urls
      if (plainText && div.children.length <= 0) {
        return;
      }
      const { range, selection } = getRange(containerStore.state.ref);
      if (!range) {
        return;
      }
      const anchor = toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
      // No anchor so we let the browser deals with it
      if (!anchor) {
        return;
      }
      $event.preventDefault();
      // Undefined if user has removed all paragraphs of the container previously
      const paragraph = toHTMLElement(findParagraph({ element: anchor, container: containerStore.state.ref }));
      this.cleanAttributes(div);
      this.cleanMetas(div);
      const notOnlyText = Array.from(div.childNodes).find((node) => !isPhrasingContent(node)) !== undefined;
      deleteRange(range);
      // If there is only text nodes and span, we consider the paste content as part of a paragraph. e.g. copy/paste a text and a link
      if (!notOnlyText) {
        // addParagraphs fallbacks to container append - this happens in case user delete all the content before parsing
        if (!paragraph) {
          addParagraphs({
            paragraph,
            container: containerStore.state.ref,
            nodes: [div]
          });
          return;
        }
        await this.insertNodes({ range, div });
        return;
      }
      const elements = Array.from(div.childNodes).map((node) => {
        if (isTextNode(node) || node.nodeName.toLowerCase().trim() === 'span') {
          const div = document.createElement('div');
          div.appendChild(node);
          return div;
        }
        return node;
      });
      const empty = isParagraphEmpty({ paragraph });
      if (empty) {
        transformParagraph({
          elements,
          paragraph,
          container: containerStore.state.ref
        });
        return;
      }
      // Extract the rest of the "line" (the paragraph) form the cursor position to end
      const moveFragment = this.splitCurrentParagraph({
        range,
        paragraph
      });
      addParagraphs({
        paragraph,
        container: containerStore.state.ref,
        nodes: [...elements, ...(moveFragment !== undefined ? [moveFragment] : [])]
      });
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('paste', this.onPaste);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('paste', this.onPaste);
  }
  async insertNodes({ range, div }) {
    // convert to fragment to add all nodes at the range position
    const fragment = document.createDocumentFragment();
    fragment.append(...Array.from(div.childNodes));
    const last = await insertNodeInRange({
      observerRoot: containerStore.state.ref,
      range,
      element: fragment
    });
    moveCursorToEnd(last);
  }
  splitCurrentParagraph({ range, paragraph }) {
    if (!paragraph) {
      return undefined;
    }
    range.collapse(true);
    range.setEndAfter(paragraph);
    return range.extractContents();
  }
  cleanAttributes(div) {
    const attributes = [
      ...new Set([...configStore.state.attributes.exclude, 'class', 'style'])
    ];
    const cleanAttr = ({ element, attributes }) => {
      for (const attr of attributes) {
        element.removeAttribute(attr);
      }
    };
    const children = div.querySelectorAll(attributes.map((attr) => `[${attr}]`).join(','));
    for (const child of Array.from(children)) {
      cleanAttr({ element: child, attributes });
    }
    return div;
  }
  // clean all meta, style and title pasted tags
  cleanMetas(div) {
    const metas = Array.from(div.children).filter((node) => isMetaContent(node));
    for (const element of metas) {
      element.parentElement.removeChild(element);
    }
    return div;
  }
}
