import { moveCursorToEnd, moveCursorToStart } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import containerStore from '../stores/container.store.js';
import undoRedoStore from '../stores/undo-redo.store.js';
import { isKeyboardEnter } from '../utils/keyboard.utils.js';
import { elementIndex, isNodeList, toHTMLElement } from '../utils/node.utils.js';
import { addEmptyText, addParagraph, createEmptyParagraph, createNewEmptyLine, findParagraph, isParagraphCode, prependEmptyText } from '../utils/paragraph.utils.js';
import { deleteRange, getRange, getSelection } from '../utils/selection.utils.js';
import { stackUndoParagraphs } from '../utils/undo-redo.utils.js';
export class EnterEvents {
  constructor() {
    this.onKeyDown = async ($event) => {
      if (!isKeyboardEnter($event)) {
        return;
      }
      await this.createParagraph($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  async createParagraph($event) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const anchor = toHTMLElement(selection === null || selection === void 0 ? void 0 : selection.anchorNode);
    // Create only if we have an anchor otherwise let the browser deals with it
    if (!anchor) {
      return;
    }
    const paragraph = toHTMLElement(findParagraph({ element: anchor, container: containerStore.state.ref }));
    // Same as above but should not happen
    if (!paragraph) {
      return;
    }
    // In "list" we use return to create new lines
    if (isNodeList({ node: paragraph })) {
      return;
    }
    $event.preventDefault();
    // We undo-redo stack an update of the current paragraph value
    const undoParagraphs = this.toUpdateParagraphs([paragraph]);
    deleteRange(range);
    // Extract the rest of the "line" (the paragraph) form the cursor position to end
    range.collapse(true);
    range.setEndAfter(paragraph);
    const fragment = range.cloneContents();
    const isEndOfParagraph = fragment.textContent === '';
    const { shiftKey } = $event;
    if (shiftKey || isParagraphCode({ paragraph })) {
      await this.createLineBreak({ anchor, paragraph, isEndOfParagraph, range, undoParagraphs });
      return;
    }
    // We created a new paragraph with the cursor at the end aka we pressed "Enter" with the cursor at the end of the paragraph
    if (isEndOfParagraph) {
      const newParagraph = await createEmptyParagraph({
        container: containerStore.state.ref,
        paragraph
      });
      moveCursorToEnd(newParagraph);
      return;
    }
    await this.createParagraphWithContent({
      range,
      paragraph,
      undoParagraphs
    });
  }
  async createParagraphWithContent({ paragraph, range, undoParagraphs }) {
    // We have to handle undo-redo manually because we want the redo to redo everything in one block
    undoRedoStore.state.observe = false;
    // The new fragment is a div - i.e. is a paragraph
    const moveFragment = range.extractContents();
    const newParagraph = await addParagraph({
      container: containerStore.state.ref,
      paragraph,
      fragment: moveFragment
    });
    // We undo-redo stack the new paragraph to remove it on undo
    const addRemoveParagraphs = this.toAddParagraphs([toHTMLElement(newParagraph)]);
    // If original paragraph is now empty - the all content has been moved to a new paragraph - we add a zero length width otherwise the div has no height
    // We do not need to add this to undo-redo stack
    // Happens for example when user click enter at the begin of the paragraph
    if (paragraph.textContent === '') {
      await prependEmptyText({ paragraph });
    }
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs,
      updateParagraphs: undoParagraphs
    });
    // We don't move the cursor, we keep the position at the beginning of the new paragraph
    undoRedoStore.state.observe = true;
    moveCursorToStart(newParagraph);
  }
  toAddParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph),
      mutation: 'add'
    }));
  }
  toUpdateParagraphs(paragraphs) {
    return paragraphs.map((paragraph) => ({
      outerHTML: paragraph.outerHTML,
      index: elementIndex(paragraph)
    }));
  }
  async createLineBreak({ anchor, paragraph, isEndOfParagraph, range, undoParagraphs }) {
    undoRedoStore.state.observe = false;
    stackUndoParagraphs({
      container: containerStore.state.ref,
      addRemoveParagraphs: [],
      updateParagraphs: undoParagraphs
    });
    // Reset range end we do not want to select empty text
    range.setEndAfter(getSelection(containerStore.state.ref).anchorNode);
    const newNode = await createNewEmptyLine({
      paragraph: anchor,
      range
    });
    if (!isEndOfParagraph || !newNode) {
      moveCursorToStart(newNode);
      undoRedoStore.state.observe = true;
      return;
    }
    const text = await addEmptyText({
      paragraph,
      element: newNode
    });
    moveCursorToStart(text);
    undoRedoStore.state.observe = true;
  }
}
