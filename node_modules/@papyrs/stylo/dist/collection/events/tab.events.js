import { moveCursorToEnd, moveCursorToStart } from '@deckdeckgo/utils';
import containerStore from '../stores/container.store';
import { isNodeList, isTextNode, nodeIndex } from '../utils/node.utils';
import { findParagraph, isParagraph } from '../utils/paragraph.utils';
import { getRange } from '../utils/selection.utils';
export class TabEvents {
  constructor() {
    this.onKeyDown = async ($event) => {
      const { key } = $event;
      if (!['Tab'].includes(key)) {
        return;
      }
      $event.preventDefault();
      await this.catchTab($event);
    };
  }
  init() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown);
  }
  destroy() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  async catchTab({ shiftKey }) {
    const { range, selection } = getRange(containerStore.state.ref);
    if (!range) {
      return;
    }
    const node = selection === null || selection === void 0 ? void 0 : selection.focusNode;
    const paragraph = findParagraph({
      element: node,
      container: containerStore.state.ref
    });
    if (paragraph && isNodeList({ node: paragraph })) {
      await this.createSublist({ paragraph, node, range, shiftKey });
      return;
    }
    // Shiftkey only useful to replace sublist
    if (shiftKey) {
      return;
    }
    this.createTabulation({ range, node, paragraph });
  }
  createTabulation({ range, node, paragraph }) {
    if (!isTextNode(node)) {
      if (paragraph !== undefined) {
        this.insertSpanTabulation({ range });
        return;
      }
      return;
    }
    this.insertSpanTabulation({ range });
  }
  insertSpanTabulation({ range }) {
    const span = document.createElement('span');
    span.innerHTML = '\u0009';
    range === null || range === void 0 ? void 0 : range.insertNode(span);
    moveCursorToEnd(span);
  }
  async createSublist({ paragraph, node, range, shiftKey }) {
    // If list contains a single child that is just text then browser returns the list as focus node
    const focusNodeIsList = node !== undefined && isNodeList({ node: node });
    const paragraphListNodeName = paragraph.nodeName.toLowerCase();
    const li = focusNodeIsList
      ? node.firstChild
      : this.findParentElement({
        element: node,
        paragraph,
        nodeName: 'li'
      });
    if (!li) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    const ul = focusNodeIsList
      ? node
      : this.findParentElement({
        element: node,
        paragraph,
        nodeName: paragraphListNodeName
      });
    if (!ul) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    if (shiftKey) {
      // We do not want to remove the top ul
      if (isParagraph({ element: ul, container: containerStore.state.ref })) {
        return;
      }
      // Move cursor end to newly created list
      const observer = new MutationObserver((mutations) => {
        var _a;
        observer.disconnect();
        const addedFirstNode = (_a = mutations.find(({ addedNodes }) => addedNodes.length > 0)) === null || _a === void 0 ? void 0 : _a.addedNodes[0];
        // Move cursor to new li
        moveCursorToStart(addedFirstNode);
      });
      observer.observe(paragraph, { childList: true, subtree: true });
      const newRange = new Range();
      newRange.setStartBefore(li);
      newRange.setEndAfter(ul.lastChild);
      const liIndex = nodeIndex(li);
      const contents = newRange.extractContents();
      // If we shift-tab first li of the ul, we want to replace the all ul
      if (liIndex === 0) {
        ul.parentElement.replaceChild(contents, ul);
        return;
      }
      // Else we want to bring the other li from the selected to end of this ul one level higher
      ul.parentElement.insertBefore(contents, ul.nextSibling);
      return;
    }
    const { endOffset, commonAncestorContainer } = range;
    const empty = commonAncestorContainer.textContent.length === 0;
    const cursorEnd = endOffset === commonAncestorContainer.textContent.length;
    const lastChild = commonAncestorContainer.isSameNode(this.findLastChild(li));
    if ((!cursorEnd || !lastChild) && !empty) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    // We do not want to index list that has a single element
    if (ul.childNodes.length === 1) {
      this.createTabulation({ range, node, paragraph });
      return;
    }
    // Move cursor end or start to added child
    const observer = new MutationObserver((mutations) => {
      var _a;
      observer.disconnect();
      const addedFirstNode = (_a = mutations.find(({ addedNodes }) => addedNodes.length > 0)) === null || _a === void 0 ? void 0 : _a.addedNodes[0];
      if (!addedFirstNode) {
        return;
      }
      const focusNode = isNodeList({ node: addedFirstNode })
        ? addedFirstNode.firstChild
        : addedFirstNode;
      // Move cursor to new li. If empty we move to start because maybe it contains a br a last child.
      if (addedFirstNode.textContent.length === 0) {
        moveCursorToStart(focusNode);
        return;
      }
      moveCursorToEnd(focusNode);
    });
    observer.observe(paragraph, { childList: true, subtree: true });
    // Previous sibling is a list so, we can move the li there
    if (li.previousSibling && isNodeList({ node: li.previousSibling })) {
      li.previousSibling.appendChild(li);
      return;
    }
    // Clone li and append it to a new sublist, a new ul
    const newRange = new Range();
    newRange.selectNode(li);
    const contents = newRange.cloneContents();
    const newUl = document.createElement(paragraphListNodeName);
    newUl.append(contents);
    // Replace li with new ul
    ul.replaceChild(newUl, li);
  }
  findParentElement({ element, paragraph, nodeName }) {
    const { nodeName: elementNodeName, parentElement } = element;
    if (elementNodeName.toLowerCase() === nodeName) {
      return element;
    }
    // We iterated till the paragraph and even the paragraph is not the nodeName we are looking for
    if (isParagraph({ element, container: containerStore.state.ref })) {
      return undefined;
    }
    return this.findParentElement({ element: parentElement, paragraph, nodeName });
  }
  findLastChild(element) {
    if (element.lastChild !== null) {
      return this.findLastChild(element.lastChild);
    }
    return element;
  }
}
