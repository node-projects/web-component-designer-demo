import { clearTheSelection, debounce, getAnchorElement, isIOS, isRTL, unifyEvent } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import { h } from '@stencil/core';
import configStore from '../../../../stores/config.store.js';
import { ToolbarActions, ToolbarAlign } from '../../../../types/toolbar.js';
import { actionBold, actionItalic, actionUnderline } from '../../../../utils/execcomand-text.utils.js';
import { execCommand as execCommandCustom } from '../../../../utils/execcommand.utils.js';
import { execCommandNative } from '../../../../utils/execcommnad-native.utils.js';
import { removeLink } from '../../../../utils/link.utils.js';
import { isMobile } from '../../../../utils/mobile.utils.js';
import { toHTMLElement } from '../../../../utils/node.utils.js';
import { findParagraph, isParagraph } from '../../../../utils/paragraph.utils.js';
import { getRange, getSelection } from '../../../../utils/selection.utils.js';
import { getBold, getContentAlignment, getFontSize, getItalic, getList, getStrikeThrough, getUnderline } from '../../../../utils/toolbar.utils.js';
import { Style } from '../actions/style/style.js';
export class Toolbar {
  constructor() {
    this.debounceDisplayToolsActivated = debounce(() => {
      this.displayToolsActivated = true;
      this.toolbarActivated.emit(true);
    });
    this.selection = null;
    this.selectionParagraph = undefined;
    this.anchorLink = null;
    this.rtl = isRTL();
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (['Escape'].includes(code)) {
        this.reset(false);
        return;
      }
      this.styleKeyboardShortcuts($event);
    };
    this.startSelection = ($event) => {
      this.anchorEvent = {
        $event,
        composedPath: $event.composedPath()
      };
    };
    this.toggleLink = () => {
      if (this.link) {
        removeLink(this.containerRef);
        this.reset(true);
      }
      else {
        this.openLink();
      }
    };
    /***
     * The toolbar is already displayed and we want to switch the actions
     */
    this.switchToolbarActions = (actions) => (this.toolbarActions = actions);
    this.onExecCommand = ($event) => {
      this.execCommand($event.detail);
    };
    this.config = undefined;
    this.containerRef = undefined;
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
    this.align = undefined;
    this.list = undefined;
    this.fontSize = undefined;
    this.disabledTitle = false;
    this.toolsActivated = false;
    this.displayToolsActivated = false;
    this.link = false;
    this.toolbarActions = ToolbarActions.STYLE;
    this.toolsPosition = undefined;
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  componentWillLoad() {
    this.initDefaultContentAlign();
    this.applyStandaloneConfig();
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  onContainerRef() {
    if (!this.containerRef) {
      return;
    }
    this.removeListener();
    this.addListener();
  }
  onConfigChange() {
    this.applyStandaloneConfig();
  }
  applyStandaloneConfig() {
    if (!this.config) {
      return;
    }
    configStore.state.toolbar = Object.assign(Object.assign({}, configStore.state.toolbar), this.config);
  }
  styleKeyboardShortcuts($event) {
    const { metaKey, ctrlKey, key } = $event;
    if (!metaKey && !ctrlKey) {
      return;
    }
    if (!['b', 'i', 'u', 'k'].includes(key)) {
      return;
    }
    $event.preventDefault();
    $event.stopPropagation();
    switch (key) {
      case 'b':
        this.execCommand(actionBold);
        break;
      case 'i':
        this.execCommand(actionItalic);
        break;
      case 'u':
        this.execCommand(actionUnderline);
        break;
      case 'k':
        this.openLink();
        break;
    }
  }
  onContextMenu() {
    this.reset(false);
  }
  onSelectionChange() {
    if ([ToolbarActions.COLOR, ToolbarActions.BACKGROUND_COLOR, ToolbarActions.LINK].includes(this.toolbarActions)) {
      return;
    }
    this.displayTools();
  }
  onResize() {
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.reset(true);
  }
  onContainerClick($event) {
    if ([ToolbarActions.COLOR, ToolbarActions.BACKGROUND_COLOR, ToolbarActions.LINK].includes(this.toolbarActions)) {
      return;
    }
    $event.preventDefault();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('mousedown', this.startSelection, { passive: true });
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('touchstart', this.startSelection, { passive: true });
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('keydown', this.onKeyDown);
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('mousedown', this.startSelection);
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('touchstart', this.startSelection);
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('keydown', this.onKeyDown);
  }
  displayTools() {
    let selection = getSelection(this.containerRef);
    if (!this.anchorEvent) {
      this.reset(false);
      return;
    }
    const { $event, composedPath } = this.anchorEvent;
    if (this.containerRef &&
      !this.containerRef.contains($event.target) &&
      !this.containerRef.contains(composedPath[0])) {
      this.reset(false);
      return;
    }
    if (!selection || !selection.toString() || selection.toString().trim().length <= 0) {
      this.reset(false);
      return;
    }
    const activated = this.activateToolbar(selection);
    this.setToolsActivated(activated);
    if (!this.toolsActivated) {
      return;
    }
    this.selection = selection;
    this.selectionParagraph = findParagraph({
      element: !this.selection ? document.activeElement : this.selection.anchorNode,
      container: this.containerRef
    });
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      this.anchorLink = {
        range: range.cloneRange()
      };
      this.setToolbarAnchorPosition();
    }
  }
  setToolbarAnchorPosition() {
    if (!this.tools) {
      return;
    }
    const { $event } = this.anchorEvent;
    const eventX = unifyEvent($event).clientX;
    const eventY = unifyEvent($event).clientY;
    const { range } = getRange(this.containerRef);
    const selectionRect = range === null || range === void 0 ? void 0 : range.getBoundingClientRect();
    // Calculate the absolute position on the screen where the container should be (if it's above the selection)
    const targetAbsoluteX = selectionRect
      ? selectionRect.x + selectionRect.width / 2
      : eventX;
    const targetAbsoluteY = selectionRect ? selectionRect.y : eventY;
    const { x, y } = this.el.shadowRoot.host.getBoundingClientRect();
    // calculate the relative position between the containers
    const relativeX = targetAbsoluteX - x;
    const relativeY = targetAbsoluteY - y;
    const position = eventY > 100 ? 'above' : 'under';
    // TODO: this maybe not always be the case that the whole window size could be used for overlay
    const { innerWidth } = window;
    const topOffset = 16;
    const top = position === 'above' ? relativeY - topOffset : relativeY + ((selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.height) || 0) + 8;
    const safeAreaMarginX = 32;
    // Limit overflow right
    const overflowLeft = this.tools.offsetWidth / 2 + safeAreaMarginX > relativeX;
    const fixedLeft = ((selectionRect === null || selectionRect === void 0 ? void 0 : selectionRect.left) || eventX) - 40;
    const overflowRight = innerWidth > 0 && fixedLeft > innerWidth - (this.tools.offsetWidth / 2 + safeAreaMarginX);
    const left = overflowRight
      ? `${innerWidth - x - this.tools.offsetWidth - safeAreaMarginX}px`
      : overflowLeft
        ? `${safeAreaMarginX}px`
        : `${relativeX}px`;
    const right = `auto`;
    // To set the position of the tools
    this.toolsPosition = {
      top,
      left,
      right,
      position,
      align: overflowRight ? 'end' : overflowLeft ? 'start' : 'center',
      anchorLeft: overflowLeft
        ? relativeX - safeAreaMarginX
        : overflowRight
          ? relativeX - (innerWidth - safeAreaMarginX - this.tools.offsetWidth)
          : this.tools.offsetWidth / 2
    };
  }
  activateToolbar(selection) {
    const tools = selection && selection.toString() && selection.toString().length > 0;
    if (tools) {
      this.initStyle(selection);
      this.initLink(selection);
    }
    return tools;
  }
  initStyle(selection) {
    if (!selection || selection.rangeCount <= 0) {
      return;
    }
    const content = getAnchorElement(selection);
    if (!content) {
      return;
    }
    this.initStyleForNode(content);
  }
  initStyleForNode(node) {
    this.bold = undefined;
    this.italic = undefined;
    this.underline = undefined;
    this.strikethrough = undefined;
    this.list = undefined;
    this.fontSize = undefined;
    this.initDefaultContentAlign();
    this.findStyle(node);
  }
  initDefaultContentAlign() {
    this.align = this.rtl ? ToolbarAlign.RIGHT : ToolbarAlign.LEFT;
  }
  // We iterate until we find the root container to detect if bold, underline or italic are active
  findStyle(node) {
    if (!node || node instanceof ShadowRoot) {
      return;
    }
    // Just in case
    if (node.nodeName.toUpperCase() === 'HTML' || node.nodeName.toUpperCase() === 'BODY') {
      return;
    }
    if (this.bold === undefined) {
      this.bold = getBold(toHTMLElement(node));
    }
    if (this.italic === undefined) {
      this.italic = getItalic(toHTMLElement(node));
    }
    if (this.underline === undefined) {
      this.underline = getUnderline(toHTMLElement(node));
    }
    if (this.strikethrough === undefined) {
      this.strikethrough = getStrikeThrough(toHTMLElement(node));
    }
    if (this.list === undefined) {
      this.list = getList(toHTMLElement(node));
    }
    if (this.fontSize === undefined) {
      this.fontSize = getFontSize(toHTMLElement(node));
    }
    if (isParagraph({ element: node, container: this.containerRef })) {
      const nodeName = node.nodeName.toUpperCase();
      this.disabledTitle =
        nodeName === 'H1' ||
          nodeName === 'H2' ||
          nodeName === 'H3' ||
          nodeName === 'H4' ||
          nodeName === 'H5' ||
          nodeName === 'H6';
      this.align = getContentAlignment(toHTMLElement(node));
      return;
    }
    this.findStyle(node.parentNode);
  }
  initLink(selection) {
    if (!selection) {
      return;
    }
    let content = selection.anchorNode;
    if (!content) {
      return;
    }
    if (content.nodeType === 3) {
      content = content.parentElement;
    }
    this.link = content.nodeName && content.nodeName.toLowerCase() === 'a';
  }
  /**
   * Reset the inline editor (= hide it) and optionally clear its selection.
   * @param clearSelection
   * @param blurActiveElement
   */
  reset(clearSelection, blurActiveElement) {
    if (clearSelection) {
      clearTheSelection();
    }
    this.setToolsActivated(false);
    if (clearSelection) {
      // We don't want to emit that state a zillion time but only when needed
      this.toolbarActivated.emit(false);
    }
    this.selection = null;
    this.selectionParagraph = null;
    this.toolbarActions = ToolbarActions.STYLE;
    this.anchorLink = null;
    this.link = false;
    if (blurActiveElement &&
      document.activeElement &&
      document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  }
  openLink() {
    this.toolbarActions = ToolbarActions.LINK;
  }
  setToolsActivated(activated) {
    this.toolsActivated = activated;
    if (activated) {
      this.debounceDisplayToolsActivated();
    }
    else {
      this.displayToolsActivated = false;
    }
  }
  execCommand(action) {
    // onSelectionChange is triggered if DOM changes, we still need to detect attributes changes to refresh style
    this.onAttributesChangesInitStyle();
    if (configStore.state.toolbar.command === 'native') {
      execCommandNative(action);
    }
    else {
      execCommandCustom(this.selection, action, this.containerRef);
    }
    const { cmd } = action;
    if (cmd === 'list' || isIOS()) {
      this.reset(true);
    }
    if (!this.selectionParagraph) {
      return;
    }
    this.styleDidChange.emit(toHTMLElement(this.selectionParagraph));
  }
  onAttributesChangesInitStyle() {
    const anchorNode = getAnchorElement(this.selection);
    if (!anchorNode) {
      return;
    }
    const observer = new MutationObserver(() => {
      observer.disconnect();
      this.initStyleForNode(anchorNode);
    });
    observer.observe(anchorNode, { attributes: true });
  }
  render() {
    var _a, _b;
    let classNames = this.displayToolsActivated ? 'tools tools-activated' : 'tools';
    const position = ((_a = this.toolsPosition) === null || _a === void 0 ? void 0 : _a.position) || 'above';
    const style = this.toolsPosition
      ? {
        '--actions-top': `${this.toolsPosition.top}px`,
        '--actions-left': this.toolsPosition.left,
        '--actions-right': this.toolsPosition.right,
        '--actions-translate-x': `${this.toolsPosition.align === 'center' ? '-50%' : '0'}`,
        '--actions-translate-y': `${this.toolsPosition.position === 'above' ? '-100%' : '0'}`
      }
      : undefined;
    return (h("div", { class: classNames, ref: (el) => (this.tools = el), style: style, onClick: ($event) => $event.stopPropagation(), onMouseDown: ($event) => this.onContainerClick($event), onTouchStart: ($event) => this.onContainerClick($event) }, h("stylo-toolbar-triangle", { class: position === 'above' ? 'bottom' : 'top', style: {
        '--stylo-toolbar-triangle-start': `${(_b = this.toolsPosition) === null || _b === void 0 ? void 0 : _b.anchorLeft}px`
      } }), this.renderActions()));
  }
  renderActions() {
    if (this.toolbarActions === ToolbarActions.LINK) {
      return (h("stylo-toolbar-link", { containerRef: this.containerRef, toolbarActions: this.toolbarActions, anchorLink: this.anchorLink, linkCreated: this.linkCreated, onLinkModified: ($event) => this.reset($event.detail), onClose: () => this.reset(false) }));
    }
    if (this.toolbarActions === ToolbarActions.COLOR ||
      this.toolbarActions === ToolbarActions.BACKGROUND_COLOR) {
      return (h("stylo-toolbar-color", { containerRef: this.containerRef, action: this.toolbarActions === ToolbarActions.BACKGROUND_COLOR ? 'background-color' : 'color', onExecCommand: this.onExecCommand, onClose: () => this.reset(false) }));
    }
    if (this.toolbarActions === ToolbarActions.ALIGNMENT) {
      return (h("stylo-toolbar-align", { containerRef: this.containerRef, anchorEvent: this.anchorEvent.$event, align: this.align, onAlignModified: () => this.reset(true) }));
    }
    if (this.toolbarActions === ToolbarActions.LIST) {
      return (h("stylo-toolbar-list", { list: this.list, onExecCommand: this.onExecCommand }));
    }
    if (this.toolbarActions === ToolbarActions.FONT_SIZE) {
      return (h("stylo-toolbar-font-size", { fontSize: this.fontSize, onExecCommand: this.onExecCommand }));
    }
    return (h(Style, { align: this.align, list: this.list, switchToolbarActions: this.switchToolbarActions, bold: this.bold, disabledTitle: this.disabledTitle, italic: this.italic, strikethrough: this.strikethrough, underline: this.underline, link: this.link, onExecCommand: this.onExecCommand, toggleLink: this.toggleLink }));
  }
  static get is() { return "stylo-toolbar"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["toolbar.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["toolbar.css"]
    };
  }
  static get properties() {
    return {
      "config": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "Partial<StyloConfigToolbar> | undefined",
          "resolved": "{ palette?: StyloPalette[]; command?: \"custom\" | \"native\"; style?: { list: boolean; align: boolean; fontSize: boolean; backgroundColor: boolean; }; }",
          "references": {
            "Partial": {
              "location": "global"
            },
            "StyloConfigToolbar": {
              "location": "import",
              "path": "../../../../types/toolbar"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "If used in a standalone mode, the configuration can also be set. It will be applied over the default configuration."
        }
      },
      "containerRef": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "HTMLElement | undefined",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "To attach the inline editor event listeners to a specific container instead of the document"
        }
      }
    };
  }
  static get states() {
    return {
      "bold": {},
      "italic": {},
      "underline": {},
      "strikethrough": {},
      "align": {},
      "list": {},
      "fontSize": {},
      "disabledTitle": {},
      "toolsActivated": {},
      "displayToolsActivated": {},
      "link": {},
      "toolbarActions": {},
      "toolsPosition": {}
    };
  }
  static get events() {
    return [{
        "method": "toolbarActivated",
        "name": "toolbarActivated",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        }
      }, {
        "method": "linkCreated",
        "name": "linkCreated",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Triggered when a link is created by the user. The event detail is the container"
        },
        "complexType": {
          "original": "HTMLElement",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        }
      }, {
        "method": "styleDidChange",
        "name": "styleDidChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Triggered when the style is modified (bold, italic, color, alignment, etc.). The event detail is the container"
        },
        "complexType": {
          "original": "HTMLElement",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        }
      }];
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "containerRef",
        "methodName": "onContainerRef"
      }, {
        "propName": "config",
        "methodName": "onConfigChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "contextmenu",
        "method": "onContextMenu",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "selectionchange",
        "method": "onSelectionChange",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "resize",
        "method": "onResize",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
