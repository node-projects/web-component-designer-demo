import { getAnchorElement, hexToRgb } from '@deckdeckgo/utils';
import { h } from '@stencil/core';
import configStore from '../../../../../stores/config.store';
import { toHTMLElement } from '../../../../../utils/node.utils';
import { getRange, getSelection } from '../../../../../utils/selection.utils';
import { findStyleNode } from '../../../../../utils/toolbar.utils';
export class Color {
  constructor() {
    this.closeToolbar = () => {
      this.close.emit();
    };
    this.action = undefined;
    this.containerRef = undefined;
    this.colorRgb = undefined;
  }
  componentWillLoad() {
    this.initColor();
  }
  connectedCallback() {
    this.addListener();
  }
  disconnectedCallback() {
    this.removeListener();
  }
  addListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.addEventListener('click', this.closeToolbar, { passive: true });
  }
  removeListener() {
    const listenerElement = this.containerRef || document;
    listenerElement === null || listenerElement === void 0 ? void 0 : listenerElement.removeEventListener('click', this.closeToolbar);
  }
  initColor() {
    const { range, selection } = getRange(this.containerRef);
    this.range = range;
    const anchor = getAnchorElement(selection);
    if (!anchor) {
      return;
    }
    const style = findStyleNode(anchor, this.action === 'color' ? 'color' : 'background-color', this.containerRef);
    if (!style) {
      return;
    }
    const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(toHTMLElement(style));
    this.colorRgb = (this.action === 'color' ? css.color : css.backgroundColor)
      .replace('rgb(', '')
      .replace(')', '');
  }
  selectColor($event) {
    const selection = getSelection(this.containerRef);
    if (!selection || !$event || !$event.detail) {
      return;
    }
    if (!this.action) {
      return;
    }
    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
    selection === null || selection === void 0 ? void 0 : selection.addRange(this.range);
    const observer = new MutationObserver((_mutations) => {
      observer.disconnect();
      // No node were added so the style was modified
      this.range = selection === null || selection === void 0 ? void 0 : selection.getRangeAt(0);
    });
    const anchorNode = getAnchorElement(selection);
    if (!anchorNode) {
      return;
    }
    observer.observe(anchorNode, { childList: true });
    this.execCommand.emit({
      cmd: 'style',
      detail: {
        style: this.action,
        value: $event.detail.hex,
        initial: (element) => {
          const rgb = hexToRgb($event.detail.hex);
          return (element &&
            (element.style[this.action] === $event.detail.hex ||
              element.style[this.action] === `rgb(${rgb})`));
        }
      }
    });
  }
  render() {
    return (h("stylo-color", { "color-rgb": this.colorRgb, onColorChange: ($event) => this.selectColor($event), palette: configStore.state.toolbar.palette }));
  }
  static get is() { return "stylo-toolbar-color"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["color.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["color.css"]
    };
  }
  static get properties() {
    return {
      "action": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "'color' | 'background-color'",
          "resolved": "\"background-color\" | \"color\"",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        },
        "attribute": "action",
        "reflect": false
      },
      "containerRef": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "HTMLElement | undefined",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": ""
        }
      }
    };
  }
  static get states() {
    return {
      "colorRgb": {}
    };
  }
  static get events() {
    return [{
        "method": "execCommand",
        "name": "execCommand",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "ExecCommandAction",
          "resolved": "ExecCommandAction",
          "references": {
            "ExecCommandAction": {
              "location": "import",
              "path": "../../../../../types/execcommand"
            }
          }
        }
      }, {
        "method": "close",
        "name": "close",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": ""
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
}
//# sourceMappingURL=color.js.map
