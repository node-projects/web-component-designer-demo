import { debounce } from '@deckdeckgo/utils';
import { Fragment, h } from '@stencil/core';
import { DataEvents } from '../../events/data.events';
import { EnterEvents } from '../../events/enter.events';
import { InputEvents } from '../../events/input.events';
import { PasteEvents } from '../../events/paste.events';
import { PlaceholderEvents } from '../../events/placeholder.events';
import { TabEvents } from '../../events/tab.events';
import { UndoRedoEvents } from '../../events/undo-redo.events';
import configStore, { DEFAULT_EXCLUDE_ATTRIBUTES, DEFAULT_PARAGRAPH_IDENTIFIER, DEFAULT_PLACEHOLDERS, DEFAULT_PLUGINS, DEFAULT_TEXT_PARAGRAPHS, DEFAULT_TOOLBAR } from '../../stores/config.store';
import containerStore from '../../stores/container.store';
import i18n from '../../stores/i18n.store';
import undoRedoStore from '../../stores/undo-redo.store';
import { injectCSS } from '../../utils/css.utils';
import { isMobile } from '../../utils/mobile.utils';
export class Editor {
  constructor() {
    this.debounceSize = debounce(() => this.applySize(), 250);
    this.undoRedoEvents = new UndoRedoEvents();
    this.enterEvents = new EnterEvents();
    this.placeHolderEvents = new PlaceholderEvents();
    this.inputEvents = new InputEvents();
    this.tabEvents = new TabEvents();
    this.dataEvents = new DataEvents();
    this.pasteEvents = new PasteEvents();
    this.mobile = isMobile();
    this.config = undefined;
    this.containerRef = undefined;
    this.contentEditable = true;
  }
  componentWillLoad() {
    this.init();
    this.applyConfig();
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', this.debounceSize);
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', this.debounceSize);
    this.destroy();
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  onContainerRefChange() {
    this.destroy();
    this.init();
  }
  onConfigChange() {
    this.destroy();
    this.applyConfig();
    this.initEvents();
  }
  applySize() {
    var _a;
    if (this.mobile) {
      return;
    }
    containerStore.state.size = (_a = this.containerRef) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  }
  init() {
    containerStore.state.ref = this.containerRef;
    if (!this.containerRef) {
      return;
    }
    injectCSS({ rootNode: this.containerRef.getRootNode() });
    containerStore.state.ref.classList.add('stylo-container');
    this.containerRefEditable();
    this.applySize();
    this.initEvents();
  }
  /**
   * Observe and init containerref "contenteditable" state. Notably useful in case consumer toggles such state.
   */
  containerRefEditable() {
    var _a;
    (_a = this.attributesObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this.attributesObserver = new MutationObserver((mutations) => {
      const contentEditableChanged = mutations.find(({ attributeName }) => ['contenteditable'].includes(attributeName.toLowerCase()));
      if (!contentEditableChanged) {
        return;
      }
      this.contentEditable = this.isContentEditable();
      if (this.contentEditable) {
        this.initEvents();
        return;
      }
      this.destroy();
    });
    this.attributesObserver.observe(containerStore.state.ref, { attributes: true });
    this.contentEditable = this.isContentEditable();
  }
  isContentEditable() {
    return ['true', ''].includes(this.containerRef.getAttribute('contenteditable'));
  }
  applyConfig() {
    var _a, _b;
    if (!this.config) {
      return;
    }
    const { plugins, toolbar, i18n: customI18n, placeholders, textParagraphs, menus, attributes } = this.config;
    i18n.state.custom = customI18n === null || customI18n === void 0 ? void 0 : customI18n.custom;
    i18n.state.lang = (customI18n === null || customI18n === void 0 ? void 0 : customI18n.lang) || 'en';
    configStore.state.plugins = plugins || DEFAULT_PLUGINS;
    configStore.state.toolbar = toolbar
      ? Object.assign(Object.assign({}, configStore.state.toolbar), toolbar) : DEFAULT_TOOLBAR;
    configStore.state.placeholders = placeholders || DEFAULT_PLACEHOLDERS;
    configStore.state.textParagraphs = textParagraphs || DEFAULT_TEXT_PARAGRAPHS;
    configStore.state.menus = menus;
    const paragraphIdentifier = (_a = attributes === null || attributes === void 0 ? void 0 : attributes.paragraphIdentifier) !== null && _a !== void 0 ? _a : DEFAULT_PARAGRAPH_IDENTIFIER;
    configStore.state.attributes = {
      paragraphIdentifier,
      exclude: [
        ...new Set([
          ...((_b = attributes === null || attributes === void 0 ? void 0 : attributes.exclude) !== null && _b !== void 0 ? _b : []),
          ...DEFAULT_EXCLUDE_ATTRIBUTES,
          paragraphIdentifier
        ])
      ]
    };
  }
  destroy() {
    this.undoRedoEvents.destroy();
    this.inputEvents.destroy();
    this.enterEvents.destroy();
    this.placeHolderEvents.destroy();
    this.tabEvents.destroy();
    this.dataEvents.destroy();
    this.pasteEvents.destroy();
    undoRedoStore.state.undo = [];
    undoRedoStore.state.redo = [];
  }
  initEvents() {
    if (!this.contentEditable) {
      return;
    }
    this.inputEvents.init();
    this.enterEvents.init();
    this.placeHolderEvents.init({ editorRef: this.el });
    this.tabEvents.init();
    this.dataEvents.init({ editorRef: this.el });
    this.undoRedoEvents.init();
    this.pasteEvents.init();
  }
  render() {
    var _a;
    if (!this.contentEditable) {
      return undefined;
    }
    return (h(Fragment, null, h("stylo-add", null), h("stylo-plugins", null), this.renderToolbar(), ((_a = configStore.state.menus) === null || _a === void 0 ? void 0 : _a.length) && h("stylo-menus", null)));
  }
  renderToolbar() {
    if (this.mobile) {
      return undefined;
    }
    return h("stylo-toolbar", { containerRef: this.containerRef });
  }
  static get is() { return "stylo-editor"; }
  static get originalStyleUrls() {
    return {
      "$": ["editor.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["editor.css"]
    };
  }
  static get properties() {
    return {
      "config": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "StyloConfig | undefined",
          "resolved": "StyloConfig",
          "references": {
            "StyloConfig": {
              "location": "import",
              "path": "../../types/config"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Optional editor configurations\n- i18n provides language and optional list of custom translations\n- plugins, if provided, replaces the default plugin config\n- Toolbar, if provided, is merged with the default toolbar config\n- Menus, if provided, is merged with the default menus config"
        }
      },
      "containerRef": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "HTMLElement | undefined",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The container (e.g. an article, a div, etc.) that contains the content, the paragraphs.\nMust have the attribute `contenteditable` set to `true`."
        }
      }
    };
  }
  static get states() {
    return {
      "contentEditable": {}
    };
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "containerRef",
        "methodName": "onContainerRefChange"
      }, {
        "propName": "config",
        "methodName": "onConfigChange"
      }];
  }
}
