import { h, Host } from '@stencil/core';
import configStore from '../../../stores/config.store.js';
import containerStore from '../../../stores/container.store.js';
import { isMobile } from '../../../utils/mobile.utils.js';
import { toHTMLElement } from '../../../utils/node.utils.js';
import { focusParagraph } from '../../../utils/paragraph.utils.js';
export class Plugins {
  constructor() {
    this.display = false;
    this.position = undefined;
  }
  componentWillLoad() {
    this.destroyListener = containerStore.onChange('size', () => {
      if (isMobile()) {
        return;
      }
      this.hide();
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  /**
   * If user click anywhere not in the stylo-editor, hide the transform options
   */
  onClick(_$event) {
    this.hide();
  }
  onHidePlugins() {
    this.hide();
  }
  hide() {
    this.display = false;
    // To make the visual transition not glitchy, we hide first and then move the component outside
    setTimeout(() => (this.position = undefined), 150);
  }
  onListPlugins({ detail: paragraph }) {
    if (!paragraph) {
      this.hide();
      return;
    }
    const { height, top } = paragraph.getBoundingClientRect();
    // top + size + margin
    const downward = top + 220 + 16 < (window.innerHeight || screen.height);
    this.position = {
      top: paragraph.offsetTop + (downward ? height : -1 * height),
      left: paragraph.offsetLeft,
      downward
    };
    this.paragraph = paragraph;
    this.displayAndFocus();
  }
  displayAndFocus() {
    const onRender = async (_mutations, observer) => {
      var _a;
      if (this.el.style.visibility !== 'visible') {
        return;
      }
      observer.disconnect();
      await ((_a = this.el.shadowRoot.querySelector('stylo-list')) === null || _a === void 0 ? void 0 : _a.focusFirstButton());
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(this.el, { attributes: true, subtree: true });
    setTimeout(() => (this.display = true), 150);
  }
  onCancelPlugins() {
    this.hide();
    focusParagraph({ paragraph: this.paragraph });
  }
  async onApplyPlugin(plugin) {
    if (!containerStore.state.ref || !this.paragraph) {
      return;
    }
    this.hide();
    const { files } = plugin;
    if (files !== undefined) {
      this.openFilePicker(plugin);
      return;
    }
    await this.transformParagraph({ plugin });
  }
  async transformParagraph({ plugin, files }) {
    const { createParagraphs } = plugin;
    await createParagraphs({
      paragraph: toHTMLElement(this.paragraph),
      container: containerStore.state.ref,
      files
    });
  }
  openFilePicker(plugin) {
    const input = this.filePicker(plugin);
    input === null || input === void 0 ? void 0 : input.click();
  }
  async onFilePickerChange(plugin) {
    const input = this.filePicker(plugin);
    if (!input || input.files.length <= 0) {
      return;
    }
    await this.transformParagraph({ plugin, files: input.files });
    // Reset input otherwise a new data cannot be selected
    input.value = '';
  }
  filePicker({ files }) {
    const { accept } = files;
    return this.el.shadowRoot.querySelector(`input[accept="${accept}"]`);
  }
  render() {
    const style = Object.assign(Object.assign({ visibility: this.display ? 'visible' : 'hidden' }, (!this.display && { height: '0px' })), (this.position === undefined
      ? {}
      : {
        '--actions-top': `${this.position.top}px`,
        '--actions-left': `${this.position.left}px`,
        '--actions-translate-y': `${this.position.downward ? '0' : '-100%'}`
      }));
    return (h(Host, { style: style, class: `${this.display ? 'display' : 'hidden'}` }, this.renderList(), this.renderInputs()));
  }
  renderInputs() {
    return configStore.state.plugins
      .filter(({ files }) => files !== undefined)
      .map((plugin) => {
      const { accept, multiple } = plugin.files;
      return (h("input", { type: "file", accept: accept, multiple: multiple, onChange: async () => await this.onFilePickerChange(plugin) }));
    });
  }
  renderList() {
    return (h("stylo-list", { onApplyPlugin: async ({ detail }) => await this.onApplyPlugin(detail), onCancelPlugins: () => this.onCancelPlugins(), display: this.display }));
  }
  static get is() { return "stylo-plugins"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["plugins.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["plugins.css"]
    };
  }
  static get states() {
    return {
      "display": {},
      "position": {}
    };
  }
  static get elementRef() { return "el"; }
  static get listeners() {
    return [{
        "name": "click",
        "method": "onClick",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "hidePlugins",
        "method": "onHidePlugins",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "listPlugins",
        "method": "onListPlugins",
        "target": "document",
        "capture": false,
        "passive": true
      }];
  }
}
