import { Component, Element, Event, Fragment, h, Listen, Method } from '@stencil/core';
import configStore from '../../../stores/config.store.js';
import i18n from '../../../stores/i18n.store.js';
import { renderIcon } from '../../../utils/icon.utils.js';
import { toHTMLElement } from '../../../utils/node.utils.js';
export class List {
  emitPlugin($event, plugin) {
    $event.stopPropagation();
    this.applyPlugin.emit(plugin);
  }
  onKeyDown($event) {
    const { code } = $event;
    if (['Escape'].includes(code)) {
      this.cancelPlugins.emit();
      return;
    }
    if (['ArrowDown'].includes(code)) {
      this.focusNext();
      return;
    }
    if (['ArrowUp'].includes(code)) {
      this.focusPrevious();
    }
    if (['Enter'].includes(code)) {
      $event.stopPropagation();
    }
  }
  async focusFirstButton() {
    var _a;
    this.focusButton = this.el.shadowRoot.querySelector('button');
    (_a = this.focusButton) === null || _a === void 0 ? void 0 : _a.focus();
  }
  focusNext() {
    var _a, _b;
    this.focusButton = toHTMLElement((_a = (this.focusButton || this.el.shadowRoot.firstElementChild)) === null || _a === void 0 ? void 0 : _a.nextElementSibling);
    (_b = this.focusButton) === null || _b === void 0 ? void 0 : _b.focus();
  }
  focusPrevious() {
    var _a, _b;
    this.focusButton = toHTMLElement((_a = (this.focusButton || this.el.shadowRoot.lastElementChild)) === null || _a === void 0 ? void 0 : _a.previousElementSibling);
    (_b = this.focusButton) === null || _b === void 0 ? void 0 : _b.focus();
  }
  render() {
    return (h(Fragment, null, configStore.state.plugins.map((plugin) => this.renderPlugin(plugin))));
  }
  renderPlugin(plugin) {
    var _a, _b;
    const { text, icon: iconSrc } = plugin;
    const icon = renderIcon(iconSrc);
    return (h("button", Object.assign({ onClick: ($event) => this.emitPlugin($event, plugin) }, (icon === undefined && { innerHTML: iconSrc })),
      icon, (_b = (_a = i18n.state.plugins[text]) !== null && _a !== void 0 ? _a : i18n.state.custom[text]) !== null && _b !== void 0 ? _b : text));
  }
  static get is() { return "stylo-list"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["list.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["list.css"]
  }; }
  static get events() { return [{
      "method": "applyPlugin",
      "name": "applyPlugin",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emit which plugin the user want to apply."
      },
      "complexType": {
        "original": "StyloPlugin",
        "resolved": "StyloPlugin",
        "references": {
          "StyloPlugin": {
            "location": "import",
            "path": "../../../types/plugin"
          }
        }
      }
    }, {
      "method": "cancelPlugins",
      "name": "cancelPlugins",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emit when user actually do not want to apply a plugin."
      },
      "complexType": {
        "original": "void",
        "resolved": "void",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "focusFirstButton": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get listeners() { return [{
      "name": "keydown",
      "method": "onKeyDown",
      "target": undefined,
      "capture": false,
      "passive": true
    }]; }
}
