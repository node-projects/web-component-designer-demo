import { Fragment, h } from '@stencil/core';
import configStore from '../../../stores/config.store';
import i18n from '../../../stores/i18n.store';
import { renderIcon } from '../../../utils/icon.utils';
import { toHTMLElement } from '../../../utils/node.utils';
export class List {
  constructor() {
    this.filter = '';
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (['Enter'].includes(code)) {
        return;
      }
      $event.preventDefault();
      if (['Escape'].includes(code)) {
        this.cancelPlugins.emit();
        return;
      }
      if (['ArrowDown'].includes(code)) {
        this.focusNext();
        return;
      }
      if (['ArrowUp'].includes(code)) {
        this.focusPrevious();
        return;
      }
      this.filterPlugins($event);
    };
    this.display = false;
    this.plugins = undefined;
  }
  componentWillLoad() {
    this.plugins = [...configStore.state.plugins];
  }
  componentDidUpdate() {
    this.focusOnUpdate();
  }
  focusOnUpdate() {
    // If only one plugin button is displayed, focus it
    const buttons = this.el.shadowRoot.querySelectorAll('button');
    if (buttons.length === 1) {
      buttons[0].focus();
    }
  }
  emitPlugin($event, plugin) {
    $event.stopPropagation();
    this.applyPlugin.emit(plugin);
  }
  onDisplay() {
    if (this.display) {
      document.addEventListener('keydown', this.onKeyDown);
      return;
    }
    document.removeEventListener('keydown', this.onKeyDown, false);
    this.reset();
  }
  reset() {
    this.filter = '';
    this.plugins = [...configStore.state.plugins];
  }
  async focusFirstButton() {
    var _a;
    this.focusButton = this.el.shadowRoot.querySelector('button');
    (_a = this.focusButton) === null || _a === void 0 ? void 0 : _a.focus();
  }
  focusNext() {
    var _a, _b;
    this.focusButton = toHTMLElement((_a = (this.focusButton || this.el.shadowRoot.firstElementChild)) === null || _a === void 0 ? void 0 : _a.nextElementSibling);
    (_b = this.focusButton) === null || _b === void 0 ? void 0 : _b.focus();
  }
  focusPrevious() {
    var _a, _b;
    this.focusButton = toHTMLElement((_a = (this.focusButton || this.el.shadowRoot.lastElementChild)) === null || _a === void 0 ? void 0 : _a.previousElementSibling);
    (_b = this.focusButton) === null || _b === void 0 ? void 0 : _b.focus();
  }
  filterPlugins($event) {
    const { code, metaKey, ctrlKey, key } = $event;
    if (metaKey || ctrlKey) {
      return;
    }
    // For example Space or ArrowUp
    if (key.length > 1 && !['Backspace'].includes(code)) {
      return;
    }
    this.filter =
      code === 'Backspace'
        ? this.filter.length > 0
          ? this.filter.slice(0, -1)
          : this.filter
        : `${this.filter}${key}`;
    this.plugins = [...configStore.state.plugins].filter(({ text }) => {
      var _a, _b;
      const label = (_b = (_a = i18n.state.plugins[text]) !== null && _a !== void 0 ? _a : i18n.state.custom[text]) !== null && _b !== void 0 ? _b : text;
      return label.toLowerCase().indexOf(this.filter.toLowerCase()) > -1;
    });
  }
  render() {
    return (h(Fragment, null, this.plugins.map((plugin, i) => this.renderPlugin(plugin, `plugin-${i}`)), this.renderEmpty()));
  }
  renderEmpty() {
    if (this.plugins.length > 0) {
      return undefined;
    }
    return (h("span", { class: "empty" }, i18n.state.plugins.no_matches, ": ", h("strong", null, this.filter)));
  }
  renderPlugin(plugin, key) {
    const { text, icon: iconSrc } = plugin;
    const icon = renderIcon(iconSrc);
    return (h("button", { key: key, onClick: ($event) => this.emitPlugin($event, plugin) }, icon === undefined && (h("div", Object.assign({ class: "icon" }, (icon === undefined && { innerHTML: iconSrc })))), icon, this.renderText(text)));
  }
  renderText(text) {
    var _a, _b, _c, _d, _e;
    const textValue = (_b = (_a = i18n.state.plugins[text]) !== null && _a !== void 0 ? _a : i18n.state.custom[text]) !== null && _b !== void 0 ? _b : text;
    if (this.filter.length > 0) {
      const rgxSplit = new RegExp(this.filter + '(.*)', 'gi');
      const split = textValue.split(rgxSplit);
      const rgxFilter = new RegExp(this.filter, 'gi');
      const filter = textValue.match(rgxFilter);
      return (h(Fragment, null, (_c = split[0]) !== null && _c !== void 0 ? _c : '', h("strong", null, (_d = filter[0]) !== null && _d !== void 0 ? _d : ''), (_e = split[1]) !== null && _e !== void 0 ? _e : ''));
    }
    return textValue;
  }
  static get is() { return "stylo-list"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["list.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["list.css"]
    };
  }
  static get properties() {
    return {
      "display": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "internal",
              "text": undefined
            }],
          "text": ""
        },
        "attribute": "display",
        "reflect": false,
        "defaultValue": "false"
      }
    };
  }
  static get states() {
    return {
      "plugins": {}
    };
  }
  static get events() {
    return [{
        "method": "applyPlugin",
        "name": "applyPlugin",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emit which plugin the user want to apply."
        },
        "complexType": {
          "original": "StyloPlugin",
          "resolved": "StyloPlugin",
          "references": {
            "StyloPlugin": {
              "location": "import",
              "path": "../../../types/plugin"
            }
          }
        }
      }, {
        "method": "cancelPlugins",
        "name": "cancelPlugins",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emit when user actually do not want to apply a plugin."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "focusFirstButton": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "display",
        "methodName": "onDisplay"
      }];
  }
}
//# sourceMappingURL=list.js.map
