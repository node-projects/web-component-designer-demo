import { debounce, isIOS, isMobile, moveCursorToStart } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import { Component, Event, h, Host, Listen, State } from '@stencil/core';
import configStore from '../../../stores/config.store.js';
import containerStore from '../../../stores/container.store.js';
import i18n from '../../../stores/i18n.store.js';
import { createEmptyElement } from '../../../utils/create-element.utils.js';
import { toHTMLElement } from '../../../utils/node.utils.js';
import { findParagraph, focusParagraph, isParagraphEmpty, isParagraphNotEditable } from '../../../utils/paragraph.utils.js';
import { getSelection } from '../../../utils/selection.utils.js';
import { IconAdd } from '../../icons/add.js';
export class Add {
  constructor() {
    this.debouncePlaceholder = debounce(() => this.addPlaceholder(), 350);
    this.onFocusout = () => {
      // Only if not mobile because the event bubble and is triggered often
      if (!isIOS()) {
        return;
      }
      this.top = undefined;
    };
    this.initParagraph = (target) => {
      if (!target) {
        this.hide();
        return;
      }
      const paragraph = findParagraph({
        element: target,
        container: containerStore.state.ref
      });
      this.paragraph = toHTMLElement(paragraph);
      if (!this.paragraph) {
        this.hide();
        return;
      }
      this.top = this.paragraph.offsetTop;
      this.editPlaceholder();
    };
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.addEventListener('focusout', this.onFocusout);
  }
  disconnectedCallback() {
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.removeEventListener('focusout', this.onFocusout);
  }
  /**
   * When "enter" is pressed, create a new paragraph and select it.
   */
  onKeyDown({ code }) {
    if (!['ArrowDown', 'ArrowUp', 'Enter'].includes(code)) {
      this.removePlaceholder();
    }
    if (!['Enter'].includes(code)) {
      return;
    }
  }
  onKeyUp({ code }) {
    var _a;
    if (!['ArrowDown', 'ArrowUp', 'Enter'].includes(code)) {
      if (this.top !== undefined) {
        this.hide();
      }
      return;
    }
    if (['ArrowDown', 'ArrowUp'].includes(code)) {
      this.initParagraph((_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode);
      return;
    }
  }
  /**
   * If user press "/" we want to display the list of plugins.
   */
  onBeforeInput({ data }) {
    if (!['/'].includes(data)) {
      this.hidePlugins.emit();
      return;
    }
    if (!this.paragraph || !this.paragraph.isConnected) {
      return;
    }
    if (!isParagraphEmpty({ paragraph: this.paragraph })) {
      this.hidePlugins.emit();
      return;
    }
    this.focusListPlugins();
  }
  /**
   * Hide or display the component, the "plus" button.
   */
  onClick({ target }) {
    this.initParagraph(target);
  }
  onAddParagraphs({ detail: addedParagraphs }) {
    this.initParagraph(addedParagraphs[0]);
  }
  hide() {
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.top = undefined;
  }
  editPlaceholder() {
    this.removePlaceholder();
    this.debouncePlaceholder();
  }
  addPlaceholder() {
    var _a;
    if (!isParagraphEmpty({ paragraph: this.paragraph })) {
      return;
    }
    if (isParagraphNotEditable({ paragraph: this.paragraph })) {
      return;
    }
    if (!configStore.state.placeholders.includes((_a = this.paragraph) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase())) {
      return;
    }
    const cssBefore = window.getComputedStyle(this.paragraph, ':before');
    const cssAfter = window.getComputedStyle(this.paragraph, ':after');
    const emptyPseudoElement = ['""', 'none'];
    if (!emptyPseudoElement.includes(cssBefore.getPropertyValue('content')) ||
      !emptyPseudoElement.includes(cssAfter.getPropertyValue('content'))) {
      // An external source use :before or :after to style this paragraph, we don't want to add noise in the ui
      return;
    }
    this.paragraph.setAttribute('placeholder', i18n.state.add.placeholder);
  }
  removePlaceholder() {
    var _a;
    const placeholders = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.querySelectorAll('[placeholder]');
    placeholders === null || placeholders === void 0 ? void 0 : placeholders.forEach((element) => element.removeAttribute('placeholder'));
  }
  selectPlugins($event) {
    if (!this.paragraph || !containerStore.state.ref) {
      return;
    }
    $event.stopPropagation();
    if (isParagraphEmpty({ paragraph: this.paragraph }) &&
      !isParagraphNotEditable({ paragraph: this.paragraph })) {
      this.focusListPlugins();
      return;
    }
    focusParagraph({ paragraph: this.paragraph });
    const onRender = (mutations, observer) => {
      observer.disconnect();
      const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
      const div = addedNodes.find((node) => node.nodeName.toLowerCase() === 'div');
      moveCursorToStart(div);
      this.listPlugins.emit(div);
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    this.paragraph.after(div);
    this.hide();
  }
  focusListPlugins() {
    focusParagraph({ paragraph: this.paragraph });
    this.listPlugins.emit(this.paragraph);
  }
  render() {
    const style = this.top === undefined ? { display: 'none' } : { '--actions-top': `${this.top}px` };
    return (h(Host, { style: style },
      h("button", { type: "button", "aria-label": i18n.state.add.add_element, onClick: ($event) => this.selectPlugins($event), onKeyDown: ($event) => $event.stopPropagation(), onMouseDown: ($event) => $event.stopPropagation(), onTouchStart: ($event) => $event.stopPropagation() },
        h(IconAdd, null))));
  }
  static get is() { return "stylo-add"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["add.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["add.css"]
  }; }
  static get states() { return {
    "top": {}
  }; }
  static get events() { return [{
      "method": "listPlugins",
      "name": "listPlugins",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "An event emitted when user click on the shadowed button.\n- If selected paragraph is empty, emitted straight away\n- If not empty, first a new paragraph is created and then event is emitted\nEvent is catched in `<style-plugins/>` and used to trigger the display of list of plugins."
      },
      "complexType": {
        "original": "HTMLElement | undefined",
        "resolved": "HTMLElement",
        "references": {
          "HTMLElement": {
            "location": "global"
          }
        }
      }
    }, {
      "method": "hidePlugins",
      "name": "hidePlugins",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "If user types anything else than a \"/\" in an empty paragraph, hide the plugins."
      },
      "complexType": {
        "original": "void",
        "resolved": "void",
        "references": {}
      }
    }]; }
  static get listeners() { return [{
      "name": "keydown",
      "method": "onKeyDown",
      "target": "document",
      "capture": false,
      "passive": true
    }, {
      "name": "keyup",
      "method": "onKeyUp",
      "target": "document",
      "capture": false,
      "passive": true
    }, {
      "name": "beforeinput",
      "method": "onBeforeInput",
      "target": "document",
      "capture": false,
      "passive": true
    }, {
      "name": "click",
      "method": "onClick",
      "target": "document",
      "capture": false,
      "passive": true
    }, {
      "name": "addParagraphs",
      "method": "onAddParagraphs",
      "target": "document",
      "capture": false,
      "passive": true
    }]; }
}
