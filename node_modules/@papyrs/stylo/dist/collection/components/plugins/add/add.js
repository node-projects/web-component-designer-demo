import { debounce, isIOS, moveCursorToStart } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import { h, Host } from '@stencil/core';
import configStore from '../../../stores/config.store.js';
import containerStore from '../../../stores/container.store.js';
import i18n from '../../../stores/i18n.store.js';
import { createEmptyElement } from '../../../utils/create-element.utils.js';
import { isKeyboardEnter } from '../../../utils/keyboard.utils.js';
import { isMobile } from '../../../utils/mobile.utils.js';
import { toHTMLElement } from '../../../utils/node.utils.js';
import { findParagraph, focusParagraph, isParagraphEmpty, isParagraphNotEditable } from '../../../utils/paragraph.utils.js';
import { getSelection } from '../../../utils/selection.utils.js';
import { IconAdd } from '../../icons/add.js';
export class Add {
  constructor() {
    this.debouncePlaceholder = debounce(() => this.addPlaceholder(), 350);
    /**
     * When "enter" is pressed, create a new paragraph and select it.
     */
    this.onKeyDown = ($event) => {
      const { code } = $event;
      if (!['ArrowDown', 'ArrowUp'].includes(code) && !isKeyboardEnter($event)) {
        this.removePlaceholder();
      }
      if (['Backspace', 'Delete'].includes(code)) {
        this.displayOnMutations();
      }
    };
    this.onFocusout = () => {
      // Only if not mobile because the event bubble and is triggered often
      if (!isIOS()) {
        return;
      }
      this.top = undefined;
    };
    this.initParagraph = ({ target, onlyIfEmptyParagraph }) => {
      if (!target) {
        this.hide();
        return;
      }
      const paragraph = findParagraph({
        element: target,
        container: containerStore.state.ref
      });
      this.paragraph = toHTMLElement(paragraph);
      if (!this.paragraph) {
        this.hide();
        return;
      }
      if (onlyIfEmptyParagraph && !isParagraphEmpty({ paragraph: this.paragraph })) {
        this.hide();
        return;
      }
      this.top = this.paragraph.offsetTop;
      this.editPlaceholder();
      this.selectParagraph.emit(this.paragraph);
    };
    this.top = undefined;
  }
  componentDidLoad() {
    window === null || window === void 0 ? void 0 : window.addEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.addEventListener('focusout', this.onFocusout);
    this.destroyListener = containerStore.onChange('ref', () => {
      this.removeContainerListener();
      this.addContainerListener();
    });
    this.addContainerListener();
  }
  disconnectedCallback() {
    var _a;
    window === null || window === void 0 ? void 0 : window.removeEventListener('resize', () => this.hide());
    document === null || document === void 0 ? void 0 : document.removeEventListener('focusout', this.onFocusout);
    this.removeContainerListener();
    (_a = this.destroyListener) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  addContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.addEventListener('keydown', this.onKeyDown, { passive: true });
  }
  removeContainerListener() {
    var _a;
    (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', this.onKeyDown);
  }
  onKeyUp($event) {
    const { code } = $event;
    if (!['ArrowDown', 'ArrowUp', 'Backspace', 'Delete'].includes(code) &&
      !isKeyboardEnter($event)) {
      if (this.top !== undefined) {
        this.hide();
      }
      return;
    }
    if (['ArrowDown', 'ArrowUp'].includes(code)) {
      this.display({ onlyIfEmptyParagraph: false });
      return;
    }
  }
  /**
   * If user press "/" we want to display the list of plugins.
   */
  onBeforeInput({ data }) {
    if (!['/'].includes(data)) {
      this.hidePlugins.emit();
      return;
    }
    if (!this.paragraph || !this.paragraph.isConnected) {
      return;
    }
    if (!isParagraphEmpty({ paragraph: this.paragraph })) {
      this.hidePlugins.emit();
      return;
    }
    this.focusListPlugins();
  }
  /**
   * Hide or display the component, the "plus" button.
   */
  onClick({ target }) {
    var _a;
    // We use the target only if not the container - it can happen for example if the margin is clicked, in such case we want to use the selection
    this.display({
      onlyIfEmptyParagraph: false,
      target: ((_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.isEqualNode(target)) ? undefined : target
    });
  }
  onAddParagraphs({ detail: addedParagraphs }) {
    this.initParagraph({ target: addedParagraphs[0], onlyIfEmptyParagraph: false });
  }
  hide() {
    this.selectParagraph.emit(undefined);
    // On Android, keyboard display resize screen
    if (isMobile()) {
      return;
    }
    this.top = undefined;
  }
  display({ onlyIfEmptyParagraph, target }) {
    var _a;
    this.initParagraph({
      target: target !== null && target !== void 0 ? target : (_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode,
      onlyIfEmptyParagraph
    });
  }
  displayOnMutations() {
    const onRender = (_mutations, observer) => {
      observer.disconnect();
      this.display({ onlyIfEmptyParagraph: true });
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, {
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  editPlaceholder() {
    this.removePlaceholder();
    this.debouncePlaceholder();
  }
  addPlaceholder() {
    var _a;
    if (!isParagraphEmpty({ paragraph: this.paragraph })) {
      return;
    }
    if (isParagraphNotEditable({ paragraph: this.paragraph })) {
      return;
    }
    if (!configStore.state.placeholders.includes((_a = this.paragraph) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase())) {
      return;
    }
    const cssBefore = window.getComputedStyle(this.paragraph, ':before');
    const cssAfter = window.getComputedStyle(this.paragraph, ':after');
    const emptyPseudoElement = ['""', 'none'];
    if (!emptyPseudoElement.includes(cssBefore.getPropertyValue('content')) ||
      !emptyPseudoElement.includes(cssAfter.getPropertyValue('content'))) {
      // An external source use :before or :after to style this paragraph, we don't want to add noise in the ui
      return;
    }
    this.paragraph.setAttribute('placeholder', i18n.state.add.placeholder);
  }
  removePlaceholder() {
    var _a;
    const placeholders = (_a = containerStore.state.ref) === null || _a === void 0 ? void 0 : _a.querySelectorAll('[placeholder]');
    placeholders === null || placeholders === void 0 ? void 0 : placeholders.forEach((element) => element.removeAttribute('placeholder'));
  }
  selectPlugins($event) {
    if (!this.paragraph || !containerStore.state.ref) {
      return;
    }
    $event.stopPropagation();
    if (isParagraphEmpty({ paragraph: this.paragraph }) &&
      !isParagraphNotEditable({ paragraph: this.paragraph })) {
      this.focusListPlugins();
      return;
    }
    focusParagraph({ paragraph: this.paragraph });
    const onRender = (mutations, observer) => {
      observer.disconnect();
      const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
      const div = addedNodes.find((node) => node.nodeName.toLowerCase() === 'div');
      moveCursorToStart(div);
      this.listPlugins.emit(div);
    };
    const docObserver = new MutationObserver(onRender);
    docObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    this.paragraph.after(div);
    this.hide();
  }
  focusListPlugins() {
    focusParagraph({ paragraph: this.paragraph });
    this.listPlugins.emit(this.paragraph);
  }
  render() {
    const style = this.top === undefined ? { display: 'none' } : { '--actions-top': `${this.top}px` };
    return (h(Host, { style: style }, h("button", { type: "button", "aria-label": i18n.state.add.add_element, onClick: ($event) => this.selectPlugins($event), onKeyDown: ($event) => $event.stopPropagation(), onMouseDown: ($event) => $event.stopPropagation(), onTouchStart: ($event) => $event.stopPropagation() }, h(IconAdd, null))));
  }
  static get is() { return "stylo-add"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["add.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["add.css"]
    };
  }
  static get states() {
    return {
      "top": {}
    };
  }
  static get events() {
    return [{
        "method": "selectParagraph",
        "name": "selectParagraph",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emits the paragraph that is selected either with mouse, touch or keyboard actions"
        },
        "complexType": {
          "original": "HTMLElement | undefined",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        }
      }, {
        "method": "listPlugins",
        "name": "listPlugins",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "An event emitted when user click on the shadowed button.\n- If selected paragraph is empty, emitted straight away\n- If not empty, first a new paragraph is created and then event is emitted\nEvent is catched in `<style-plugins/>` and used to trigger the display of list of plugins."
        },
        "complexType": {
          "original": "HTMLElement | undefined",
          "resolved": "HTMLElement",
          "references": {
            "HTMLElement": {
              "location": "global"
            }
          }
        }
      }, {
        "method": "hidePlugins",
        "name": "hidePlugins",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "If user types anything else than a \"/\" in an empty paragraph, hide the plugins."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
  static get listeners() {
    return [{
        "name": "keyup",
        "method": "onKeyUp",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "beforeinput",
        "method": "onBeforeInput",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "click",
        "method": "onClick",
        "target": "document",
        "capture": false,
        "passive": true
      }, {
        "name": "addParagraphs",
        "method": "onAddParagraphs",
        "target": "document",
        "capture": false,
        "passive": true
      }];
  }
}
