export const isTextNode = (element) => {
  return (element === null || element === void 0 ? void 0 : element.nodeType) === Node.TEXT_NODE || (element === null || element === void 0 ? void 0 : element.nodeType) === Node.COMMENT_NODE;
};
export const toHTMLElement = (element) => {
  return isTextNode(element) ? element.parentElement : element;
};
export const elementIndex = (element) => {
  var _a;
  return Array.from(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || []).indexOf(element);
};
export const nodeIndex = (node) => {
  var _a;
  return Array.from(((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes) || []).indexOf(node);
};
export const nodeDepths = ({ target, paragraph }) => {
  const depths = [nodeIndex(target)];
  if (!paragraph) {
    return depths;
  }
  let parentElement = target.parentElement;
  while (parentElement && !parentElement.isSameNode(paragraph)) {
    depths.push(nodeIndex(parentElement));
    parentElement = parentElement.parentElement;
  }
  return depths.reverse();
};
export const findNodeAtDepths = ({ parent, indexDepths }) => {
  const childNode = ((parent === null || parent === void 0 ? void 0 : parent.childNodes) ? Array.from(parent === null || parent === void 0 ? void 0 : parent.childNodes) : [])[indexDepths[0]];
  if (!childNode) {
    return undefined;
  }
  const [, ...rest] = indexDepths;
  if ((rest === null || rest === void 0 ? void 0 : rest.length) <= 0) {
    return childNode;
  }
  return findNodeAtDepths({ parent: childNode, indexDepths: rest });
};
