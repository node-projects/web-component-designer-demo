import { caretPosition, isFirefox, isIOS, isSafari, moveCursorToEnd } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import containerStore from '../stores/container.store.js';
import undoRedoStore from '../stores/undo-redo.store.js';
import { isTextNode, toHTMLElement } from './node.utils.js';
import { getSelection } from './selection.utils.js';
export const beforeInputTransformer = [
  {
    match: ({ lastKey, key }) => {
      if (isIOS()) {
        return ['‘', '’'].includes(lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) && key.key === ' ';
      }
      if (isSafari()) {
        return (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === null && key.key === '`';
      }
      return (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '`' && key.key === '`';
    },
    transform: () => {
      return document.createElement('mark');
    },
    active: ({ nodeName }) => nodeName.toLowerCase() === 'mark',
    trim: () => (isSafari() && !isIOS() ? 0 : '`'.length),
    postTransform: () => replaceBacktick()
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '*' && key.key === '*',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontWeight = 'bold';
      return span;
    },
    active: (parent) => {
      const { fontWeight } = window.getComputedStyle(parent);
      return parseInt(fontWeight) > 400 || fontWeight === 'bold';
    },
    trim: () => '*'.length
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === ' ' && key.key === '_',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontStyle = 'italic';
      return span;
    },
    active: (parent) => {
      const { fontStyle } = window.getComputedStyle(parent);
      return fontStyle === 'italic';
    },
    trim: () => ''.length
  }
];
export const transformInput = async ({ $event, transformInput }) => {
  const selection = getSelection(containerStore.state.ref);
  if (!selection) {
    return;
  }
  const { focusNode: target } = selection;
  if (!target) {
    return;
  }
  $event.preventDefault();
  // Disable undo-redo observer as we are about to play with the DOM
  undoRedoStore.state.observe = false;
  const parent = toHTMLElement(target);
  // Check if we can transform or end tag
  if (!canTransform({ target, parent, transformInput })) {
    return;
  }
  // We eiter remove the last character, a *, or split the text around the selection and *
  await updateText({ target, parent, transformInput });
  // We had fun, we can observe again the undo redo store to stack the next bold element we are about to create
  undoRedoStore.state.observe = true;
  await createNode({ target, parent, transformInput });
};
const replaceBacktick = () => {
  if (isSafari()) {
    return Promise.resolve();
  }
  if (isFirefox()) {
    return replaceBacktickFirefox();
  }
  return replaceBacktickChrome();
};
/**
 * Firefox renders the new mark and let the backtick in the previous text element
 */
const replaceBacktickFirefox = async () => {
  var _a;
  const markElement = (_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.anchorNode;
  const previousSibling = markElement === null || markElement === void 0 ? void 0 : markElement.previousSibling;
  if (!previousSibling) {
    return;
  }
  const text = isTextNode(previousSibling) ? previousSibling : previousSibling.firstChild;
  if (text.nodeValue.charAt(text.nodeValue.length - 1) !== '`') {
    return;
  }
  undoRedoStore.state.observe = false;
  await removeLastChar({ target: text });
  undoRedoStore.state.observe = true;
};
/**
 * Chrome renders the backtick in the new mark therefore we have to delete it the new element
 */
const replaceBacktickChrome = () => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async (mutation) => {
      changeObserver.disconnect();
      const target = mutation[0].target;
      undoRedoStore.state.observe = false;
      await replaceChar({ target, searchValue: '`', replaceValue: '' });
      undoRedoStore.state.observe = true;
      moveCursorToEnd(target);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  });
};
const replaceChar = ({ target, searchValue, replaceValue }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.replace(searchValue, replaceValue);
  });
};
const removeLastChar = ({ target }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(0, target.nodeValue.length - 1);
  });
};
const createNode = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      moveCursorToEnd((_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const { active, transform } = transformInput;
    if (active(parent)) {
      // We are in a bold node, therefore we want to exit it
      const newText = document.createTextNode('\u200B');
      parent.after(newText);
    }
    else {
      // We create the new node
      const newNode = transform();
      newNode.innerHTML = '\u200B';
      if (target.nextSibling) {
        parent.insertBefore(newNode, target.nextSibling);
      }
      else {
        parent.appendChild(newNode);
      }
    }
  });
};
const canTransform = ({ target, parent, transformInput }) => {
  const index = caretPosition({ target });
  // We are typing at the end of the node text, we can transform it
  if (target.nodeValue.length === index) {
    return true;
  }
  // We are typing in the middle of a text node, we can transform it or end it only if not yet transformed
  const { active } = transformInput;
  return !active(parent);
};
const updateText = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const index = caretPosition({ target });
    // Exact same length, so we remove the last characters
    if (target.nodeValue.length === index) {
      const changeObserver = new MutationObserver(() => {
        changeObserver.disconnect();
        resolve();
      });
      changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
      target.nodeValue = target.nodeValue.substring(0, target.nodeValue.length - transformInput.trim());
      return;
    }
    // The end results will be text followed by a span bold and then the remaining text
    const newText = await splitText({ target, index, transformInput });
    const changeObserver = new MutationObserver(() => {
      changeObserver.disconnect();
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    if (target.nextSibling) {
      parent.insertBefore(newText, target.nextSibling);
    }
    else {
      parent.appendChild(newText);
    }
  });
};
const splitText = ({ target, index, transformInput }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async () => {
      changeObserver.disconnect();
      const node = await removeChar({ target: newText, index: 1 });
      resolve(node);
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const newText = target.splitText(index - transformInput.trim());
  });
};
const removeChar = ({ target, index }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(index);
  });
};
