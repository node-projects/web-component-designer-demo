import { caretPosition, isFirefox, isIOS, isSafari, moveCursorToEnd } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import containerStore from '../stores/container.store.js';
import undoRedoStore from '../stores/undo-redo.store.js';
import { toHTMLElement } from './node.utils.js';
import { getSelection } from './selection.utils.js';
export const beforeInputTransformer = [
  {
    match: ({ key, lastKey, lastBeforeInput }) => {
      if (isIOS()) {
        return ['‘', '’', '´'].includes(lastBeforeInput === null || lastBeforeInput === void 0 ? void 0 : lastBeforeInput.key) && key.key === ' ';
      }
      return key.key === '`' && [' ', 'Dead'].includes(lastKey === null || lastKey === void 0 ? void 0 : lastKey.key);
    },
    transform: () => {
      return document.createElement('mark');
    },
    active: ({ nodeName }) => nodeName.toLowerCase() === 'mark',
    shouldTrim: ({ nodeValue }) => nodeValue.charAt(nodeValue.length - 1) === '`',
    trim: () => '`'.length,
    postTransform: () => replaceBacktick()
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '*' && key.key === '*',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontWeight = 'bold';
      return span;
    },
    active: (parent) => {
      const { fontWeight } = window.getComputedStyle(parent);
      return parseInt(fontWeight) > 400 || fontWeight === 'bold';
    },
    shouldTrim: ({ nodeValue }) => nodeValue.charAt(nodeValue.length - 1) === '*',
    trim: () => '*'.length
  },
  {
    match: ({ lastBeforeInput, key }) => (lastBeforeInput === null || lastBeforeInput === void 0 ? void 0 : lastBeforeInput.key) === ' ' && key.key === '_',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontStyle = 'italic';
      return span;
    },
    active: (parent) => {
      const { fontStyle } = window.getComputedStyle(parent);
      return fontStyle === 'italic';
    },
    shouldTrim: (_target) => false,
    trim: () => ''.length
  }
];
export const transformInput = async ({ $event, transformInput }) => {
  const selection = getSelection(containerStore.state.ref);
  if (!selection) {
    return;
  }
  const { focusNode: target } = selection;
  if (!target) {
    return;
  }
  const parent = toHTMLElement(target);
  // Check if we can transform or end tag
  if (!canTransform({ target, parent, transformInput })) {
    return;
  }
  $event.preventDefault();
  // Disable undo-redo observer as we are about to play with the DOM
  undoRedoStore.state.observe = false;
  // We might remove the last character, a * or ` if present in text
  await updateText({ target, transformInput });
  // We had fun, we can observe again the undo redo store to stack the next bold element we are about to create
  undoRedoStore.state.observe = true;
  await createNode({ target, parent, transformInput });
};
const replaceBacktick = () => {
  if (isSafari()) {
    return Promise.resolve();
  }
  return replaceBacktickText();
};
/**
 * On Swiss French keyboard - i.e. when backtick is entered with "Shift + key":
 *
 * - Chrome renders the backtick in the new mark therefore we have to delete it the new element
 * - Firefox renders the new mark and renders the backtick at the begin of the previous text element
 */
const replaceBacktickText = () => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async (mutations) => {
      changeObserver.disconnect();
      const target = mutations[0].target;
      // On us keyboard, the backtick is already removed
      if (!target.nodeValue.includes('`')) {
        resolve();
        return;
      }
      undoRedoStore.state.observe = false;
      await replaceChar({ target, searchValue: '`', replaceValue: '' });
      undoRedoStore.state.observe = true;
      if (isFirefox()) {
        // Firefox acts a bit weirdly
        const parent = toHTMLElement(target);
        moveCursorToEnd((parent === null || parent === void 0 ? void 0 : parent.nodeName.toLowerCase()) === 'mark' ? parent.nextSibling : target.nextSibling);
        resolve();
        return;
      }
      moveCursorToEnd(target);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  });
};
const replaceChar = ({ target, searchValue, replaceValue }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.replace(searchValue, replaceValue);
  });
};
const createNode = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      moveCursorToEnd((_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const { active, transform } = transformInput;
    if (active(parent)) {
      // We are in a bold node, therefore we want to exit it
      const newText = document.createTextNode('\u200B');
      parent.after(newText);
    }
    else {
      // We create the new node
      const newNode = transform();
      newNode.innerHTML = '\u200B';
      if (target.nextSibling) {
        parent.insertBefore(newNode, target.nextSibling);
      }
      else {
        parent.appendChild(newNode);
      }
    }
  });
};
const canTransform = ({ target, parent, transformInput }) => {
  const index = caretPosition({ target });
  // We are typing at the end of the node text, we can transform it
  if (target.nodeValue.length === index) {
    return true;
  }
  // We are typing in the middle of a text node, we can transform it or end it only if not yet transformed
  const { active } = transformInput;
  return !active(parent);
};
const updateText = ({ target, transformInput: { trim, shouldTrim } }) => {
  return new Promise(async (resolve) => {
    if (!shouldTrim(target)) {
      resolve();
      return;
    }
    const changeObserver = new MutationObserver(() => {
      changeObserver.disconnect();
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.substring(0, target.nodeValue.length - trim());
  });
};
