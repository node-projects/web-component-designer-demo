import { caretPosition, isFirefox, isIOS, isSafari, moveCursorToEnd } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import containerStore from '../stores/container.store.js';
import undoRedoStore from '../stores/undo-redo.store.js';
import { toHTMLElement } from './node.utils.js';
import { getSelection } from './selection.utils.js';
export const beforeInputTransformer = [
  {
    match: ({ key, lastKey, lastBeforeInput }) => {
      if (isIOS()) {
        return ['‘', '’', '´'].includes(lastBeforeInput === null || lastBeforeInput === void 0 ? void 0 : lastBeforeInput.key) && key.key === ' ';
      }
      return key.key === '`' && [' ', 'Dead'].includes(lastKey === null || lastKey === void 0 ? void 0 : lastKey.key);
    },
    transform: () => {
      return document.createElement('mark');
    },
    active: (element) => (element === null || element === void 0 ? void 0 : element.nodeName.toLowerCase()) === 'mark',
    shouldTrimText: ({ nodeValue }) => nodeValue.charAt(nodeValue.length - 1) === '`' || nodeValue.charAt(0) === '`',
    shouldTrimSplit: ({ target, startOffset }) => startOffset !== undefined && target.nodeValue.charAt(startOffset - 1) === '`',
    trim: () => '`'.length,
    postTransform: () => replaceBacktick()
  },
  {
    match: ({ lastKey, key }) => (lastKey === null || lastKey === void 0 ? void 0 : lastKey.key) === '*' && key.key === '*',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontWeight = 'bold';
      return span;
    },
    active: (parent) => {
      if (!parent) {
        return false;
      }
      const { fontWeight } = window.getComputedStyle(parent);
      return parseInt(fontWeight) > 400 || fontWeight === 'bold';
    },
    shouldTrimText: ({ nodeValue }) => nodeValue.charAt(nodeValue.length - 1) === '*' || nodeValue.charAt(0) === '*',
    shouldTrimSplit: ({ target, startOffset }) => startOffset !== undefined && target.nodeValue.charAt(startOffset - 1) === '*',
    trim: () => '*'.length
  },
  {
    match: ({ lastBeforeInput, key }) => (lastBeforeInput === null || lastBeforeInput === void 0 ? void 0 : lastBeforeInput.key) === ' ' && key.key === '_',
    transform: () => {
      const span = document.createElement('span');
      span.style.fontStyle = 'italic';
      return span;
    },
    active: (parent) => {
      if (!parent) {
        return false;
      }
      const { fontStyle } = window.getComputedStyle(parent);
      return fontStyle === 'italic';
    },
    shouldTrimText: (_target) => false,
    shouldTrimSplit: () => false,
    trim: () => ''.length
  }
];
export const transformInput = async ({ $event, transformInput, target, parent }) => {
  // Check if we can transform or end tag
  if (!canTransform({ target, parent, transformInput })) {
    return;
  }
  $event.preventDefault();
  // Disable undo-redo observer as we are about to play with the DOM
  undoRedoStore.state.observe = false;
  // We might remove the character, a * or `, if present
  await updateText({ target, parent, transformInput });
  // We had fun, we can observe again the undo redo store to stack the next bold element we are about to create
  undoRedoStore.state.observe = true;
  await createNode({ target, parent, transformInput });
};
const replaceBacktick = () => {
  if (isSafari()) {
    return Promise.resolve();
  }
  return replaceBacktickText();
};
/**
 * On Swiss French keyboard - i.e. when backtick is entered with "Shift + key":
 *
 * - Chrome renders the backtick in the new mark therefore we have to delete it the new element
 * - Firefox renders the new mark and renders the backtick at the begin of the previous text element
 */
const replaceBacktickText = () => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver(async (mutations) => {
      changeObserver.disconnect();
      const target = mutations[0].target;
      // On us keyboard, the backtick is already removed
      if (!target.nodeValue.includes('`')) {
        resolve();
        return;
      }
      undoRedoStore.state.observe = false;
      await replaceChar({ target, searchValue: '`', replaceValue: '' });
      undoRedoStore.state.observe = true;
      const parent = toHTMLElement(target);
      const mark = (parent === null || parent === void 0 ? void 0 : parent.nodeName.toLowerCase()) === 'mark';
      if (isFirefox()) {
        moveCursorToEnd(mark ? parent.nextSibling : target.nextSibling);
        resolve();
        return;
      }
      moveCursorToEnd(mark ? target : target.nextSibling);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
  });
};
const replaceChar = ({ target, searchValue, replaceValue }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.replace(searchValue, replaceValue);
  });
};
const createNode = ({ target, parent, transformInput }) => {
  return new Promise(async (resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      moveCursorToEnd((_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const { active, transform } = transformInput;
    if (active(parent)) {
      // We are in a bold node, therefore we want to exit it
      return;
    }
    // We create the new node and a node afterwards if last node of the paragraph so user can escape by clicking the arrow right
    const newNode = transform();
    newNode.innerHTML = '\u200B';
    const newText = document.createTextNode('\u200B');
    if (target.nextSibling) {
      parent.insertBefore(newNode, target.nextSibling);
    }
    else {
      parent.append(newNode, newText);
    }
  });
};
const canTransform = ({ target, parent, transformInput }) => {
  const index = caretPosition({ target });
  // We are typing at the end of the node text, we can transform it
  if (target.nodeValue.length === index) {
    return true;
  }
  // We are typing in the middle of a text node, we can transform it or end it only if not yet transformed
  const { active } = transformInput;
  return !active(parent);
};
const updateText = ({ target, transformInput, parent }) => {
  return new Promise(async (resolve) => {
    const index = caretPosition({ target });
    // Exact same length, so we remove the last characters
    if (target.nodeValue.length === index) {
      if (!transformInput.shouldTrimText(target)) {
        resolve();
        return;
      }
      const changeObserver = new MutationObserver(() => {
        changeObserver.disconnect();
        resolve();
      });
      changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
      target.nodeValue = target.nodeValue.substring(0, target.nodeValue.length - transformInput.trim());
      return;
    }
    // The end results will be text followed by a span bold and then the remaining text
    const newText = await splitText({ target, index, transformInput });
    const changeObserver = new MutationObserver((mutations) => {
      var _a;
      changeObserver.disconnect();
      moveCursorToEnd((_a = mutations[1]) === null || _a === void 0 ? void 0 : _a.addedNodes[0]);
      resolve();
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    if (target.nextSibling) {
      parent.insertBefore(newText, target.nextSibling);
    }
    else {
      parent.appendChild(newText);
    }
  });
};
const splitText = ({ target, index, transformInput }) => {
  return new Promise((resolve) => {
    var _a, _b;
    const changeObserver = new MutationObserver(async () => {
      changeObserver.disconnect();
      if (!transformInput.shouldTrimText(newText)) {
        resolve(newText);
        return;
      }
      const node = await removeChar({ target: newText, index: 1 });
      resolve(node);
    });
    changeObserver.observe(containerStore.state.ref, { childList: true, subtree: true });
    const startOffset = (_b = (_a = getSelection(containerStore.state.ref)) === null || _a === void 0 ? void 0 : _a.getRangeAt(0)) === null || _b === void 0 ? void 0 : _b.startOffset;
    const newText = target.splitText(index - (transformInput.shouldTrimSplit({ target, startOffset }) ? transformInput.trim() : 0));
  });
};
const removeChar = ({ target, index }) => {
  return new Promise((resolve) => {
    const changeObserver = new MutationObserver((mutations) => {
      changeObserver.disconnect();
      resolve(mutations[0].target);
    });
    changeObserver.observe(containerStore.state.ref, { characterData: true, subtree: true });
    target.nodeValue = target.nodeValue.slice(index);
  });
};
