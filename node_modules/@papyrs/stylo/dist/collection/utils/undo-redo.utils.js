import { moveCursorToOffset } from '@deckdeckgo/utils';
import containerStore from '../stores/container.store';
import undoRedoStore from '../stores/undo-redo.store';
import { findNodeAtDepths, isTextNode, nodeDepths, toHTMLElement } from './node.utils';
import { redoSelection, toUndoRedoSelection } from './undo-redo-selection.utils';
export const stackUndoInput = ({ container, data }) => {
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  undoRedoStore.state.undo.push({
    changes: data.map((undoRedoInput) => ({
      type: 'input',
      target: container,
      data: undoRedoInput
    }))
  });
  undoRedoStore.state.redo = [];
};
export const stackUndoParagraphs = ({ container, addRemoveParagraphs, updateParagraphs, selection }) => {
  if (addRemoveParagraphs.length <= 0 && updateParagraphs.length <= 0) {
    return;
  }
  if (!undoRedoStore.state.undo) {
    undoRedoStore.state.undo = [];
  }
  const changes = {
    changes: [
      {
        type: 'paragraph',
        target: container,
        data: addRemoveParagraphs.map(({ outerHTML, index, mutation }) => ({
          outerHTML,
          mutation,
          index
        }))
      },
      {
        type: 'update',
        target: container,
        data: updateParagraphs
      }
    ],
    selection
  };
  undoRedoStore.state.undo.push(changes);
  undoRedoStore.state.redo = [];
};
export const nextUndoChanges = () => nextChange(undoRedoStore.state.undo);
export const nextRedoChanges = () => nextChange(undoRedoStore.state.redo);
const nextChange = (changes) => {
  if (!changes) {
    return undefined;
  }
  return changes[changes.length - 1];
};
export const undo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.undo = [
    ...undoRedoStore.state.undo.slice(0, undoRedoStore.state.undo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.redo.push(value),
  undoChanges: nextUndoChanges()
});
export const redo = async () => undoRedo({
  popFrom: () => (undoRedoStore.state.redo = [
    ...undoRedoStore.state.redo.slice(0, undoRedoStore.state.redo.length - 1)
  ]),
  pushTo: (value) => undoRedoStore.state.undo.push(value),
  undoChanges: nextRedoChanges()
});
const undoRedo = async ({ popFrom, pushTo, undoChanges }) => {
  if (!undoChanges) {
    return;
  }
  const currentSelection = toUndoRedoSelection(containerStore.state.ref);
  const { changes, selection } = undoChanges;
  let redoChanges = [];
  for (const undoChange of changes) {
    redoChanges = [await undoRedoChange({ undoChange }), ...redoChanges];
  }
  redoSelection({ container: containerStore.state.ref, selection });
  pushTo({ changes: redoChanges, selection: currentSelection });
  popFrom();
};
const undoRedoChange = async ({ undoChange }) => {
  const { type } = undoChange;
  if (type === 'input') {
    return undoRedoInput({ undoChange });
  }
  if (type === 'paragraph') {
    return undoRedoParagraph({ undoChange });
  }
  return undoRedoUpdate({ undoChange });
};
const undoRedoInput = async ({ undoChange }) => {
  var _a;
  const { data, target } = undoChange;
  const container = toHTMLElement(target);
  const { oldValue, offset: newCaretPosition, index, indexDepths } = data;
  const paragraph = container.children[index];
  let text = findNodeAtDepths({ parent: paragraph, indexDepths });
  if (!text || !isTextNode(text)) {
    // We try to find sibling in case the parent does not yet exist. If we find it, we can replicate such parent for the new text.
    // Useful notably when reverting lists and li.
    const cloneIndexDepths = [...indexDepths];
    cloneIndexDepths.pop();
    let parent = cloneIndexDepths.length <= 0
      ? text
        ? text.parentNode
        : undefined
      : findNodeAtDepths({ parent: paragraph, indexDepths: [...cloneIndexDepths] });
    if (!parent && isTextNode((_a = toHTMLElement(paragraph)) === null || _a === void 0 ? void 0 : _a.lastChild)) {
      text = toHTMLElement(paragraph).lastChild;
    }
    if (!text) {
      if (!parent) {
        parent = await createLast({ paragraph: toHTMLElement(paragraph) || container, container });
      }
      text = await prependText({ parent: toHTMLElement(parent), container });
    }
  }
  const { previousValue } = await updateNodeValue({ text, oldValue, container });
  moveCursorToOffset({
    element: text,
    offset: Math.max(Math.min(oldValue.length > newCaretPosition ? newCaretPosition : oldValue.length, text.nodeValue.length), 0)
  });
  return {
    type: 'input',
    target: container,
    data: {
      index,
      indexDepths: nodeDepths({ target: text !== null && text !== void 0 ? text : target, paragraph }),
      oldValue: previousValue,
      offset: newCaretPosition + (previousValue.length - oldValue.length)
    }
  };
};
const undoRedoParagraph = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const container = toHTMLElement(target);
  const paragraphs = data;
  let to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML, mutation } = paragraph;
    if (mutation === 'add') {
      await removeNode({ container, index });
      to = [
        {
          outerHTML,
          index,
          mutation: 'remove'
        },
        ...to
      ];
    }
    if (mutation === 'remove') {
      await insertNode({ container, index, outerHTML });
      to = [
        {
          outerHTML,
          mutation: 'add',
          index
        },
        ...to
      ];
    }
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
const undoRedoUpdate = async ({ undoChange }) => {
  const { data, target } = undoChange;
  const paragraphs = data;
  const container = toHTMLElement(target);
  const to = [];
  for (const paragraph of paragraphs) {
    const { index, outerHTML } = paragraph;
    const { previousOuterHTML } = await updateNode({
      container,
      index,
      outerHTML
    });
    to.push({ index, outerHTML: previousOuterHTML });
  }
  return Object.assign(Object.assign({}, undoChange), { data: to });
};
/**
 * Because we are using indexes to add or remove back and forth elements, we have to wait for changes to be applied to the DOM before iterating to next element to process.
 * That's why the mutation observer and promises.
 */
const insertNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const previousSiblingIndex = index - 1;
  if (previousSiblingIndex === -1) {
    container.insertAdjacentHTML('afterbegin', outerHTML);
    return;
  }
  container.children[Math.min(previousSiblingIndex, container.children.length - 1)].insertAdjacentHTML('afterend', outerHTML);
});
const removeNode = ({ container, index }) => new Promise((resolve) => {
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve();
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  const element = container.children[Math.min(index, container.children.length - 1)];
  element === null || element === void 0 ? void 0 : element.parentElement.removeChild(element);
});
const updateNode = ({ container, index, outerHTML }) => new Promise((resolve) => {
  const paragraph = container.children[Math.min(index, container.children.length - 1)];
  const previousOuterHTML = paragraph.outerHTML;
  const changeObserver = new MutationObserver((_mutations) => {
    changeObserver.disconnect();
    resolve({ previousOuterHTML });
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  paragraph.outerHTML = outerHTML;
});
const prependText = ({ parent, container }) => new Promise((resolve) => {
  const text = document.createTextNode('');
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(text);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  parent.prepend(text);
});
const updateNodeValue = ({ container, oldValue, text }) => new Promise((resolve) => {
  const previousValue = text.nodeValue;
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve({ previousValue });
  });
  changeObserver.observe(container, { characterData: true, subtree: true });
  text.nodeValue = oldValue;
});
const createLast = ({ container, paragraph }) => new Promise((resolve) => {
  var _a;
  const anchor = ((_a = paragraph.lastElementChild) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) !== 'br'
    ? toHTMLElement(paragraph.lastElementChild)
    : document.createElement('span');
  const parent = toHTMLElement(anchor.cloneNode());
  parent.innerHTML = '';
  const changeObserver = new MutationObserver(() => {
    changeObserver.disconnect();
    resolve(parent);
  });
  changeObserver.observe(container, { childList: true, subtree: true });
  anchor.after(parent);
});
//# sourceMappingURL=undo-redo.utils.js.map
