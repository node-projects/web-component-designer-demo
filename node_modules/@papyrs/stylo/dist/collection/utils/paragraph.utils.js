import { moveCursorToEnd } from '@deckdeckgo/utils';
import { createEmptyElement } from './create-element.utils';
import { isTextNode, nodeIndex, toHTMLElement } from './node.utils';
export const findParagraph = ({ element, container }) => {
  if (!container) {
    return undefined;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return undefined;
  }
  if (!container.parentNode) {
    return undefined;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return undefined;
  }
  if (parentElement.isEqualNode(container)) {
    return element;
  }
  return findParagraph({ element: parentElement, container });
};
/**
 * <article>
 *   <div>
 *     <span>
 *       => isStartNode = true
 *
 * <article>
 *   <div>
 *     Hello <span>
 *             => isStartNode = false
 */
export const isStartNode = ({ element, container }) => {
  if (!container) {
    return false;
  }
  // Just in case
  if (container.nodeName.toUpperCase() === 'HTML' || container.nodeName.toUpperCase() === 'BODY') {
    return false;
  }
  if (isParagraph({ element, container })) {
    return true;
  }
  // If node is the direct first child of it's parent, we can check the parent until we get the container
  if (nodeIndex(element) === 0) {
    return isStartNode({ element: element.parentElement, container });
  }
  return false;
};
export const isParagraph = ({ element, container }) => {
  if (!element) {
    return false;
  }
  const { parentElement } = element;
  if (!parentElement) {
    return false;
  }
  return parentElement === null || parentElement === void 0 ? void 0 : parentElement.isEqualNode(container);
};
export const focusParagraph = ({ paragraph }) => {
  if (!isTextNode(paragraph)) {
    toHTMLElement(paragraph).focus();
  }
  moveCursorToEnd(paragraph);
};
export const transformParagraph = ({ elements, paragraph, container, focus = 'first' }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const addedNodes = mutations.reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
    if (addedNodes.length <= 0) {
      return;
    }
    const { firstChild } = toHTMLElement(addedNodes[focus === 'first' ? 0 : addedNodes.length - 1]);
    moveCursorToEnd(firstChild);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  paragraph.replaceWith(...elements);
};
export const createEmptyParagraph = ({ paragraph, container }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    const div = createEmptyElement({ nodeName: 'div' });
    // Should not happen, fallback
    if (!paragraph) {
      container.append(div);
      return;
    }
    paragraph.after(div);
  });
};
export const addParagraph = ({ paragraph, container, fragment }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(container, { childList: true, subtree: true });
    paragraph.after(fragment);
  });
};
export const addParagraphs = ({ paragraph, container, nodes }) => {
  const addObserver = new MutationObserver((mutations) => {
    addObserver.disconnect();
    const mutation = mutations[mutations.length - 1];
    if (!mutation) {
      return;
    }
    const { addedNodes } = mutation;
    const last = addedNodes[addedNodes.length - 1];
    moveCursorToEnd(last);
  });
  addObserver.observe(container, { childList: true, subtree: true });
  // User has deleted all paragraphs of the container previously
  if (!paragraph) {
    container.append(...nodes);
    return;
  }
  paragraph.after(...nodes);
};
export const createNewEmptyLine = ({ paragraph, range }) => {
  const br = document.createElement('br');
  return insertNodeInRange({ observerRoot: paragraph, range, element: br });
};
export const createNewParagraph = ({ container, range, text }) => {
  const div = document.createElement('div');
  div.innerHTML = text;
  return insertNodeInRange({ observerRoot: container, range, element: div });
};
export const insertNodeInRange = ({ observerRoot, range, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      addObserver.disconnect();
      if (mutations.length === 0) {
        resolve(undefined);
        return;
      }
      const { addedNodes } = mutations[mutations.length - 1];
      if (!addedNodes || addedNodes.length === 0) {
        resolve(undefined);
        return;
      }
      resolve(addedNodes[addedNodes.length - 1]);
    });
    addObserver.observe(observerRoot, { childList: true, subtree: true });
    range.insertNode(element);
  });
};
export const prependEmptyText = ({ paragraph }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    paragraph.prepend(text);
  });
};
export const addEmptyText = ({ paragraph, element }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((mutations) => {
      var _a, _b;
      addObserver.disconnect();
      resolve((_b = (_a = mutations[0]) === null || _a === void 0 ? void 0 : _a.addedNodes) === null || _b === void 0 ? void 0 : _b[0]);
    });
    addObserver.observe(paragraph, { childList: true, subtree: true });
    const text = document.createTextNode('\u200B');
    element.after(text);
  });
};
export const isParagraphEmpty = ({ paragraph }) => { var _a; return ['', '\n', '\u200B'].includes((_a = paragraph === null || paragraph === void 0 ? void 0 : paragraph.textContent) === null || _a === void 0 ? void 0 : _a.trim()); };
export const isParagraphNotEditable = ({ paragraph }) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.getAttribute('contenteditable')) === 'false';
export const isParagraphCode = ({ paragraph }) => {
  // DeckDeckGo web components
  if (paragraph.nodeName.toLowerCase().startsWith('deckgo-')) {
    return true;
  }
  return ['code', 'pre'].includes(paragraph.nodeName.toLowerCase());
};
export const setParagraphAttribute = ({ paragraph, attributeName }) => {
  return new Promise((resolve) => {
    const addObserver = new MutationObserver((_mutations) => {
      addObserver.disconnect();
      resolve();
    });
    addObserver.observe(paragraph, { attributes: true });
    paragraph.setAttribute(attributeName, '');
  });
};
