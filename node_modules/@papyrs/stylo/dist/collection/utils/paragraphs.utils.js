import { isTextNode, toHTMLElement } from './node.utils';
import { findParagraph, isParagraph, isParagraphEmpty } from './paragraph.utils';
import { getRange } from './selection.utils';
export const findAddedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const addedNodes = mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .reduce((acc, { addedNodes }) => [...acc, ...Array.from(addedNodes)], []);
  return filterAddedParagraphs({ nodes: addedNodes, container });
};
export const findAddedNodesParagraphs = ({ mutations, container }) => {
  return mutations
    .filter(({ addedNodes }) => (addedNodes === null || addedNodes === void 0 ? void 0 : addedNodes.length) > 0)
    .filter(({ addedNodes }) => !isParagraph({ element: addedNodes[0], container }))
    .filter(({ addedNodes }) => !isParagraphEmpty({
    paragraph: findParagraph({ element: addedNodes[0], container })
  }));
};
const hasNodeParagraph = ({ removedNodes, paragraphIdentifier }) => Array.from(removedNodes).find((removedNode) => { var _a; return !isTextNode(removedNode) && ((_a = toHTMLElement(removedNode)) === null || _a === void 0 ? void 0 : _a.hasAttribute(paragraphIdentifier)); }) !== undefined;
export const findRemovedNodesParagraphs = ({ mutations, paragraphIdentifier }) => mutations
  .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
  .filter(({ removedNodes }) => !hasNodeParagraph({ removedNodes, paragraphIdentifier }));
export const findRemovedParagraphs = ({ mutations, container, paragraphIdentifier }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  return mutations
    .filter(({ removedNodes }) => (removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.length) > 0)
    .reduce((acc, { removedNodes, previousSibling }) => {
    const paragraphs = filterRemovedParagraphs({
      nodes: Array.from(removedNodes),
      paragraphIdentifier
    });
    return [
      ...acc,
      ...paragraphs.map((paragraph) => ({
        paragraph,
        previousSibling: findPreviousElementSibling({ container, previousSibling })
      }))
    ];
  }, []);
};
/**
 * The mutation observer previous sibling can be a #text node. Because we assume every child of the container are HTML elements, we iterate until we find the closest one.
 */
const findPreviousElementSibling = ({ previousSibling, container }) => {
  if (!previousSibling) {
    return undefined;
  }
  if (container.isEqualNode(previousSibling)) {
    return undefined;
  }
  if (!isTextNode(previousSibling)) {
    return previousSibling;
  }
  return findPreviousElementSibling({ previousSibling: previousSibling.previousSibling, container });
};
export const findUpdatedParagraphs = ({ mutations, container }) => {
  if (!mutations || mutations.length <= 0) {
    return [];
  }
  const nodes = mutations.reduce((acc, { target }) => [...acc, target], []);
  return [
    ...new Set(nodes
      .map((node) => findParagraph({ element: node, container }))
      .filter((paragraph) => paragraph !== undefined &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE &&
      (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE))
  ];
};
const filterAddedParagraphs = ({ nodes, container }) => {
  return nodes
    .filter((node) => isParagraph({ element: node, container }))
    .filter((paragraph) => (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.TEXT_NODE && (paragraph === null || paragraph === void 0 ? void 0 : paragraph.nodeType) !== Node.COMMENT_NODE);
};
const filterRemovedParagraphs = ({ nodes, paragraphIdentifier }) => {
  return nodes
    .filter((paragraph) => !isTextNode(paragraph))
    .map((node) => node)
    .filter((element) => element === null || element === void 0 ? void 0 : element.hasAttribute(paragraphIdentifier));
};
export const findSelectionParagraphs = ({ container, filterEmptySelection }) => {
  const { range, selection } = getRange(container);
  if (!range || (filterEmptySelection && (selection === null || selection === void 0 ? void 0 : selection.toString().length) === 0)) {
    return undefined;
  }
  const start = toHTMLElement(findParagraph({ element: range.startContainer, container }));
  const end = toHTMLElement(findParagraph({ element: range.endContainer, container }));
  if (!end || !start || (start === null || start === void 0 ? void 0 : start.isSameNode(end))) {
    return start ? [start] : [];
  }
  if (start.nextElementSibling.isSameNode(end)) {
    return [start, end];
  }
  const nodes = [];
  let next = start.nextElementSibling;
  while (next !== null && !next.isSameNode(end)) {
    nodes.push(toHTMLElement(next));
    next = next.nextElementSibling;
  }
  return [start, ...nodes, end];
};
export const filterAttributesMutations = ({ mutations, excludeAttributes }) => {
  const attributeMutations = mutations.filter(({ attributeName }) => attributeName !== null);
  // We consider only single change. If the mutations contains one attribute to exclude, we ignore all the mutations
  // If a web component attribute is updated, e.g theme="ubuntu", the component might update the class of the host
  // In such case, the mutation observer will be triggered twice
  const excludeMutations = attributeMutations.find(({ attributeName }) => excludeAttributes.includes(attributeName));
  if (excludeMutations !== undefined) {
    return [];
  }
  return attributeMutations;
};
