import { elementIndex, findNodeAtDepths, nodeDepths, toHTMLElement } from './node.utils';
import { findParagraph } from './paragraph.utils';
import { getRange, getSelection } from './selection.utils';
export const toUndoRedoSelection = (container) => {
  const { range, selection } = getRange();
  if (!range) {
    return undefined;
  }
  const { anchorNode, focusNode } = selection;
  const startParagraph = toHTMLElement(findParagraph({ element: anchorNode, container }));
  const endParagraph = toHTMLElement(findParagraph({ element: focusNode, container }));
  if (!startParagraph || !endParagraph) {
    return;
  }
  return {
    startIndex: elementIndex(startParagraph),
    startIndexDepths: nodeDepths({
      target: anchorNode,
      paragraph: findParagraph({ element: anchorNode, container })
    }),
    startOffset: selection.anchorOffset,
    endIndex: elementIndex(endParagraph),
    endIndexDepths: nodeDepths({
      target: focusNode,
      paragraph: findParagraph({ element: focusNode, container })
    }),
    endOffset: selection.focusOffset,
    reverse: !anchorNode.isEqualNode(range.startContainer)
  };
};
export const redoSelection = ({ selection, container }) => {
  if (!selection) {
    return;
  }
  const { startIndex, startIndexDepths, startOffset, endIndex, endIndexDepths, endOffset, reverse } = selection;
  const startParagraph = container.children[Math.min(startIndex, container.children.length - 1)];
  const endParagraph = container.children[Math.min(endIndex, container.children.length - 1)];
  const startNode = findNodeAtDepths({
    parent: startParagraph,
    indexDepths: startIndexDepths
  });
  const endNode = findNodeAtDepths({
    parent: endParagraph,
    indexDepths: endIndexDepths
  });
  if (!startNode || !endNode) {
    return;
  }
  // Prevent error "DOMException: Failed to execute 'setStart' on 'Range': The offset 7 is larger than the node's length (1)."
  if (startNode.textContent.length < startOffset || endNode.textContent.length < endOffset) {
    return;
  }
  const range = document.createRange();
  if (!reverse) {
    range.setStart(startNode, startOffset);
    range.setEnd(endNode, endOffset);
  }
  else {
    range.setEnd(startNode, startOffset);
    range.setStart(endNode, endOffset);
  }
  const windowSelection = getSelection(container);
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.removeAllRanges();
  windowSelection === null || windowSelection === void 0 ? void 0 : windowSelection.addRange(range);
  range.detach();
};
