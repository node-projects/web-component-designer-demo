import { getAnchorElement } from '/web-component-designer-demo/node_modules/@deckdeckgo/utils/lib/esm/index.js';
import { isParagraph } from './paragraph.utils.js';
import { findStyleNode } from './toolbar.utils.js';
export function execCommandStyle(selection, action, container) {
  const anchor = getAnchorElement(selection);
  if (!anchor) {
    return;
  }
  const sameSelection = anchor && anchor.innerText === selection.toString();
  if (sameSelection &&
    !isParagraph({ element: anchor, container }) &&
    anchor.style[action.style] !== undefined) {
    updateSelection(anchor, action, container);
    return;
  }
  replaceSelection(anchor, action, selection, container);
}
function updateSelection(anchor, action, container) {
  anchor.style[action.style] = getStyleValue(container, action, container);
  cleanChildren(action, anchor);
}
function replaceSelection(anchor, action, selection, container) {
  const range = selection.getRangeAt(0);
  // User selected a all list?
  if (range.commonAncestorContainer &&
    ['ol', 'ul', 'dl'].some((listType) => listType === range.commonAncestorContainer.nodeName.toLowerCase())) {
    updateSelection(range.commonAncestorContainer, action, container);
    return;
  }
  const fragment = range.extractContents();
  const span = createSpan(anchor, action, container);
  span.appendChild(fragment);
  cleanChildren(action, span);
  flattenChildren(action, span);
  range.insertNode(span);
  selection.selectAllChildren(span);
}
function cleanChildren(action, span) {
  if (!span.hasChildNodes()) {
    return;
  }
  // Clean direct (> *) children with same style
  const children = Array.from(span.children).filter((element) => {
    return element.style[action.style] !== undefined && element.style[action.style] !== '';
  });
  if (children && children.length > 0) {
    children.forEach((element) => {
      element.style[action.style] = '';
      if (element.getAttribute('style') === '' || element.style === null) {
        element.removeAttribute('style');
      }
    });
  }
  // Direct children (> *) may have children (*) which need to be cleaned too
  Array.from(span.children).forEach((element) => cleanChildren(action, element));
}
function createSpan(anchor, action, container) {
  const span = document.createElement('span');
  span.style[action.style] = getStyleValue(anchor, action, container);
  return span;
}
// We assume that if the same style is applied, user want actually to remove it (same behavior as in MS Word)
// Note: initial may have no effect on the background-color
function getStyleValue(anchor, action, container) {
  if (!anchor) {
    return action.value;
  }
  if (action.initial(anchor)) {
    return 'initial';
  }
  const style = findStyleNode(anchor, action.style, container);
  if (action.initial(style)) {
    return 'initial';
  }
  return action.value;
}
// We try to not keep <span/> in the tree if we can use text
function flattenChildren(action, span) {
  if (!span.hasChildNodes()) {
    return;
  }
  // Flatten direct (> *) children with no style
  const children = Array.from(span.children).filter((element) => {
    const style = element.getAttribute('style');
    return !style || style === '';
  });
  if (children && children.length > 0) {
    children.forEach((element) => {
      // Can only be flattened if there is no other style applied to a children, like a color to part of a text with a background
      const styledChildren = element.querySelectorAll('[style]');
      if (!styledChildren || styledChildren.length === 0) {
        const text = document.createTextNode(element.textContent);
        element.parentElement.replaceChild(text, element);
      }
    });
    return;
  }
  // Direct children (> *) may have children (*) which need to be flattened too
  Array.from(span.children).forEach((element) => flattenChildren(action, element));
}
