/*
 * String Iterator v0.0.1
 * Corey Hart @ http://www.codenothing.com
 * MIT License
 */
(function( global, undefined ) {

var Slice = Array.prototype.slice,
	toString = Object.prototype.toString,
	rnewline = /\r\n|\r|\n/;


function StringIterator( string ) {
	var self = this, i = -1, line = [], length, c;

	if ( ! ( self instanceof StringIterator ) ) {
		return new StringIterator( string );
	}
	else if ( ! StringIterator.isString( string ) ) {
		throw new Error( "No string found" );
	}

	// Meta
	self.string = string;
	self.index = -1;
	self.length = -1;
	self.character = 1;
	self.line = 1;
	self.c = "";
	self.next = "";
	self.prev = "";
	self.chars = [];
	self.lines = [ line ];

	// Break down each individual character, and seperate newlines
	for ( length = self.string.length; ++i < length; ) {
		c = self.string[ i ];
		if ( c == "\r" && self.string[ i + 1 ] == "\n" ) {
			c = "\r\n";
			i++;
		}

		self.chars.push( c );
		if ( rnewline.exec( c ) ) {
			self.lines.push( line = [] );
		}
		else {
			line.push( c );
		}
	}

	// Length should represent number of characters
	self.length = self.chars.length;
}

StringIterator.prototype = {

	// Skip to specific index
	goto: function( n ) {
		var self = this, count = 0, i = -1, line;

		if ( ! StringIterator.isNumber( n ) ) {
			throw new Error( "Expecting a number for goto" );
		}
		else if ( n < 0 ) {
			throw new Error( "Number too small for goto" );
		}
		else if ( n >= self.length ) {
			throw new Error( "Number too large for goto" );
		}

		self.index = n;
		self.c = self.chars[ n ];
		self.next = self.chars[ n + 1 ] || "";
		self.prev = self.chars[ n - 1 ] || "";

		while ( ( line = self.lines[ ++i ] ) ) {
			if ( self.index < ( count + line.length ) ) {
				self.line = i + 1;
				self.character = self.index - count + 1;
				break;
			}
			else {
				count += line.length + 1;
			}
		}

		return self;
	},

	// Forward iteration
	each: function( callback ) {
		var self = this, substr = "";

		// Test for function
		if ( ! StringIterator.isFunction( callback ) ) {
			throw new Error( "No function found" );
		}

		// Iterate
		for ( ; ++self.index < self.length; ) {
			self.goto( self.index );
			substr += self.c;

			if ( callback( self.c, self ) === false ) {
				break;
			}
		}

		if ( self.index >= self.length ) {
			self.index = self.length - 1;
		}

		return substr;
	},

	// Find a character while compiling a sub string
	seek: function( match ) {
		var self = this,
			regex = StringIterator.isRegExp( match ) ? match : null,
			endChar = StringIterator.isString( match ) ? match : null;

		// Make sure there is an end matcher
		if ( regex === null && endChar === null ) {
			throw new Error( "No seek found" );
		}

		// Iterate until we find the match
		return self.each(function( c ) {
			if ( self.prev == "\\" ) {
				return;
			}
			else if ( ( endChar && c === endChar ) || ( regex && regex.exec( c ) ) ) {
				return false;
			}
		});
	},

	// Skipping n string iterations
	skip: function( n ) {
		var self = this, count = 0;

		// No number means a single skip
		if ( n === undefined ) {
			n = 1;
		}
		// Make sure a number is passed
		else if ( ! StringIterator.isNumber( n ) ) {
			throw new Error( "Expecting a number for skip" );
		}

		// Iterate until count is matched
		return self.each(function( c ) {
			if ( ++count >= n ) {
				return false;
			}
		});
	},

	// Going back n string iterations
	reverse: function( value ) {
		var self = this,
			isFunction = StringIterator.isFunction( value ),
			substr = "",
			count = 0;

		// Number of iterations
		if ( value === undefined ) {
			value = 1;
		}
		// Make sure a number or function is passed
		else if ( ! isFunction && ! StringIterator.isNumber( value ) ) {
			throw new Error( "Expecting a number or function for reverse" );
		}

		// Reverse iterate until wall is hit
		for ( ; --self.index > 0; ) {
			self.goto( self.index );
			substr = self.c + substr;

			// Check to see if thresholds have been met
			if ( ( isFunction && value( self.c, self ) === false ) || ( ! isFunction && ++count >= value ) ) {
				break;
			}
		}

		return substr;
	},

	// Restarting iteration
	restart: function(){
		var self = this;

		self.index = -1;
		self.character = 1;
		self.line = 1;
		self.c = "";
		self.next = "";
		self.prev = "";

		return self;
	},

};


// Version
StringIterator.version = "0.0.1";


// Type tests
"Boolean Number String Function Array Date RegExp Object".split(' ').forEach(function( method ) {
	if ( method == 'Array' && Array.isArray ) {
		return ( StringIterator.isArray = Array.isArray );
	}

	var match = '[object ' + method + ']';
	StringIterator[ 'is' + method ] = function( object ) {
		return object !== undefined && object !== null && toString.call( object ) == match;
	};
});


// Expose
if ( typeof module == 'object' && typeof module.exports == 'object' ) {
	module.exports = StringIterator;
}
else {
	global.StringIterator = StringIterator;
}

})( this );
/*
 * CSSTree 0.0.3
 * Corey Hart @ http://www.codenothing.com
 * MIT License http://www.codenothing.com/license
 */
(function( global, undefined ) {

var rwhitespace = /(\s|\t|\r\n|\r|\n)/,
	leftTrim = /^(\r\n|\r|\n|\t|\s)*/,
	StringIterator = global.StringIterator;


function CSSTree( css ) {
	var self = this, m;

	// Force instance of CSSTree
	if ( ! ( self instanceof CSSTree ) ) {
		return new CSSTree( css );
	}

	// Internals
	self.iter = new StringIterator( css );
	self.css = css;
	self.branches = [];

	// Begin rendering
	self.render();
}

// Methods
CSSTree.prototype = {

	// Starts process of reading the stylesheet
	render: function(){
		var self = this,
			iter = self.iter;

		iter.each(function( c ) {
			// Comment
			if ( c == '/' && iter.next == '*' ) {
				iter.reverse();
				self.comment();
			}
			// Skip over whitespace, but assume anything else is a selector/atrule
			else if ( ! rwhitespace.exec( c ) ) {
				iter.reverse();
				self.selector();
			}
		});

		// Apply line/character information to all positions
		self._positions( self.branches );
	},

	// Ignore comment blocks
	comment: function( nested ) {
		var self = this,
			iter = self.iter,
			position = new CSSTree.Position( iter.index + 1 ),
			comment = iter.each(function( c, iter ) {
				if ( iter.c == '/' && iter.prev == '*' ) {
					return false;
				}
			});

		self.branches.push(
			new CSSTree.Comment( comment, nested || false, position.markEnd( iter.index ) )
		);
	},

	// Selctor looks for opening rule set or closing semicolon for oneliners
	selector: function(){
		var self = this,
			iter = self.iter,
			position = new CSSTree.Position( iter.index + 1 ),
			selector = '',
			branch;

		iter.each(function( c ) {
			// Comment block
			if ( c == '/' && iter.next == '*' ) {
				iter.reverse();
				position.markChunkEnd( iter.index );
				self.comment();
				position.markChunkStart( iter.index + 1 );
			}
			// Atrule
			else if ( c == ';' ) {
				return false;
			}
			// Media atrule
			else if ( c == '{' && selector.trim()[ 0 ] == '@' ) {
				branch = self.nested( selector, position );
				branch.position = position.markEnd( iter.index );
				self.branches.push( branch );

				selector = null;
				return false;
			}
			// Selector for ruleset
			else if ( c == '{' ) {
				branch = new CSSTree.Selector( selector, self.rules( position ), position );
				position.markEnd( iter.index );
				self.branches.push( branch );

				selector = null;
				return false;
			}
			// Escape string
			else if ( c == "\\" ) {
				iter.skip();
				selector += c + iter.c;
			}
			// Seek
			else if ( c == "'" || c == '"' ) {
				selector += c + iter.seek( c );
			}
			// Seek
			else if ( c == '(' ) {
				selector += c + iter.seek( ')' );
			}
			// Add to selector string
			else {
				selector += c;
			}
		});

		// Single line queries
		if ( selector && selector.trim().length ) {
			self.branches.push(
				new CSSTree.AtRule( selector, position.markEnd( iter.index - 1 ) )
			);
		}
	},

	// Rule Sets
	rules: function( parentPos ) {
		var self = this,
			iter = self.iter,
			rules = [],
			rule, position;

		iter.each(function( c ) {
			// Nested Comment block
			if ( c == '/' && iter.next == '*' ) {
				iter.reverse();
				parentPos.markChunkEnd( iter.index );
				self.comment( true );
				parentPos.markChunkStart( iter.index + 1 );
			}
			// End of rules
			else if ( c == '}' ) {
				return false;
			}
			// New rule
			else if ( ! rwhitespace.exec( c ) ) {
				position = new CSSTree.Position( iter.index, parentPos );
				iter.reverse();

				rule = new CSSTree.Rule(
					self.property( position ).trim(),
					self.value( position ).trim(),
					position
				);

				// Break down the parts of the value, and push it
				position.markEnd( iter.index - ( iter.c == ';' ? 1 : 0 ), false );

				// Only add if there is an actual property
				if ( rule.property.length ) {
					rules.push( rule );
				}
			}
		});

		return rules;
	},

	// Property Names
	property: function( position ) {
		var self = this,
			iter = self.iter,
			property = '';

		iter.each(function( c ) {
			// Nested Comment block
			if ( c == '/' && iter.next == '*' ) {
				iter.reverse();
				position.markChunkEnd( iter.index );
				self.comment( true );
				position.markChunkStart( iter.index + 1 );
			}
			// End of property
			else if ( c == ':' ) {
				return false;
			}
			// Invalid CSS, but still end of property
			else if ( c == ';' || c == '}' ) {
				iter.reverse();
				return false;
			}
			else {
				property += c;
			}
		});

		return property;
	},

	// Values
	value: function( position ) {
		var self = this,
			iter = self.iter,
			value = '';

		iter.each(function( c ) {
			// Nested Comment block
			if ( c == '/' && iter.next == '*' ) {
				iter.reverse();
				position.markChunkEnd( iter.index );
				self.comment( true );
				position.markChunkStart( iter.index + 1 );
			}
			// End of value
			else if ( c == ';' ) {
				return false;
			}
			// Watch for no semi-colon at end of set
			else if ( c == '}' ) {
				iter.reverse();
				return false;
			}
			// Seek strings
			else if ( c == "'" || c == '"' ) {
				value += c + iter.seek( c );
			}
			// Seek groupings
			else if ( c == '(' ) {
				value += c + iter.seek( ')' );
			}
			// Append
			else {
				value += c;
			}
		});

		return value;
	},

	// Nested atrules
	nested: function( atrule, position ) {
		var self = this,
			iter = self.iter,
			startPos = null,
			string = '',
			peek, index, rule, subPosition, character,
			block = atrule.trim()[ 0 ] == '@' ?
				new CSSTree.AtRule( atrule, position ) :
				new CSSTree.Selector( atrule, null, position );

		iter.each(function( c ) {
			// Nested Comment block
			if ( c == '/' && iter.next == '*' ) {
				iter.reverse();
				position.markChunkEnd( iter.index );
				self.comment( true );
				position.markChunkStart( iter.index );
			}
			// End of property:value
			else if ( c == ';' ) {
				subPosition = new CSSTree.Position( startPos );
				subPosition.markEnd( iter.index - ( iter.c == ';' ? 1 : 0 ) );

				// String trimming & positioning
				string = string.trim();
				index = string.indexOf( ':' );

				// Build up rule property
				rule = new CSSTree.Rule(
					string.substr( 0, index ).trim(),
					string.substr( index + 1 ).trim(),
					subPosition
				);

				// Atrules don't startoff with rules
				if ( ! block.rules ) {
					block.rules = [];
				}

				// Parse out parts and add to branches rules
				block.rules.push( rule );
				startPos = null;
				string = '';
			}
			// Nested Block
			else if ( c == '{' ) {
				if ( ! block.branches ) {
					block.branches = [];
				}

				// Nested branches should start tracking at the first character, not whitespace
				string = string.replace( leftTrim, '' );

				// Travel down the tree
				subPosition = new CSSTree.Position( startPos, position );
				block.branches.push( self.nested( string, subPosition ) );
				startPos = null;
				string = '';
			}
			// Seek
			else if ( c == "'" || c == '"' ) {
				string += c + iter.seek( c );
			}
			// Seek
			else if ( c == '(' ) {
				string += c + iter.seek( ')' );
			}
			// End of block
			else if ( c == '}' ) {
				subPosition = new CSSTree.Position( startPos );

				// Assume any string left is a property:value definition
				if ( ( string = string.trim() ).length ) {
					index = string.indexOf( ':' );
					rule = new CSSTree.Rule(
						string.substr( 0, index ).trim(),
						string.substr( index + 1 ).trim(),
						subPosition.markEnd( iter.index - 1 )
					);

					// Atrules don't startoff with rules
					if ( ! block.rules ) {
						block.rules = [];
					}

					// Parse out value parts and add to rules
					block.rules.push( rule );
				}

				block.position.markEnd( iter.index, false );
				return false;
			}
			// Append
			else {
				if ( startPos === null && ! rwhitespace.exec( c ) ) {
					startPos = iter.index;
				}

				string += c;
			}
		});

		return block;
	},

	// Crawl the tree to finish position markup
	_positions: function( branches ) {
		var self = this;

		// Cycle through each branch for markings
		branches.forEach(function( branch ) {
			self._markPosition( branch.position );

			// Markup each rule positions
			if ( branch.rules ) {
				branch.rules.forEach(function( rule ) {
					if ( rule.position ) {
						self._markPosition( rule.position );
					}
				});
			}

			// Crawl nested branches
			if ( branch.branches ) {
				self._positions( branch.branches );
			}
		});
	},

	// Marks up position
	_markPosition: function( position ) {
		var self = this;

		// Mark branch positions
		position.start = self._charPosition( position.range.start );
		position.end = self._charPosition( position.range.end );
	},

	// Marks the line & character for the character position passed
	_charPosition: function( pos ) {
		var self = this,
			iter = self.iter.goto( pos );

		return {
			line: iter.line,
			character: iter.character
		};
	}

};

// Keep Reference
CSSTree.StringIterator = StringIterator;

// Expose to NodeJS/Window
if ( typeof module == 'object' && typeof module.exports == 'object' ) {
	module.exports = CSSTree;
}
else {
	global.CSSTree = CSSTree;
}


})( this );

(function( global, undefined ) {

function Position( start, _parent ) {
	var self = this;

	if ( ! ( self instanceof Position ) ) {
		return new Position( start, _parent );
	}

	if ( _parent && _parent instanceof Position ) {
		self._parent = _parent;
	}

	if ( start === undefined ) {
		start = 0;
	}

	self.range = { start: start, end: start, length: 0 };
	self.start = { line: 0, character: 0 };
	self.end = { line: 0, character: 0 };
	self.chunks = [];
	self.markChunkStart( start, false );
}

Position.prototype = {

	markChunkStart: function( pos, propagate ) {
		var self = this;

		self._chunk = { start: pos, end: pos, length: 0 };
		self.chunks.push( self._chunk );

		if ( self._parent && propagate !== false ) {
			self._parent.markChunkStart( pos, propagate );
		}
	},

	markChunkEnd: function( pos, propagate ) {
		var self = this;

		if ( self._chunk ) {
			self._chunk.end = pos;
			self._chunk.length = pos - self._chunk.start + 1;
			delete self._chunk;
		}

		if ( self._parent && propagate !== false ) {
			self._parent.markChunkEnd( pos, propagate );
		}

		return self;
	},

	markEnd: function( pos, propagate ) {
		var self = this;

		self.markChunkEnd( pos, propagate );
		self.range.end = pos;
		self.range.length = pos - self.range.start + 1;

		if ( self._parent ) {
			delete self._parent;
		}

		return self;
	}

};

global.CSSTree.Position = Position;


})( this );

(function( global, undefined ) {

function Comment( comment, nested, position ) {
	var self = this;

	if ( ! ( self instanceof Comment ) ) {
		return new Comment( comment, nested, position );
	}

	self.comment = ( comment || '' ).trim();
	self.nested = !!nested;
	self.position = position;
}

global.CSSTree.Comment = Comment;


})( this );

(function( global, undefined ) {

var ratruleseek = /"|'|\(/,
	ratrulepart = /[\, ]/;


function AtRule( atrule, position ) {
	var self = this;

	if ( ! ( self instanceof AtRule ) ) {
		return new AtRule( atrule, position );
	}

	self.atrule = ( atrule || '' ).trim();
	self.position = position;
	self.parts = [];
	self.breakdown();
}

AtRule.prototype = {
	
	breakdown: function(){
		var self = this, atrule = self.atrule,
			parts = [], part = '',
			i = -1, l = atrule.length, c = '',
			seek;

		for ( ; ++i < l; ) {
			c = atrule[ i ];

			// Part separator
			if ( ratrulepart.exec( c ) ) {
				part = part.trim();

				if ( part.length ) {
					parts.push( part );
				}

				if ( c != ' ' ) {
					parts.push( c );
				}

				part = '';
			}
			// Read all characters in a seek sequence ((...), "...", '...', etc)
			else if ( ratruleseek.exec( c ) ) {
				part += c;
				seek = c == '(' ? ')' : c;

				// Find end char
				for ( ; ++i < l; ) {
					c = atrule[ i ];
					part += c;

					// End char found, break off and attach part
					if ( c == seek ) {
						break;
					}
					// Skip over escaped values
					else if ( c == "\\" && atrule[ i + 1 ] ) {
						part += atrule[ ++i ];
					}
				}
			}
			// Add to the current part
			else {
				part += c;
			}
		}

		// Catch the last part and add it
		if ( ( part = part.trim() ).length ) {
			parts.push( part );
		}

		self.parts = parts;
	}

};

global.CSSTree.AtRule = AtRule;


})( this );

(function( global, undefined ) {

var rwhitespace = /(\s|\t|\r\n|\r|\n)/,
	rvalueseparator = /\/|,/,
	rvalueseek = /"|'|\(/;


function Rule( property, value, position ) {
	var self = this;

	if ( ! ( self instanceof Rule ) ) {
		return new Rule( property, value, position );
	}

	self.property = ( property || '' ).trim();
	self.value = ( value || '' ).trim();
	self.position = position;
	self.parts = [];
	self.breakdown();
}

Rule.prototype = {

	breakdown: function(){
		var self = this, value = self.value,
			parts = [], i = -1, l = value.length, part = '', c, seek;

		for ( ; ++i < l; ) {
			c = value[ i ];

			// Whitespace is a value separator
			if ( rwhitespace.exec( c ) ) {
				if ( ( part = part.trim() ).length ) {
					parts.push( part );
				}

				part = '';
			}
			// Value separator
			else if ( rvalueseparator.exec( c ) ) {
				if ( ( part = part.trim() ).length ) {
					parts.push( part );
				}

				parts.push( c );
				part = '';
			}
			// Read all characters in a seek sequence (url(...), "...", '...', etc)
			else if ( rvalueseek.exec( c ) ) {
				part += c;
				seek = c == '(' ? ')' : c;

				// Find end char
				for ( ; ++i < l; ) {
					c = value[ i ];
					part += c;

					// End char found, break off and attach part
					if ( c == seek ) {
						break;
					}
					// Skip over escaped values
					else if ( c == "\\" && value[ i + 1 ] ) {
						part += value[ ++i ];
					}
				}

				parts.push( part );
				part = '';
			}
			else {
				part += c;
			}
		}

		// Attach final leftover part
		if ( part.length ) {
			parts.push( part );
		}

		self.parts = parts;
	}

};

global.CSSTree.Rule = Rule;


})( this );

(function( global, undefined ) {

var rselectornested = /[:#\[\.]/,
	rselectorpart = /[>~\+\*\,]/,
	rwhitespace = /(\s|\t|\r\n|\r|\n)/;


function Selector( selector, rules, position ) {
	var self = this;

	if ( ! ( self instanceof Selector ) ) {
		return new Selector( selector, rules, position );
	}

	self.selector = ( selector || '' ).trim();
	self.position = position;
	self.parts = [];
	self.rules = rules || [];
	self.breakdown();
}

Selector.prototype = {

	breakdown: function(){
		var self = this, selector = self.selector,
			parts = [], nested = null, part = '',
			i = -1, l = selector.length, c = '',
			innerSeek = null;

		for ( ; ++i < l; ) {
			c = selector[ i ];

			// Selector breaker (whitespace, comma, etc...)
			if ( rselectorpart.exec( c ) || rwhitespace.exec( c ) ) {
				part = part.trim();

				if ( nested !== null ) {
					if ( part.length ) {
						nested.push( part );
					}

					parts.push( nested );
				}
				else if ( part.length ) {
					parts.push( part );
				}

				if ( ! rwhitespace.exec( c ) ) {
					parts.push( c );
				}

				nested = null;
				part = '';
			}
			// Inside selector, but still need to break apart ('span.class')
			else if ( part.length && rselectornested.exec( c ) ) {
				part = part.trim();

				// Catch whitespace parts and just continue on
				if ( ! part.length ) {
					part = c;
					continue;
				}

				// Add part to nested array
				if ( nested === null ) {
					nested = [ part ];
				}
				else {
					nested.push( part );
				}

				// Create new part
				part = c;

				// Seek to closing brace
				if ( c == '[' ) {
					for ( ; ++i < l; ) {
						c = selector[ i ];
						part += c;

						if ( c == "\\" ) {
							part += selector[ ++i ];
						}
						else if ( innerSeek !== null ) {
							if ( c == innerSeek ) {
								innerSeek = null;
							}
						}
						else if ( c == '"' || c == "'" ) {
							innerSeek = c;
						}
						else if ( c == ']' ) {
							nested.push( part );
							part = '';
							break;
						}
					}
				}
			}
			else {
				part += c;
			}
		}

		// Catch the last part if it exists
		if ( ( part = part.trim() ).length || nested !== null ) {
			if ( nested !== null ) {
				if ( part.length ) {
					nested.push( part );
				}

				parts.push( nested );
			}
			else {
				parts.push( part );
			}
		}

		// Apply parts back to object
		self.parts = parts;
	}

};

global.CSSTree.Selector = Selector;


})( this );