"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const arg_1 = __importDefault(require("arg"));
const valid_arguments_1 = require("./valid-arguments");
const file_utils_1 = require("../utils/file.utils");
const ora_1 = __importDefault(require("ora"));
const cli_spinners_1 = require("cli-spinners");
const enquirer_1 = require("enquirer");
const path_1 = __importDefault(require("path"));
const main_1 = require("../main");
function parseArgumentsIntoOptions(rawArgs) {
    const args = arg_1.default(valid_arguments_1.validArguments, {
        argv: rawArgs.slice(2),
    });
    return {
        input: args["--input"] || undefined,
        output: args["--output"] || undefined,
        overwriteOutput: args["--overwrite"] || undefined
    };
}
function promptForAnswers(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.input) {
            const answer = yield enquirer_1.prompt({
                type: "input",
                name: "input",
                initial: (yield file_utils_1.doesFileExist("./package.json")) ? "./package.json" : "",
                message: "package.json location:"
            });
            options.input = answer.input;
        }
        while (!options.output || options.overwriteOutput === false) {
            const answer = yield enquirer_1.prompt({
                type: "input",
                name: "output",
                initial: "3rd-party-licenses.txt",
                message: "Output file location:"
            });
            options.output = answer.output;
            if (yield file_utils_1.doesFileExist(options.output)) {
                const yesNoAnswer = yield enquirer_1.prompt({
                    type: "confirm",
                    name: "overwriteOutput",
                    message: "The given output file already exists and will be overwritten. Is this OK?"
                });
                options.overwriteOutput = yesNoAnswer.overwriteOutput;
            }
        }
        return options;
    });
}
function cli(args) {
    return __awaiter(this, void 0, void 0, function* () {
        let options = parseArgumentsIntoOptions(args);
        options = yield promptForAnswers(options);
        const spinner = ora_1.default({
            spinner: cli_spinners_1.pong,
            text: "Resolving licenses..."
        });
        spinner.start();
        const directory = path_1.default.dirname(options.input);
        yield main_1.generateLicenseFile(directory, options.output);
        spinner.stop();
    });
}
exports.cli = cli;
